From be40c684a05001a8a9f810e83205a28673899ab8 Mon Sep 17 00:00:00 2001
From: jony zhang <jony.zhang@nxp.com>
Date: Tue, 21 Oct 2025 15:14:04 +0800
Subject: [PATCH 6/6] add imx8mm imx8mp and imx93 support

- soem_gpio_pulse
- soem_servo_motor
- soem_servo_motor_rt1180

Signed-off-by: jony zhang <jony.zhang@nxp.com>
Upstream-Status: Pending
---
 .../soem_examples/soem_gpio_pulse/bm/app.h    |  48 ++
 .../soem_gpio_pulse/bm/board.readme           |  25 +
 .../bm/example_board_readme.md                |  27 +
 .../soem_gpio_pulse/bm/hardware_init.c        |  75 +++
 .../soem_gpio_pulse/bm/pin_mux.c              |  98 ++++
 .../soem_gpio_pulse/bm/pin_mux.h              |  54 ++
 .../soem_examples/soem_gpio_pulse/bm/prj.conf |   8 +
 .../soem_gpio_pulse/bm/reconfig.cmake         |  14 +
 .../soem_gpio_pulse/freertos/app.h            |  48 ++
 .../soem_gpio_pulse/freertos/board.readme     |  25 +
 .../freertos/example_board_readme.md          |  27 +
 .../soem_gpio_pulse/freertos/hardware_init.c  |  75 +++
 .../soem_gpio_pulse/freertos/pin_mux.c        |  98 ++++
 .../soem_gpio_pulse/freertos/pin_mux.h        |  54 ++
 .../soem_gpio_pulse/freertos/prj.conf         |   9 +
 .../soem_gpio_pulse/freertos/reconfig.cmake   |  14 +
 .../soem_examples/soem_servo_motor/bm/app.h   |  78 +++
 .../soem_servo_motor/bm/board.readme          |  25 +
 .../bm/example_board_readme.md                |  27 +
 .../soem_servo_motor/bm/hardware_init.c       | 211 +++++++
 .../soem_servo_motor/bm/pin_mux.c             |  98 ++++
 .../soem_servo_motor/bm/pin_mux.h             |  54 ++
 .../soem_servo_motor/bm/prj.conf              |   8 +
 .../soem_servo_motor/bm/reconfig.cmake        |  14 +
 .../soem_servo_motor/freertos/app.h           |  73 +++
 .../soem_servo_motor/freertos/board.readme    |  25 +
 .../freertos/example_board_readme.md          |  27 +
 .../soem_servo_motor/freertos/hardware_init.c |  73 +++
 .../soem_servo_motor/freertos/pin_mux.c       |  98 ++++
 .../soem_servo_motor/freertos/pin_mux.h       |  54 ++
 .../soem_servo_motor/freertos/prj.conf        |   9 +
 .../soem_servo_motor/freertos/reconfig.cmake  |  14 +
 .../soem_servo_motor_rt1180/bm/app.h          |  83 +++
 .../soem_servo_motor_rt1180/bm/board.readme   |  25 +
 .../bm/example_board_readme.md                |  27 +
 .../bm/hardware_init.c                        | 276 +++++++++
 .../soem_servo_motor_rt1180/bm/pin_mux.c      |  98 ++++
 .../soem_servo_motor_rt1180/bm/pin_mux.h      |  54 ++
 .../soem_servo_motor_rt1180/bm/prj.conf       |   8 +
 .../soem_servo_motor_rt1180/bm/reconfig.cmake |  14 +
 .../soem_servo_motor_rt1180/freertos/app.h    |  73 +++
 .../freertos/board.readme                     |  25 +
 .../freertos/example_board_readme.md          |  27 +
 .../freertos/hardware_init.c                  |  73 +++
 .../freertos/pin_mux.c                        |  98 ++++
 .../freertos/pin_mux.h                        |  54 ++
 .../soem_servo_motor_rt1180/freertos/prj.conf |   9 +
 .../freertos/reconfig.cmake                   |  14 +
 .../soem_examples/soem_gpio_pulse/bm/app.h    |  47 ++
 .../soem_gpio_pulse/bm/board.readme           |  25 +
 .../bm/example_board_readme.md                |  27 +
 .../soem_gpio_pulse/bm/hardware_init.c        |  81 +++
 .../soem_gpio_pulse/bm/pin_mux.c              | 147 +++++
 .../soem_gpio_pulse/bm/pin_mux.h              |  56 ++
 .../soem_examples/soem_gpio_pulse/bm/prj.conf |   8 +
 .../soem_gpio_pulse/bm/reconfig.cmake         |  14 +
 .../soem_gpio_pulse/freertos/app.h            |  47 ++
 .../soem_gpio_pulse/freertos/board.readme     |  25 +
 .../freertos/example_board_readme.md          |  27 +
 .../soem_gpio_pulse/freertos/hardware_init.c  |  81 +++
 .../soem_gpio_pulse/freertos/pin_mux.c        | 147 +++++
 .../soem_gpio_pulse/freertos/pin_mux.h        |  56 ++
 .../soem_gpio_pulse/freertos/prj.conf         |   9 +
 .../soem_gpio_pulse/freertos/reconfig.cmake   |  14 +
 .../soem_examples/soem_servo_motor/bm/app.h   |  77 +++
 .../soem_servo_motor/bm/board.readme          |  25 +
 .../bm/example_board_readme.md                |  27 +
 .../soem_servo_motor/bm/hardware_init.c       | 217 +++++++
 .../soem_servo_motor/bm/pin_mux.c             | 147 +++++
 .../soem_servo_motor/bm/pin_mux.h             |  56 ++
 .../soem_servo_motor/bm/prj.conf              |   8 +
 .../soem_servo_motor/bm/reconfig.cmake        |  14 +
 .../soem_servo_motor/freertos/app.h           |  73 +++
 .../soem_servo_motor/freertos/board.readme    |  25 +
 .../freertos/example_board_readme.md          |  27 +
 .../soem_servo_motor/freertos/hardware_init.c |  79 +++
 .../soem_servo_motor/freertos/pin_mux.c       | 147 +++++
 .../soem_servo_motor/freertos/pin_mux.h       |  56 ++
 .../soem_servo_motor/freertos/prj.conf        |   9 +
 .../soem_servo_motor/freertos/reconfig.cmake  |  14 +
 .../soem_servo_motor_rt1180/bm/app.h          |  82 +++
 .../soem_servo_motor_rt1180/bm/board.readme   |  25 +
 .../bm/example_board_readme.md                |  27 +
 .../bm/hardware_init.c                        | 282 +++++++++
 .../soem_servo_motor_rt1180/bm/pin_mux.c      | 147 +++++
 .../soem_servo_motor_rt1180/bm/pin_mux.h      |  56 ++
 .../soem_servo_motor_rt1180/bm/prj.conf       |   8 +
 .../soem_servo_motor_rt1180/bm/reconfig.cmake |  14 +
 .../soem_servo_motor_rt1180/freertos/app.h    |  73 +++
 .../freertos/board.readme                     |  25 +
 .../freertos/example_board_readme.md          |  27 +
 .../freertos/hardware_init.c                  |  79 +++
 .../freertos/pin_mux.c                        | 147 +++++
 .../freertos/pin_mux.h                        |  56 ++
 .../soem_servo_motor_rt1180/freertos/prj.conf |   9 +
 .../freertos/reconfig.cmake                   |  14 +
 .../soem_examples/soem_servo_motor/bm/app.h   |  88 +++
 .../soem_servo_motor/bm/board.readme          |  25 +
 .../bm/example_board_readme.md                |  27 +
 .../soem_servo_motor/bm/hardware_init.c       | 251 ++++++++
 .../soem_servo_motor/bm/pin_mux.c             | 154 +++++
 .../soem_servo_motor/bm/pin_mux.h             |  53 ++
 .../soem_servo_motor/bm/prj.conf              |   9 +
 .../soem_servo_motor/bm/reconfig.cmake        |  10 +
 .../soem_servo_motor_rt1180/bm/app.h          |  93 +++
 .../soem_servo_motor_rt1180/bm/board.readme   |  25 +
 .../bm/example_board_readme.md                |  27 +
 .../bm/hardware_init.c                        | 316 +++++++++++
 .../soem_servo_motor_rt1180/bm/pin_mux.c      | 154 +++++
 .../soem_servo_motor_rt1180/bm/pin_mux.h      |  53 ++
 .../soem_servo_motor_rt1180/bm/prj.conf       |   9 +
 .../soem_servo_motor_rt1180/bm/reconfig.cmake |  10 +
 .../soem_gpio_pulse/bm/soem_gpio_pulse.c      |   4 +
 .../soem_gpio_pulse/freertos/CMakeLists.txt   |  12 -
 .../freertos/soem_gpio_pulse.c                |   6 +-
 .../soem_servo_motor/bm/soem_servo_motor.c    |  23 +-
 .../soem_servo_motor/freertos/CMakeLists.txt  |  27 +
 .../freertos/FreeRTOSConfig.h                 | 122 ++++
 .../soem_servo_motor/freertos/axis_nc.c       | 308 ++++++++++
 .../soem_servo_motor/freertos/axis_nc.h       |  79 +++
 .../soem_servo_motor/freertos/cia402.c        | 161 ++++++
 .../soem_servo_motor/freertos/cia402.h        |  62 ++
 .../soem_servo_motor/freertos/example.yml     |  14 +
 .../soem_servo_motor/freertos/prj.conf        |   1 +
 .../soem_servo_motor/freertos/readme.md       |  60 ++
 .../soem_servo_motor/freertos/servo.c         |  58 ++
 .../soem_servo_motor/freertos/servo.h         |  26 +
 .../freertos/soem_servo_motor.c               | 534 ++++++++++++++++++
 .../bm/soem_servo_motor.c                     |   2 +-
 .../freertos/CMakeLists.txt                   |  27 +
 .../freertos/FreeRTOSConfig.h                 | 122 ++++
 .../freertos/axis_nc.c                        | 308 ++++++++++
 .../freertos/axis_nc.h                        |  79 +++
 .../soem_servo_motor_rt1180/freertos/cia402.c | 161 ++++++
 .../soem_servo_motor_rt1180/freertos/cia402.h |  62 ++
 .../freertos/example.yml                      |  14 +
 .../soem_servo_motor_rt1180/freertos/prj.conf |   1 +
 .../freertos/readme.md                        |  60 ++
 .../soem_servo_motor_rt1180/freertos/servo.c  |  58 ++
 .../soem_servo_motor_rt1180/freertos/servo.h  |  26 +
 .../freertos/soem_servo_motor.c               | 479 ++++++++++++++++
 141 files changed, 9592 insertions(+), 36 deletions(-)
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/app.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/board.readme
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/example_board_readme.md
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/hardware_init.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/pin_mux.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/pin_mux.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/prj.conf
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/reconfig.cmake
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/app.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/board.readme
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/example_board_readme.md
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/hardware_init.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/pin_mux.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/pin_mux.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/prj.conf
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/reconfig.cmake
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/app.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/board.readme
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/example_board_readme.md
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/hardware_init.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/pin_mux.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/pin_mux.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/prj.conf
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/reconfig.cmake
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/app.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/board.readme
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/example_board_readme.md
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/hardware_init.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/pin_mux.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/pin_mux.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/prj.conf
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/reconfig.cmake
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/app.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/board.readme
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/prj.conf
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/app.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/board.readme
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/example_board_readme.md
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/hardware_init.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.c
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.h
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf
 create mode 100644 _boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/reconfig.cmake
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/app.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/board.readme
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/example_board_readme.md
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/hardware_init.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/pin_mux.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/pin_mux.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/prj.conf
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/reconfig.cmake
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/app.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/board.readme
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/example_board_readme.md
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/hardware_init.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/pin_mux.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/pin_mux.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/prj.conf
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/reconfig.cmake
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/app.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/board.readme
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/example_board_readme.md
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/hardware_init.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/pin_mux.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/pin_mux.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/prj.conf
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/reconfig.cmake
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/app.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/board.readme
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/example_board_readme.md
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/hardware_init.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/pin_mux.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/pin_mux.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/prj.conf
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/reconfig.cmake
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/app.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/board.readme
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/prj.conf
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/app.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/board.readme
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/example_board_readme.md
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/hardware_init.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.c
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.h
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf
 create mode 100644 _boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/reconfig.cmake
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor/bm/app.h
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor/bm/board.readme
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor/bm/example_board_readme.md
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor/bm/hardware_init.c
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor/bm/pin_mux.c
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor/bm/pin_mux.h
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor/bm/prj.conf
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor/bm/reconfig.cmake
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/app.h
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/board.readme
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/prj.conf
 create mode 100644 _boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake
 create mode 100644 soem_examples/soem_servo_motor/freertos/CMakeLists.txt
 create mode 100644 soem_examples/soem_servo_motor/freertos/FreeRTOSConfig.h
 create mode 100644 soem_examples/soem_servo_motor/freertos/axis_nc.c
 create mode 100644 soem_examples/soem_servo_motor/freertos/axis_nc.h
 create mode 100644 soem_examples/soem_servo_motor/freertos/cia402.c
 create mode 100644 soem_examples/soem_servo_motor/freertos/cia402.h
 create mode 100644 soem_examples/soem_servo_motor/freertos/example.yml
 create mode 100644 soem_examples/soem_servo_motor/freertos/prj.conf
 create mode 100644 soem_examples/soem_servo_motor/freertos/readme.md
 create mode 100644 soem_examples/soem_servo_motor/freertos/servo.c
 create mode 100644 soem_examples/soem_servo_motor/freertos/servo.h
 create mode 100644 soem_examples/soem_servo_motor/freertos/soem_servo_motor.c
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/CMakeLists.txt
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/FreeRTOSConfig.h
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.c
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.h
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/cia402.c
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/cia402.h
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/example.yml
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/prj.conf
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/readme.md
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/servo.c
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/servo.h
 create mode 100644 soem_examples/soem_servo_motor_rt1180/freertos/soem_servo_motor.c

diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/app.h b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/app.h
new file mode 100644
index 000000000..0fc195fbf
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/app.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyar8031.h"
+#include "fsl_gpt.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+/* Ethernet configuration. */
+extern phy_ar8031_resource_t g_phy_resource;
+
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x00U
+#define EXAMPLE_PHY_OPS      &phyar8031_ops
+#define EXAMPLE_PHY_RESOURCE &g_phy_resource
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+/*${macro:end}*/
+
+/*${prototype:start}*/
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (800000U)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (500000U)
+#endif
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ                                                                \
+    (CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+     
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/board.readme b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/board.readme
new file mode 100644
index 000000000..fd006eab0
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/example_board_readme.md b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/example_board_readme.md
new file mode 100644
index 000000000..289add957
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/hardware_init.c b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/hardware_init.c
new file mode 100644
index 000000000..78fad45ba
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/hardware_init.c
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_ar8031_resource_t g_phy_resource;
+/*${variable:end}*/
+
+/*${function:start}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+void BOARD_InitHardware()
+{
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+    BOARD_InitMemory();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4);      /* SYSTEM PLL2 divided by 4: 125Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8);      /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 22U, &gpio_config);
+    GPIO_WritePinOutput(GPIO4, 22U, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 22U, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/pin_mux.c b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/pin_mux.c
new file mode 100644
index 000000000..8d7f59478
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/pin_mux.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v11.0
+processor: MIMX8MM6xxxLZ
+package_id: MIMX8MM6DVTLZ
+mcu_data: ksdk2_0
+processor_version: 0.11.3
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', prefix: BOARD_, coreID: cm4}
+- pin_list:
+  - {pin_num: F19, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: F18, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: AE27, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: ENET_RD0}
+  - {pin_num: AD27, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: ENET_RD1}
+  - {pin_num: AD26, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: ENET_RD2}
+  - {pin_num: AC26, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: ENET_RD3}
+  - {pin_num: AF27, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: ENET_RX_CTL}
+  - {pin_num: AE26, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: ENET_RXC}
+  - {pin_num: AG26, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: ENET_TD0}
+  - {pin_num: AF26, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: ENET_TD1}
+  - {pin_num: AG25, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: ENET_TD2}
+  - {pin_num: AF25, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: ENET_TD3}
+  - {pin_num: AF24, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: ENET_TX_CTL}
+  - {pin_num: AG24, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: ENET_TXC}
+  - {pin_num: AB22, peripheral: GPIO4, signal: 'gpio_io, 22', pin_signal: SAI2_RXC}
+  - {pin_num: AB27, peripheral: ENET1, signal: enet_mdio, pin_signal: ENET_MDIO}
+  - {pin_num: AC27, peripheral: ENET1, signal: enet_mdc, pin_signal: ENET_MDC}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: undefined[cm4] */
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDC_ENET1_MDC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDIO_ENET1_MDIO, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD0_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD1_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD2_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD3_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TXC_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI2_RXC_GPIO4_IO22, 0U);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/pin_mux.h b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/pin_mux.h
new file mode 100644
index 000000000..99a855a40
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/pin_mux.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: undefined[cm4] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/prj.conf b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/prj.conf
new file mode 100644
index 000000000..549a2888b
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MCUX_COMPONENT_component.phyar8031=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_lmem=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.bm=y
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/reconfig.cmake b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/reconfig.cmake
new file mode 100644
index 000000000..9efe7f9dc
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/bm/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/app.h b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/app.h
new file mode 100644
index 000000000..0fc195fbf
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/app.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyar8031.h"
+#include "fsl_gpt.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+/* Ethernet configuration. */
+extern phy_ar8031_resource_t g_phy_resource;
+
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x00U
+#define EXAMPLE_PHY_OPS      &phyar8031_ops
+#define EXAMPLE_PHY_RESOURCE &g_phy_resource
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+/*${macro:end}*/
+
+/*${prototype:start}*/
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (800000U)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (500000U)
+#endif
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ                                                                \
+    (CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+     
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/board.readme b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/board.readme
new file mode 100644
index 000000000..fd006eab0
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/example_board_readme.md b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/example_board_readme.md
new file mode 100644
index 000000000..289add957
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/hardware_init.c b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/hardware_init.c
new file mode 100644
index 000000000..78fad45ba
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/hardware_init.c
@@ -0,0 +1,75 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_ar8031_resource_t g_phy_resource;
+/*${variable:end}*/
+
+/*${function:start}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+void BOARD_InitHardware()
+{
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+    BOARD_InitMemory();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4);      /* SYSTEM PLL2 divided by 4: 125Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8);      /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 22U, &gpio_config);
+    GPIO_WritePinOutput(GPIO4, 22U, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 22U, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/pin_mux.c b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/pin_mux.c
new file mode 100644
index 000000000..8d7f59478
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/pin_mux.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v11.0
+processor: MIMX8MM6xxxLZ
+package_id: MIMX8MM6DVTLZ
+mcu_data: ksdk2_0
+processor_version: 0.11.3
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', prefix: BOARD_, coreID: cm4}
+- pin_list:
+  - {pin_num: F19, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: F18, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: AE27, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: ENET_RD0}
+  - {pin_num: AD27, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: ENET_RD1}
+  - {pin_num: AD26, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: ENET_RD2}
+  - {pin_num: AC26, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: ENET_RD3}
+  - {pin_num: AF27, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: ENET_RX_CTL}
+  - {pin_num: AE26, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: ENET_RXC}
+  - {pin_num: AG26, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: ENET_TD0}
+  - {pin_num: AF26, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: ENET_TD1}
+  - {pin_num: AG25, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: ENET_TD2}
+  - {pin_num: AF25, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: ENET_TD3}
+  - {pin_num: AF24, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: ENET_TX_CTL}
+  - {pin_num: AG24, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: ENET_TXC}
+  - {pin_num: AB22, peripheral: GPIO4, signal: 'gpio_io, 22', pin_signal: SAI2_RXC}
+  - {pin_num: AB27, peripheral: ENET1, signal: enet_mdio, pin_signal: ENET_MDIO}
+  - {pin_num: AC27, peripheral: ENET1, signal: enet_mdc, pin_signal: ENET_MDC}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: undefined[cm4] */
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDC_ENET1_MDC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDIO_ENET1_MDIO, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD0_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD1_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD2_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD3_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TXC_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI2_RXC_GPIO4_IO22, 0U);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/pin_mux.h b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/pin_mux.h
new file mode 100644
index 000000000..99a855a40
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/pin_mux.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: undefined[cm4] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/prj.conf b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/prj.conf
new file mode 100644
index 000000000..1f1576550
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MCUX_COMPONENT_component.phyar8031=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_lmem=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.freertos-kernel=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.freertos=y
diff --git a/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/reconfig.cmake b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/reconfig.cmake
new file mode 100644
index 000000000..472d9ed57
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_gpio_pulse/freertos/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=12\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/app.h b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/app.h
new file mode 100644
index 000000000..0e77d1e09
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/app.h
@@ -0,0 +1,78 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyar8031.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+#define EXAMPLE_ENET_NUM    1U
+#define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x00U
+#define EXAMPLE_PHY_OPS      &phyar8031_ops
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+#define CLOCK_GRANULARITY_NS 40UL
+#define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
+#define CLOCK_INCREASE_PER_SEC 1000000000UL 
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (800000U)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (500000U)
+#endif
+
+#define SOEM_PORT_NAME "enet0"
+#define ENET_RXBD_NUM          (1)
+#define ENET_TXBD_NUM          (1)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ                                                                \
+    (CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+     
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+uint64_t gettime(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+void osal_timer_init(uint32_t priority);
+int if_port_init(void);
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/board.readme b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/board.readme
new file mode 100644
index 000000000..fd006eab0
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/example_board_readme.md b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/example_board_readme.md
new file mode 100644
index 000000000..289add957
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/hardware_init.c b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/hardware_init.c
new file mode 100644
index 000000000..935b04517
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/hardware_init.c
@@ -0,0 +1,211 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_ar8031_resource_t g_phy_resource;
+
+volatile uint64_t system_time_ns = 0;
+
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+
+enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+uint64_t gettime()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > gettime());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = gettime();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+struct enet_if_port if_port;
+
+int if_port_init()
+{
+	struct soem_if_port soem_port;
+	memset(&if_port, 0, sizeof(if_port));
+	if_port.bufferConfig = buffConfig;
+	if_port.base = EXAMPLE_ENET;
+/* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+	if_port.mii_mode = kENET_RgmiiMode;
+#else
+	if_port.mii_mode = kENET_RmiiMode;
+#endif
+	g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    if_port.phy_config.autoNeg = true;
+    if_port.phy_config.phyAddr = EXAMPLE_PHY_ADDRESS;
+	if_port.phy_config.ops = &phyar8031_ops;
+	if_port.phy_config.resource = &g_phy_resource;
+
+    if_port.srcClock_Hz = EXAMPLE_CLOCK_FREQ;
+    if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+    if_port.phy_stability_delay_us = PHY_STABILITY_DELAY_US;
+
+    soem_port.port_init = enet_init;
+    soem_port.port_send = enet_send;
+    soem_port.port_recv = enet_recv;
+    soem_port.port_link_status = enet_link_status;
+    soem_port.port_close = enet_close;
+    strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+    strncpy(soem_port.dev_name, "enet", SOEM_DEV_NAME_MAXLEN);
+    soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+void BOARD_InitHardware()
+{
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+    BOARD_InitMemory();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4);      /* SYSTEM PLL2 divided by 4: 125Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8);      /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 22U, &gpio_config);
+    GPIO_WritePinOutput(GPIO4, 22U, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 22U, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/pin_mux.c b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/pin_mux.c
new file mode 100644
index 000000000..8d7f59478
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/pin_mux.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v11.0
+processor: MIMX8MM6xxxLZ
+package_id: MIMX8MM6DVTLZ
+mcu_data: ksdk2_0
+processor_version: 0.11.3
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', prefix: BOARD_, coreID: cm4}
+- pin_list:
+  - {pin_num: F19, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: F18, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: AE27, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: ENET_RD0}
+  - {pin_num: AD27, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: ENET_RD1}
+  - {pin_num: AD26, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: ENET_RD2}
+  - {pin_num: AC26, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: ENET_RD3}
+  - {pin_num: AF27, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: ENET_RX_CTL}
+  - {pin_num: AE26, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: ENET_RXC}
+  - {pin_num: AG26, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: ENET_TD0}
+  - {pin_num: AF26, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: ENET_TD1}
+  - {pin_num: AG25, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: ENET_TD2}
+  - {pin_num: AF25, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: ENET_TD3}
+  - {pin_num: AF24, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: ENET_TX_CTL}
+  - {pin_num: AG24, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: ENET_TXC}
+  - {pin_num: AB22, peripheral: GPIO4, signal: 'gpio_io, 22', pin_signal: SAI2_RXC}
+  - {pin_num: AB27, peripheral: ENET1, signal: enet_mdio, pin_signal: ENET_MDIO}
+  - {pin_num: AC27, peripheral: ENET1, signal: enet_mdc, pin_signal: ENET_MDC}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: undefined[cm4] */
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDC_ENET1_MDC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDIO_ENET1_MDIO, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD0_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD1_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD2_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD3_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TXC_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI2_RXC_GPIO4_IO22, 0U);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/pin_mux.h b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/pin_mux.h
new file mode 100644
index 000000000..99a855a40
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/pin_mux.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: undefined[cm4] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/prj.conf b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/prj.conf
new file mode 100644
index 000000000..549a2888b
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MCUX_COMPONENT_component.phyar8031=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_lmem=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.bm=y
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/reconfig.cmake b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/reconfig.cmake
new file mode 100644
index 000000000..18938dda7
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/bm/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/app.h b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/app.h
new file mode 100644
index 000000000..46f899c21
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/app.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyar8031.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+extern phy_ar8031_resource_t g_phy_resource;
+#define EXAMPLE_ENET_NUM    1U
+#define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define SOEM_PORT_NAME       "enet1"
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x0U
+#define EXAMPLE_PHY_OPS      &phyar8031_ops
+#define EXAMPLE_PHY_RESOURCE &g_phy_resource
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (300000)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (0)
+#endif
+
+#define ENET_RXBD_NUM          (4)
+#define ENET_TXBD_NUM          (4)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ		(CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/board.readme b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/board.readme
new file mode 100644
index 000000000..fd006eab0
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/example_board_readme.md b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/example_board_readme.md
new file mode 100644
index 000000000..289add957
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/hardware_init.c b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/hardware_init.c
new file mode 100644
index 000000000..b3c62dc6f
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/hardware_init.c
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_ar8031_resource_t g_phy_resource;
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+void BOARD_InitHardware()
+{
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+    BOARD_InitMemory();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4);      /* SYSTEM PLL2 divided by 4: 125Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8);      /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 22U, &gpio_config);
+    GPIO_WritePinOutput(GPIO4, 22U, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 22U, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/pin_mux.c b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/pin_mux.c
new file mode 100644
index 000000000..8d7f59478
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/pin_mux.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v11.0
+processor: MIMX8MM6xxxLZ
+package_id: MIMX8MM6DVTLZ
+mcu_data: ksdk2_0
+processor_version: 0.11.3
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', prefix: BOARD_, coreID: cm4}
+- pin_list:
+  - {pin_num: F19, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: F18, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: AE27, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: ENET_RD0}
+  - {pin_num: AD27, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: ENET_RD1}
+  - {pin_num: AD26, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: ENET_RD2}
+  - {pin_num: AC26, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: ENET_RD3}
+  - {pin_num: AF27, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: ENET_RX_CTL}
+  - {pin_num: AE26, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: ENET_RXC}
+  - {pin_num: AG26, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: ENET_TD0}
+  - {pin_num: AF26, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: ENET_TD1}
+  - {pin_num: AG25, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: ENET_TD2}
+  - {pin_num: AF25, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: ENET_TD3}
+  - {pin_num: AF24, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: ENET_TX_CTL}
+  - {pin_num: AG24, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: ENET_TXC}
+  - {pin_num: AB22, peripheral: GPIO4, signal: 'gpio_io, 22', pin_signal: SAI2_RXC}
+  - {pin_num: AB27, peripheral: ENET1, signal: enet_mdio, pin_signal: ENET_MDIO}
+  - {pin_num: AC27, peripheral: ENET1, signal: enet_mdc, pin_signal: ENET_MDC}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: undefined[cm4] */
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDC_ENET1_MDC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDIO_ENET1_MDIO, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD0_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD1_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD2_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD3_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TXC_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI2_RXC_GPIO4_IO22, 0U);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/pin_mux.h b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/pin_mux.h
new file mode 100644
index 000000000..99a855a40
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/pin_mux.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: undefined[cm4] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/prj.conf b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/prj.conf
new file mode 100644
index 000000000..1f1576550
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MCUX_COMPONENT_component.phyar8031=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_lmem=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.freertos-kernel=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.freertos=y
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/reconfig.cmake b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/reconfig.cmake
new file mode 100644
index 000000000..18938dda7
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor/freertos/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/app.h b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/app.h
new file mode 100644
index 000000000..332e39fad
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/app.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyar8031.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+ #define EXAMPLE_ENET_NUM    1U
+ #define CYCLE_SHIFT_NS  440000  // 440us
+ #define DC_FILTER_CNT   64
+
+ #define MASTER_SLAVE_SYNC 1U
+ #define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x00U
+#define EXAMPLE_PHY_OPS      &phyar8031_ops
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+#define CLOCK_GRANULARITY_NS 40UL
+#define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
+#define CLOCK_INCREASE_PER_SEC 1000000000UL 
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (800000U)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (500000U)
+#endif
+
+#define SOEM_PORT_NAME "enet0"
+#define ENET_RXBD_NUM          (1)
+#define ENET_TXBD_NUM          (1)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ                                                                \
+    (CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+     
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+void osal_timer_init(uint32_t priority);
+uint64_t system_time64_ns(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+int if_port_init(void);
+void update_master_clock(void);
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/board.readme b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/board.readme
new file mode 100644
index 000000000..fd006eab0
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md
new file mode 100644
index 000000000..289add957
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
new file mode 100644
index 000000000..d82c43c48
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
@@ -0,0 +1,276 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+/* dc sync time */
+uint8_t  dc_started = 0;
+int32_t  dc_diff_ns = 0;
+int32_t  prev_dc_diff_ns = 0;
+int64_t  dc_adjust_ns;
+int64_t  system_time_offset = 0LL;
+
+phy_ar8031_resource_t g_phy_resource;
+
+volatile uint64_t system_time_ns = 0;
+
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+
+enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+uint64_t system_time64_ns()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS - system_time_offset;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > system_time64_ns());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = system_time64_ns();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+uint64_t dc_diff_accu = 0;
+int32_t dc_diff_accu_arrary[DC_FILTER_CNT];
+int32_t dc_diff_accu_index = 0;
+
+static void dc_diff_init(int32_t dc_diff_ns)
+{
+	int i;
+	for (i = 0; i < DC_FILTER_CNT; i++) {
+		dc_diff_accu_arrary[i] = dc_diff_ns;
+		dc_diff_accu += dc_diff_ns;
+	}
+}
+
+static int32_t dc_diff_update(int32_t dc_diff_ns)
+{
+	dc_diff_accu += dc_diff_ns;
+	dc_diff_accu -= dc_diff_accu_arrary[dc_diff_accu_index];
+	dc_diff_accu_arrary[dc_diff_accu_index++] = dc_diff_ns;
+	if (dc_diff_accu_index >= DC_FILTER_CNT) {
+		dc_diff_accu_index = 0;
+	}
+	return dc_diff_accu / DC_FILTER_CNT;
+}
+
+#define PID_P  3 / 2
+#define PID_I  3 / 2
+#define PID_D  1 / 5 
+void update_master_clock()
+{
+	int32_t dc_diff_ns_avg;
+    // calc drift (via un-normalised time diff)
+    int32_t delta = dc_diff_ns - prev_dc_diff_ns;
+    prev_dc_diff_ns = dc_diff_ns;
+
+    if (dc_started == 2) {
+		dc_diff_ns_avg = dc_diff_update(dc_diff_ns);
+       dc_adjust_ns = dc_diff_ns * PID_P  + dc_diff_ns_avg * PID_I  + delta * PID_D;
+        if (dc_adjust_ns < -10000) {
+            dc_adjust_ns = -10000;
+        }
+        if (dc_adjust_ns > 10000) {
+            dc_adjust_ns =  10000;
+        }
+		// add cycles adjustment to time base (including a spot adjustment)
+        system_time_offset += dc_adjust_ns;
+    }
+    else {
+		if (dc_started == 0) {
+        	dc_started = (dc_diff_ns != 0);
+			system_time_offset = dc_diff_ns;
+		} else {
+			dc_started = 2;
+			dc_diff_init(dc_diff_ns);
+			system_time_offset += dc_diff_ns / 2;
+		}
+    }
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+struct enet_if_port if_port;
+
+int if_port_init()
+{
+	struct soem_if_port soem_port;
+	memset(&if_port, 0, sizeof(if_port));
+	if_port.bufferConfig = buffConfig;
+	if_port.base = EXAMPLE_ENET;
+/* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+	if_port.mii_mode = kENET_RgmiiMode;
+#else
+	if_port.mii_mode = kENET_RmiiMode;
+#endif
+	g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    if_port.phy_config.autoNeg = true;
+    if_port.phy_config.phyAddr = EXAMPLE_PHY_ADDRESS;
+	if_port.phy_config.ops = &phyar8031_ops;
+	if_port.phy_config.resource = &g_phy_resource;
+
+    if_port.srcClock_Hz = EXAMPLE_CLOCK_FREQ;
+    if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+    if_port.phy_stability_delay_us = PHY_STABILITY_DELAY_US;
+
+    soem_port.port_init = enet_init;
+    soem_port.port_send = enet_send;
+    soem_port.port_recv = enet_recv;
+    soem_port.port_link_status = enet_link_status;
+    soem_port.port_close = enet_close;
+    strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+    strncpy(soem_port.dev_name, "enet", SOEM_DEV_NAME_MAXLEN);
+    soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+void BOARD_InitHardware()
+{
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+    BOARD_InitMemory();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4);      /* SYSTEM PLL2 divided by 4: 125Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8);      /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 22U, &gpio_config);
+    GPIO_WritePinOutput(GPIO4, 22U, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 22U, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c
new file mode 100644
index 000000000..8d7f59478
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v11.0
+processor: MIMX8MM6xxxLZ
+package_id: MIMX8MM6DVTLZ
+mcu_data: ksdk2_0
+processor_version: 0.11.3
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', prefix: BOARD_, coreID: cm4}
+- pin_list:
+  - {pin_num: F19, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: F18, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: AE27, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: ENET_RD0}
+  - {pin_num: AD27, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: ENET_RD1}
+  - {pin_num: AD26, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: ENET_RD2}
+  - {pin_num: AC26, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: ENET_RD3}
+  - {pin_num: AF27, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: ENET_RX_CTL}
+  - {pin_num: AE26, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: ENET_RXC}
+  - {pin_num: AG26, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: ENET_TD0}
+  - {pin_num: AF26, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: ENET_TD1}
+  - {pin_num: AG25, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: ENET_TD2}
+  - {pin_num: AF25, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: ENET_TD3}
+  - {pin_num: AF24, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: ENET_TX_CTL}
+  - {pin_num: AG24, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: ENET_TXC}
+  - {pin_num: AB22, peripheral: GPIO4, signal: 'gpio_io, 22', pin_signal: SAI2_RXC}
+  - {pin_num: AB27, peripheral: ENET1, signal: enet_mdio, pin_signal: ENET_MDIO}
+  - {pin_num: AC27, peripheral: ENET1, signal: enet_mdc, pin_signal: ENET_MDC}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: undefined[cm4] */
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDC_ENET1_MDC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDIO_ENET1_MDIO, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD0_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD1_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD2_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD3_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TXC_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI2_RXC_GPIO4_IO22, 0U);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h
new file mode 100644
index 000000000..99a855a40
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: undefined[cm4] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/prj.conf b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/prj.conf
new file mode 100644
index 000000000..549a2888b
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MCUX_COMPONENT_component.phyar8031=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_lmem=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.bm=y
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake
new file mode 100644
index 000000000..18938dda7
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/app.h b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/app.h
new file mode 100644
index 000000000..46f899c21
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/app.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyar8031.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+extern phy_ar8031_resource_t g_phy_resource;
+#define EXAMPLE_ENET_NUM    1U
+#define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define SOEM_PORT_NAME       "enet1"
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x0U
+#define EXAMPLE_PHY_OPS      &phyar8031_ops
+#define EXAMPLE_PHY_RESOURCE &g_phy_resource
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (300000)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (0)
+#endif
+
+#define ENET_RXBD_NUM          (4)
+#define ENET_TXBD_NUM          (4)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ		(CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/board.readme b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/board.readme
new file mode 100644
index 000000000..fd006eab0
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/example_board_readme.md b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/example_board_readme.md
new file mode 100644
index 000000000..289add957
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MM-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/hardware_init.c b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/hardware_init.c
new file mode 100644
index 000000000..b3c62dc6f
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/hardware_init.c
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_ar8031_resource_t g_phy_resource;
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+void BOARD_InitHardware()
+{
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+    BOARD_InitMemory();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4);      /* SYSTEM PLL2 divided by 4: 125Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8);      /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 22U, &gpio_config);
+    GPIO_WritePinOutput(GPIO4, 22U, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 22U, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.c b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.c
new file mode 100644
index 000000000..8d7f59478
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v11.0
+processor: MIMX8MM6xxxLZ
+package_id: MIMX8MM6DVTLZ
+mcu_data: ksdk2_0
+processor_version: 0.11.3
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', prefix: BOARD_, coreID: cm4}
+- pin_list:
+  - {pin_num: F19, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: F18, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: AE27, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: ENET_RD0}
+  - {pin_num: AD27, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: ENET_RD1}
+  - {pin_num: AD26, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: ENET_RD2}
+  - {pin_num: AC26, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: ENET_RD3}
+  - {pin_num: AF27, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: ENET_RX_CTL}
+  - {pin_num: AE26, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: ENET_RXC}
+  - {pin_num: AG26, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: ENET_TD0}
+  - {pin_num: AF26, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: ENET_TD1}
+  - {pin_num: AG25, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: ENET_TD2}
+  - {pin_num: AF25, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: ENET_TD3}
+  - {pin_num: AF24, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: ENET_TX_CTL}
+  - {pin_num: AG24, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: ENET_TXC}
+  - {pin_num: AB22, peripheral: GPIO4, signal: 'gpio_io, 22', pin_signal: SAI2_RXC}
+  - {pin_num: AB27, peripheral: ENET1, signal: enet_mdio, pin_signal: ENET_MDIO}
+  - {pin_num: AC27, peripheral: ENET1, signal: enet_mdc, pin_signal: ENET_MDC}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: undefined[cm4] */
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDC_ENET1_MDC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDIO_ENET1_MDIO, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD0_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD1_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD2_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD3_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TXC_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI2_RXC_GPIO4_IO22, 0U);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX,
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.h b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.h
new file mode 100644
index 000000000..99a855a40
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2022-2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: undefined[cm4] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf
new file mode 100644
index 000000000..1f1576550
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MCUX_COMPONENT_component.phyar8031=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_lmem=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.freertos-kernel=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.freertos=y
diff --git a/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/reconfig.cmake b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/reconfig.cmake
new file mode 100644
index 000000000..18938dda7
--- /dev/null
+++ b/_boards/evkmimx8mm/soem_examples/soem_servo_motor_rt1180/freertos/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/app.h b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/app.h
new file mode 100644
index 000000000..9cf07a816
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/app.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyrtl8211f.h"
+#include "fsl_gpt.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+/* Ethernet configuration. */
+extern phy_rtl8211f_resource_t g_phy_resource;
+
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x01U
+#define EXAMPLE_PHY_OPS      &phyrtl8211f_ops
+#define EXAMPLE_PHY_RESOURCE &g_phy_resource
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+/*${macro:end}*/
+
+/*${prototype:start}*/
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (300000)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (0)
+#endif
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ		(CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+     
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/board.readme b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/board.readme
new file mode 100644
index 000000000..b3056d7bf
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/example_board_readme.md b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/example_board_readme.md
new file mode 100644
index 000000000..55d5cc8d9
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/hardware_init.c b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/hardware_init.c
new file mode 100644
index 000000000..c9495da5a
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/hardware_init.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_rtl8211f_resource_t g_phy_resource;
+/*${variable:end}*/
+
+/*${function:start}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+void BOARD_InitHardware()
+{
+    BOARD_InitMemory();
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4); /* SYSTEM PLL2 divided by 4: 250Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8); /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    CLOCK_EnableClock(kCLOCK_Sim_enet);
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 2, &gpio_config);
+    /* For a complete PHY reset of RTL8211FDI-CG, this pin must be asserted low for at least 10ms. And
+     * wait for a further 30ms(for internal circuits settling time) before accessing the PHY register */
+    GPIO_WritePinOutput(GPIO4, 2, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 2, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/pin_mux.c b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/pin_mux.c
new file mode 100644
index 000000000..4902ade2b
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/pin_mux.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2019-2022 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v9.0
+processor: MIMX8ML8xxxLZ
+package_id: MIMX8ML8DVNLZ
+mcu_data: ksdk2_0
+processor_version: 0.9.1
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', coreID: cm7}
+- pin_list:
+  - {pin_num: AJ5, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH5, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH9, peripheral: ENET1, signal: enet_mdc, pin_signal: SAI1_RXD2, PE: Disabled, DSE: X2}
+  - {pin_num: AJ8, peripheral: ENET1, signal: enet_mdio, pin_signal: SAI1_RXD3, PE: Disabled, DSE: X2}
+  - {pin_num: AD10, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: SAI1_RXD4, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AE10, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: SAI1_RXD5, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH10, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: SAI1_RXD6, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH12, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: SAI1_RXD7, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AF12, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: SAI1_TXFS, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ12, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: SAI1_TXC, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ11, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: SAI1_TXD0, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AJ10, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: SAI1_TXD1, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH11, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: SAI1_TXD2, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AD12, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: SAI1_TXD3, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH13, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: SAI1_TXD4, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH14, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: SAI1_TXD5, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AC10, peripheral: GPIO4, signal: 'gpio_io, 02', pin_signal: SAI1_RXD0, PE: Disabled, FSEL: Slow, DSE: X1}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: Cortex-M7F[m7] */
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD2_ENET1_MDC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD2_ENET1_MDC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD3_ENET1_MDIO, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD3_ENET1_MDIO, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/pin_mux.h b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/pin_mux.h
new file mode 100644
index 000000000..2c3322754
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/pin_mux.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2019-2020, 2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: Cortex-M7F[m7] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/prj.conf b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/prj.conf
new file mode 100644
index 000000000..7a7122d01
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MCUX_COMPONENT_component.phyrtl8211f=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_armv7_m7=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.bm=y
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/reconfig.cmake b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/reconfig.cmake
new file mode 100644
index 000000000..18938dda7
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/bm/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/app.h b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/app.h
new file mode 100644
index 000000000..9cf07a816
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/app.h
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyrtl8211f.h"
+#include "fsl_gpt.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+/* Ethernet configuration. */
+extern phy_rtl8211f_resource_t g_phy_resource;
+
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x01U
+#define EXAMPLE_PHY_OPS      &phyrtl8211f_ops
+#define EXAMPLE_PHY_RESOURCE &g_phy_resource
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+/*${macro:end}*/
+
+/*${prototype:start}*/
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (300000)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (0)
+#endif
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ		(CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+     
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/board.readme b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/board.readme
new file mode 100644
index 000000000..b3056d7bf
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/example_board_readme.md b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/example_board_readme.md
new file mode 100644
index 000000000..55d5cc8d9
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/hardware_init.c b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/hardware_init.c
new file mode 100644
index 000000000..c9495da5a
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/hardware_init.c
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_rtl8211f_resource_t g_phy_resource;
+/*${variable:end}*/
+
+/*${function:start}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+void BOARD_InitHardware()
+{
+    BOARD_InitMemory();
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4); /* SYSTEM PLL2 divided by 4: 250Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8); /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    CLOCK_EnableClock(kCLOCK_Sim_enet);
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 2, &gpio_config);
+    /* For a complete PHY reset of RTL8211FDI-CG, this pin must be asserted low for at least 10ms. And
+     * wait for a further 30ms(for internal circuits settling time) before accessing the PHY register */
+    GPIO_WritePinOutput(GPIO4, 2, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 2, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/pin_mux.c b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/pin_mux.c
new file mode 100644
index 000000000..4902ade2b
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/pin_mux.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2019-2022 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v9.0
+processor: MIMX8ML8xxxLZ
+package_id: MIMX8ML8DVNLZ
+mcu_data: ksdk2_0
+processor_version: 0.9.1
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', coreID: cm7}
+- pin_list:
+  - {pin_num: AJ5, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH5, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH9, peripheral: ENET1, signal: enet_mdc, pin_signal: SAI1_RXD2, PE: Disabled, DSE: X2}
+  - {pin_num: AJ8, peripheral: ENET1, signal: enet_mdio, pin_signal: SAI1_RXD3, PE: Disabled, DSE: X2}
+  - {pin_num: AD10, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: SAI1_RXD4, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AE10, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: SAI1_RXD5, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH10, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: SAI1_RXD6, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH12, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: SAI1_RXD7, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AF12, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: SAI1_TXFS, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ12, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: SAI1_TXC, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ11, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: SAI1_TXD0, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AJ10, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: SAI1_TXD1, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH11, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: SAI1_TXD2, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AD12, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: SAI1_TXD3, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH13, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: SAI1_TXD4, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH14, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: SAI1_TXD5, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AC10, peripheral: GPIO4, signal: 'gpio_io, 02', pin_signal: SAI1_RXD0, PE: Disabled, FSEL: Slow, DSE: X1}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: Cortex-M7F[m7] */
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD2_ENET1_MDC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD2_ENET1_MDC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD3_ENET1_MDIO, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD3_ENET1_MDIO, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/pin_mux.h b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/pin_mux.h
new file mode 100644
index 000000000..2c3322754
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/pin_mux.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2019-2020, 2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: Cortex-M7F[m7] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/prj.conf b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/prj.conf
new file mode 100644
index 000000000..ee38fb7e1
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MCUX_COMPONENT_component.phyrtl8211f=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_armv7_m7=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.freertos-kernel=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.freertos=y
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/reconfig.cmake b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/reconfig.cmake
new file mode 100644
index 000000000..945516079
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_gpio_pulse/freertos/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=12\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/app.h b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/app.h
new file mode 100644
index 000000000..6ce570230
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/app.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyrtl8211f.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+#define EXAMPLE_ENET_NUM    1U
+#define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x01U
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+#define CLOCK_GRANULARITY_NS 40UL
+#define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
+#define CLOCK_INCREASE_PER_SEC 1000000000UL 
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (800000U)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (500000U)
+#endif
+
+#define SOEM_PORT_NAME "enet1"
+#define ENET_RXBD_NUM          (1)
+#define ENET_TXBD_NUM          (1)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ                                                                \
+    (CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+     
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+uint64_t gettime(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+void osal_timer_init(uint32_t priority);
+int if_port_init(void);
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/board.readme b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/board.readme
new file mode 100644
index 000000000..b3056d7bf
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/example_board_readme.md b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/example_board_readme.md
new file mode 100644
index 000000000..55d5cc8d9
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/hardware_init.c b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/hardware_init.c
new file mode 100644
index 000000000..bf96eef2a
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/hardware_init.c
@@ -0,0 +1,217 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_rtl8211f_resource_t g_phy_resource;
+
+volatile uint64_t system_time_ns = 0;
+
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+
+enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+uint64_t gettime()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > gettime());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = gettime();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+struct enet_if_port if_port;
+
+int if_port_init()
+{
+	struct soem_if_port soem_port;
+	memset(&if_port, 0, sizeof(if_port));
+	if_port.bufferConfig = buffConfig;
+	if_port.base = EXAMPLE_ENET;
+/* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+	if_port.mii_mode = kENET_RgmiiMode;
+#else
+	if_port.mii_mode = kENET_RmiiMode;
+#endif
+	g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    if_port.phy_config.autoNeg = true;
+    if_port.phy_config.phyAddr = EXAMPLE_PHY_ADDRESS;
+	if_port.phy_config.ops = &phyrtl8211f_ops;
+	if_port.phy_config.resource = &g_phy_resource;
+
+    if_port.srcClock_Hz = EXAMPLE_CLOCK_FREQ;
+    if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+    if_port.phy_stability_delay_us = PHY_STABILITY_DELAY_US;
+
+    soem_port.port_init = enet_init;
+    soem_port.port_send = enet_send;
+    soem_port.port_recv = enet_recv;
+    soem_port.port_link_status = enet_link_status;
+    soem_port.port_close = enet_close;
+    strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+    strncpy(soem_port.dev_name, "enet", SOEM_DEV_NAME_MAXLEN);
+    soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+void BOARD_InitHardware()
+{
+    BOARD_InitMemory();
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4); /* SYSTEM PLL2 divided by 4: 250Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8); /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    CLOCK_EnableClock(kCLOCK_Sim_enet);
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 2, &gpio_config);
+    /* For a complete PHY reset of RTL8211FDI-CG, this pin must be asserted low for at least 10ms. And
+     * wait for a further 30ms(for internal circuits settling time) before accessing the PHY register */
+    GPIO_WritePinOutput(GPIO4, 2, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 2, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/pin_mux.c b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/pin_mux.c
new file mode 100644
index 000000000..4902ade2b
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/pin_mux.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2019-2022 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v9.0
+processor: MIMX8ML8xxxLZ
+package_id: MIMX8ML8DVNLZ
+mcu_data: ksdk2_0
+processor_version: 0.9.1
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', coreID: cm7}
+- pin_list:
+  - {pin_num: AJ5, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH5, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH9, peripheral: ENET1, signal: enet_mdc, pin_signal: SAI1_RXD2, PE: Disabled, DSE: X2}
+  - {pin_num: AJ8, peripheral: ENET1, signal: enet_mdio, pin_signal: SAI1_RXD3, PE: Disabled, DSE: X2}
+  - {pin_num: AD10, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: SAI1_RXD4, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AE10, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: SAI1_RXD5, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH10, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: SAI1_RXD6, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH12, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: SAI1_RXD7, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AF12, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: SAI1_TXFS, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ12, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: SAI1_TXC, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ11, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: SAI1_TXD0, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AJ10, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: SAI1_TXD1, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH11, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: SAI1_TXD2, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AD12, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: SAI1_TXD3, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH13, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: SAI1_TXD4, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH14, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: SAI1_TXD5, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AC10, peripheral: GPIO4, signal: 'gpio_io, 02', pin_signal: SAI1_RXD0, PE: Disabled, FSEL: Slow, DSE: X1}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: Cortex-M7F[m7] */
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD2_ENET1_MDC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD2_ENET1_MDC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD3_ENET1_MDIO, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD3_ENET1_MDIO, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/pin_mux.h b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/pin_mux.h
new file mode 100644
index 000000000..2c3322754
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/pin_mux.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2019-2020, 2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: Cortex-M7F[m7] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/prj.conf b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/prj.conf
new file mode 100644
index 000000000..7a7122d01
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MCUX_COMPONENT_component.phyrtl8211f=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_armv7_m7=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.bm=y
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/reconfig.cmake b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/reconfig.cmake
new file mode 100644
index 000000000..18938dda7
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/bm/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/app.h b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/app.h
new file mode 100644
index 000000000..e8ae21bf2
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/app.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyrtl8211f.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+extern phy_rtl8211f_resource_t g_phy_resource;
+#define EXAMPLE_ENET_NUM    1U
+#define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define SOEM_PORT_NAME       "enet1"
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x01U
+#define EXAMPLE_PHY_OPS      &phyrtl8211f_ops
+#define EXAMPLE_PHY_RESOURCE &g_phy_resource
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (300000)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (0)
+#endif
+
+#define ENET_RXBD_NUM          (4)
+#define ENET_TXBD_NUM          (4)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ		(CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/board.readme b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/board.readme
new file mode 100644
index 000000000..b3056d7bf
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/example_board_readme.md b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/example_board_readme.md
new file mode 100644
index 000000000..55d5cc8d9
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/hardware_init.c b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/hardware_init.c
new file mode 100644
index 000000000..c61821278
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/hardware_init.c
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_rtl8211f_resource_t g_phy_resource;
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+void BOARD_InitHardware()
+{
+    BOARD_InitMemory();
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4); /* SYSTEM PLL2 divided by 4: 250Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8); /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    CLOCK_EnableClock(kCLOCK_Sim_enet);
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 2, &gpio_config);
+    /* For a complete PHY reset of RTL8211FDI-CG, this pin must be asserted low for at least 10ms. And
+     * wait for a further 30ms(for internal circuits settling time) before accessing the PHY register */
+    GPIO_WritePinOutput(GPIO4, 2, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 2, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/pin_mux.c b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/pin_mux.c
new file mode 100644
index 000000000..4902ade2b
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/pin_mux.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2019-2022 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v9.0
+processor: MIMX8ML8xxxLZ
+package_id: MIMX8ML8DVNLZ
+mcu_data: ksdk2_0
+processor_version: 0.9.1
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', coreID: cm7}
+- pin_list:
+  - {pin_num: AJ5, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH5, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH9, peripheral: ENET1, signal: enet_mdc, pin_signal: SAI1_RXD2, PE: Disabled, DSE: X2}
+  - {pin_num: AJ8, peripheral: ENET1, signal: enet_mdio, pin_signal: SAI1_RXD3, PE: Disabled, DSE: X2}
+  - {pin_num: AD10, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: SAI1_RXD4, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AE10, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: SAI1_RXD5, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH10, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: SAI1_RXD6, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH12, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: SAI1_RXD7, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AF12, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: SAI1_TXFS, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ12, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: SAI1_TXC, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ11, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: SAI1_TXD0, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AJ10, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: SAI1_TXD1, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH11, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: SAI1_TXD2, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AD12, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: SAI1_TXD3, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH13, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: SAI1_TXD4, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH14, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: SAI1_TXD5, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AC10, peripheral: GPIO4, signal: 'gpio_io, 02', pin_signal: SAI1_RXD0, PE: Disabled, FSEL: Slow, DSE: X1}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: Cortex-M7F[m7] */
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD2_ENET1_MDC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD2_ENET1_MDC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD3_ENET1_MDIO, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD3_ENET1_MDIO, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/pin_mux.h b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/pin_mux.h
new file mode 100644
index 000000000..2c3322754
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/pin_mux.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2019-2020, 2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: Cortex-M7F[m7] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/prj.conf b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/prj.conf
new file mode 100644
index 000000000..c5db58d68
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MCUX_COMPONENT_component.phyrtl8211f=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_armv7_m7=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.freertos-kernel=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.freertos=y
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/reconfig.cmake b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/reconfig.cmake
new file mode 100644
index 000000000..18938dda7
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor/freertos/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/app.h b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/app.h
new file mode 100644
index 000000000..4acb2eade
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/app.h
@@ -0,0 +1,82 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyrtl8211f.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+#define EXAMPLE_ENET_NUM    1U
+#define CYCLE_SHIFT_NS  440000  // 440us
+#define DC_FILTER_CNT   64
+
+#define MASTER_SLAVE_SYNC 1U
+#define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define SOEM_PORT_NAME       "enet1"
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x01U
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+#define CLOCK_GRANULARITY_NS 40UL
+#define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
+#define CLOCK_INCREASE_PER_SEC 1000000000UL 
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (300000)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (0)
+#endif
+
+#define ENET_RXBD_NUM          (4)
+#define ENET_TXBD_NUM          (4)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ                                                                \
+    (CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+     
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+void osal_timer_init(uint32_t priority);
+uint64_t system_time64_ns(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+int if_port_init(void);
+void update_master_clock(void);
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/board.readme b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/board.readme
new file mode 100644
index 000000000..b3056d7bf
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md
new file mode 100644
index 000000000..55d5cc8d9
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
new file mode 100644
index 000000000..19aef545c
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
@@ -0,0 +1,282 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+/* dc sync time */
+uint8_t  dc_started = 0;
+int32_t  dc_diff_ns = 0;
+int32_t  prev_dc_diff_ns = 0;
+int64_t  dc_adjust_ns;
+int64_t  system_time_offset = 0LL;
+
+phy_rtl8211f_resource_t g_phy_resource;
+
+volatile uint64_t system_time_ns = 0;
+
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+
+SDK_ALIGN(uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+SDK_ALIGN(uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+
+enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+uint64_t system_time64_ns()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS - system_time_offset;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > system_time64_ns());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = system_time64_ns();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+uint64_t dc_diff_accu = 0;
+int32_t dc_diff_accu_arrary[DC_FILTER_CNT];
+int32_t dc_diff_accu_index = 0;
+
+static void dc_diff_init(int32_t dc_diff_ns)
+{
+	int i;
+	for (i = 0; i < DC_FILTER_CNT; i++) {
+		dc_diff_accu_arrary[i] = dc_diff_ns;
+		dc_diff_accu += dc_diff_ns;
+	}
+}
+
+static int32_t dc_diff_update(int32_t dc_diff_ns)
+{
+	dc_diff_accu += dc_diff_ns;
+	dc_diff_accu -= dc_diff_accu_arrary[dc_diff_accu_index];
+	dc_diff_accu_arrary[dc_diff_accu_index++] = dc_diff_ns;
+	if (dc_diff_accu_index >= DC_FILTER_CNT) {
+		dc_diff_accu_index = 0;
+	}
+	return dc_diff_accu / DC_FILTER_CNT;
+}
+
+#define PID_P  3 / 2
+#define PID_I  3 / 2
+#define PID_D  1 / 5 
+void update_master_clock()
+{
+	int32_t dc_diff_ns_avg;
+    // calc drift (via un-normalised time diff)
+    int32_t delta = dc_diff_ns - prev_dc_diff_ns;
+    prev_dc_diff_ns = dc_diff_ns;
+
+    if (dc_started == 2) {
+		dc_diff_ns_avg = dc_diff_update(dc_diff_ns);
+       dc_adjust_ns = dc_diff_ns * PID_P  + dc_diff_ns_avg * PID_I  + delta * PID_D;
+        if (dc_adjust_ns < -10000) {
+            dc_adjust_ns = -10000;
+        }
+        if (dc_adjust_ns > 10000) {
+            dc_adjust_ns =  10000;
+        }
+		// add cycles adjustment to time base (including a spot adjustment)
+        system_time_offset += dc_adjust_ns;
+    }
+    else {
+		if (dc_started == 0) {
+        	dc_started = (dc_diff_ns != 0);
+			system_time_offset = dc_diff_ns;
+		} else {
+			dc_started = 2;
+			dc_diff_init(dc_diff_ns);
+			system_time_offset += dc_diff_ns / 2;
+		}
+    }
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+struct enet_if_port if_port;
+
+int if_port_init()
+{
+	struct soem_if_port soem_port;
+	memset(&if_port, 0, sizeof(if_port));
+	if_port.bufferConfig = buffConfig;
+	if_port.base = EXAMPLE_ENET;
+/* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+	if_port.mii_mode = kENET_RgmiiMode;
+#else
+	if_port.mii_mode = kENET_RmiiMode;
+#endif
+	g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    if_port.phy_config.autoNeg = true;
+    if_port.phy_config.phyAddr = EXAMPLE_PHY_ADDRESS;
+	if_port.phy_config.ops = &phyrtl8211f_ops;
+	if_port.phy_config.resource = &g_phy_resource;
+
+    if_port.srcClock_Hz = EXAMPLE_CLOCK_FREQ;
+    if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+    if_port.phy_stability_delay_us = PHY_STABILITY_DELAY_US;
+
+    soem_port.port_init = enet_init;
+    soem_port.port_send = enet_send;
+    soem_port.port_recv = enet_recv;
+    soem_port.port_link_status = enet_link_status;
+    soem_port.port_close = enet_close;
+    strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+    strncpy(soem_port.dev_name, "enet", SOEM_DEV_NAME_MAXLEN);
+    soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+void BOARD_InitHardware()
+{
+    BOARD_InitMemory();
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    PRINTF("Start the soem_servo_motor_rt1180...\r\n");
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4); /* SYSTEM PLL2 divided by 4: 250Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8); /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    CLOCK_EnableClock(kCLOCK_Sim_enet);
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 2, &gpio_config);
+    /* For a complete PHY reset of RTL8211FDI-CG, this pin must be asserted low for at least 10ms. And
+     * wait for a further 30ms(for internal circuits settling time) before accessing the PHY register */
+    GPIO_WritePinOutput(GPIO4, 2, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 2, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c
new file mode 100644
index 000000000..4902ade2b
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2019-2022 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v9.0
+processor: MIMX8ML8xxxLZ
+package_id: MIMX8ML8DVNLZ
+mcu_data: ksdk2_0
+processor_version: 0.9.1
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', coreID: cm7}
+- pin_list:
+  - {pin_num: AJ5, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH5, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH9, peripheral: ENET1, signal: enet_mdc, pin_signal: SAI1_RXD2, PE: Disabled, DSE: X2}
+  - {pin_num: AJ8, peripheral: ENET1, signal: enet_mdio, pin_signal: SAI1_RXD3, PE: Disabled, DSE: X2}
+  - {pin_num: AD10, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: SAI1_RXD4, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AE10, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: SAI1_RXD5, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH10, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: SAI1_RXD6, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH12, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: SAI1_RXD7, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AF12, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: SAI1_TXFS, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ12, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: SAI1_TXC, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ11, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: SAI1_TXD0, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AJ10, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: SAI1_TXD1, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH11, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: SAI1_TXD2, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AD12, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: SAI1_TXD3, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH13, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: SAI1_TXD4, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH14, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: SAI1_TXD5, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AC10, peripheral: GPIO4, signal: 'gpio_io, 02', pin_signal: SAI1_RXD0, PE: Disabled, FSEL: Slow, DSE: X1}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: Cortex-M7F[m7] */
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD2_ENET1_MDC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD2_ENET1_MDC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD3_ENET1_MDIO, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD3_ENET1_MDIO, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h
new file mode 100644
index 000000000..2c3322754
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2019-2020, 2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: Cortex-M7F[m7] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/prj.conf b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/prj.conf
new file mode 100644
index 000000000..7a7122d01
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/prj.conf
@@ -0,0 +1,8 @@
+CONFIG_MCUX_COMPONENT_component.phyrtl8211f=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_armv7_m7=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.bm=y
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake
new file mode 100644
index 000000000..18938dda7
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/app.h b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/app.h
new file mode 100644
index 000000000..e8ae21bf2
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/app.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyrtl8211f.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+#include "FreeRTOS.h"
+#include "task.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+extern phy_rtl8211f_resource_t g_phy_resource;
+#define EXAMPLE_ENET_NUM    1U
+#define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define SOEM_PORT_NAME       "enet1"
+#define EXAMPLE_ENET         ENET1
+#define EXAMPLE_PHY_ADDRESS  0x01U
+#define EXAMPLE_PHY_OPS      &phyrtl8211f_ops
+#define EXAMPLE_PHY_RESOURCE &g_phy_resource
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetFreq(kCLOCK_EnetIpgClk)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (300000)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (0)
+#endif
+
+#define ENET_RXBD_NUM          (4)
+#define ENET_TXBD_NUM          (4)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ		(CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/board.readme b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/board.readme
new file mode 100644
index 000000000..b3056d7bf
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/example_board_readme.md b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/example_board_readme.md
new file mode 100644
index 000000000..55d5cc8d9
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX8MP-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/hardware_init.c b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/hardware_init.c
new file mode 100644
index 000000000..c61821278
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/hardware_init.c
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_rtl8211f_resource_t g_phy_resource;
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+void BOARD_InitHardware()
+{
+    BOARD_InitMemory();
+    /* Board specific RDC settings */
+    BOARD_RdcInit();
+
+    BOARD_InitPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4); /* SYSTEM PLL2 divided by 4: 250Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8); /* SYSTEM PLL2 divided by 8: 125Mhz */
+
+    CLOCK_EnableClock(kCLOCK_Sim_enet);
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+    GPIO_PinInit(GPIO4, 2, &gpio_config);
+    /* For a complete PHY reset of RTL8211FDI-CG, this pin must be asserted low for at least 10ms. And
+     * wait for a further 30ms(for internal circuits settling time) before accessing the PHY register */
+    GPIO_WritePinOutput(GPIO4, 2, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 2, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done2_IRQn);
+
+    MDIO_Init();
+    g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+}
+
+/*${function:end}*/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.c b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.c
new file mode 100644
index 000000000..4902ade2b
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.c
@@ -0,0 +1,147 @@
+/*
+ * Copyright 2019-2022 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v9.0
+processor: MIMX8ML8xxxLZ
+package_id: MIMX8ML8DVNLZ
+mcu_data: ksdk2_0
+processor_version: 0.9.1
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', coreID: cm7}
+- pin_list:
+  - {pin_num: AJ5, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH5, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Enabled, PUE: Weak_Pull_Up, DSE: X1}
+  - {pin_num: AH9, peripheral: ENET1, signal: enet_mdc, pin_signal: SAI1_RXD2, PE: Disabled, DSE: X2}
+  - {pin_num: AJ8, peripheral: ENET1, signal: enet_mdio, pin_signal: SAI1_RXD3, PE: Disabled, DSE: X2}
+  - {pin_num: AD10, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: SAI1_RXD4, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AE10, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: SAI1_RXD5, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH10, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: SAI1_RXD6, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH12, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: SAI1_RXD7, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AF12, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: SAI1_TXFS, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ12, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: SAI1_TXC, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ11, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: SAI1_TXD0, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AJ10, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: SAI1_TXD1, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH11, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: SAI1_TXD2, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AD12, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: SAI1_TXD3, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH13, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: SAI1_TXD4, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH14, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: SAI1_TXD5, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AC10, peripheral: GPIO4, signal: 'gpio_io, 02', pin_signal: SAI1_RXD0, PE: Disabled, FSEL: Slow, DSE: X1}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: Cortex-M7F[m7] */
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD2_ENET1_MDC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD2_ENET1_MDC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD3_ENET1_MDIO, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD3_ENET1_MDIO, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(2U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.h b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.h
new file mode 100644
index 000000000..2c3322754
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/pin_mux.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2019-2020, 2023 NXP
+ *
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: Cortex-M7F[m7] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
\ No newline at end of file
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf
new file mode 100644
index 000000000..c5db58d68
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MCUX_COMPONENT_component.phyrtl8211f=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.cache_armv7_m7=y
+CONFIG_MCUX_COMPONENT_driver.rdc=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.gpt=y
+CONFIG_MCUX_COMPONENT_middleware.freertos-kernel=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.freertos=y
diff --git a/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/reconfig.cmake b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/reconfig.cmake
new file mode 100644
index 000000000..18938dda7
--- /dev/null
+++ b/_boards/evkmimx8mp/soem_examples/soem_servo_motor_rt1180/freertos/reconfig.cmake
@@ -0,0 +1,14 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DFSL_SDK_ENABLE_DRIVER_CACHE_CONTROL=1"
+)
+
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES middleware/multicore/remoteproc/empty_rsc_table.c
+)
\ No newline at end of file
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/app.h b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/app.h
new file mode 100644
index 000000000..77c352ceb
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/app.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyrtl8211f.h"
+#include "fsl_pcal6524.h"
+#include "fsl_rgpio.h"
+#include "fsl_tpm.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+#define EXAMPLE_ENET_NUM    1U
+#define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define EXAMPLE_ENET         ENET
+#define EXAMPLE_PHY_ADDRESS  0x02U
+#define ENET_CLOCK_ROOT      kCLOCK_Root_WakeupAxi
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetIpFreq(ENET_CLOCK_ROOT)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+#define CLOCK_GRANULARITY_NS 40UL
+#define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
+#define CLOCK_INCREASE_PER_SEC 1000000000UL 
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (800000U)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (500000U)
+#endif
+
+#define SOEM_PORT_NAME "enet0"
+#define ENET_RXBD_NUM          (4)
+#define ENET_TXBD_NUM          (4)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define BOARD_TPM            TPM2
+#define DEMO_TIMER_PERIOD_US (1000000U)
+
+/* Interrupt number and interrupt handler for the TPM instance used */
+#define BOARD_TPM_IRQ_NUM TPM2_IRQn
+#define BOARD_TPM_HANDLER TPM2_IRQHandler
+
+/* Get source clock for TPM driver */
+#define LPTPM_CLOCK_ROOT kCLOCK_Root_Tpm2
+#define LPTPM_CLOCK_GATE kCLOCK_Tpm2
+#define TPM_SOURCE_CLOCK CLOCK_GetIpFreq(LPTPM_CLOCK_ROOT)
+
+/* Calculate the clock division based on the PWM frequency to be obtained */
+#define TPM_PRESCALER TPM_CalculateCounterClkDiv(BOARD_TPM, 1000000U / DEMO_TIMER_PERIOD_US, TPM_SOURCE_CLOCK);
+     
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+uint64_t gettime(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+void osal_timer_init(uint32_t priority);
+int if_port_init(void);
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/board.readme b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/board.readme
new file mode 100644
index 000000000..e9cb9205d
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX93-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/example_board_readme.md b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/example_board_readme.md
new file mode 100644
index 000000000..5f6c63dc2
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX93-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/hardware_init.c b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/hardware_init.c
new file mode 100644
index 000000000..dd0a90e76
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/hardware_init.c
@@ -0,0 +1,251 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+phy_rtl8211f_resource_t g_phy_resource;
+double rate_counter_ns = 0;
+
+volatile uint64_t system_time_ns = 0;
+
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+
+enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+uint64_t gettime()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = TPM_GetCurrentTimerCount(BOARD_TPM);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = TPM_GetCurrentTimerCount(BOARD_TPM);
+	}
+	return nsec_base + cur_nsec * rate_counter_ns;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > gettime());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = gettime();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	TPM_ClearStatusFlags(BOARD_TPM, kTPM_TimeOverflowFlag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void BOARD_TPM_HANDLER(void)
+{
+    /* Clear interrupt flag.*/
+    TPM_ClearStatusFlags(BOARD_TPM, kTPM_TimeOverflowFlag);
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+    SDK_ISR_EXIT_BARRIER;
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	tpm_config_t tpmInfo;
+	TPM_GetDefaultConfig(&tpmInfo);
+
+	/* TPM clock divide by TPM_PRESCALER */
+    tpmInfo.prescale = TPM_PRESCALER;
+
+	/* Initialize TPM module */
+    TPM_Init(BOARD_TPM, &tpmInfo);
+
+	rate_counter_ns = 1000000000.0 / (TPM_SOURCE_CLOCK / (1U << tpmInfo.prescale));
+
+	/* Set timer period */
+    TPM_SetTimerPeriod(BOARD_TPM, USEC_TO_COUNT(DEMO_TIMER_PERIOD_US, TPM_SOURCE_CLOCK / (1U << tpmInfo.prescale)));
+
+    TPM_EnableInterrupts(BOARD_TPM, kTPM_TimeOverflowInterruptEnable);
+
+	/* Enable at the Interrupt */
+	EnableIRQ(BOARD_TPM_IRQ_NUM);
+	TPM_StartTimer(BOARD_TPM, kTPM_SystemClock);
+
+	system_time_ns = TPM_GetCurrentTimerCount(BOARD_TPM);
+}
+
+struct enet_if_port if_port;
+
+int if_port_init()
+{
+	struct soem_if_port soem_port;
+	memset(&if_port, 0, sizeof(if_port));
+	if_port.bufferConfig = buffConfig;
+	if_port.base = EXAMPLE_ENET;
+/* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+	if_port.mii_mode = kENET_RgmiiMode;
+#else
+	if_port.mii_mode = kENET_RmiiMode;
+#endif
+	g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    if_port.phy_config.autoNeg = true;
+    if_port.phy_config.phyAddr = EXAMPLE_PHY_ADDRESS;
+	if_port.phy_config.ops = &phyrtl8211f_ops;
+	if_port.phy_config.resource = &g_phy_resource;
+
+    if_port.srcClock_Hz = EXAMPLE_CLOCK_FREQ;
+    if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+    if_port.phy_stability_delay_us = PHY_STABILITY_DELAY_US;
+
+    soem_port.port_init = enet_init;
+    soem_port.port_send = enet_send;
+    soem_port.port_recv = enet_recv;
+    soem_port.port_link_status = enet_link_status;
+    soem_port.port_close = enet_close;
+    strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+    strncpy(soem_port.dev_name, "enet", SOEM_DEV_NAME_MAXLEN);
+    soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+void BOARD_InitHardware()
+{
+    /* Hardware Initialization. */
+    /* clang-format off */
+    /* enetClk 250MHz */
+    const clock_root_config_t enetClkCfg = {
+        .clockOff = false,
+	.mux = kCLOCK_WAKEUPAXI_ClockRoot_MuxSysPll1Pfd0, // 1000MHz
+	.div = 4
+    };
+
+    /* enetRefClk 250MHz (For 125MHz TX_CLK ) */
+    const clock_root_config_t enetRefClkCfg = {
+        .clockOff = false,
+	.mux = kCLOCK_ENETREF_ClockRoot_MuxSysPll1Pfd0Div2, // 500MHz
+	.div = 2
+    };
+
+    const clock_root_config_t lpi2cClkCfg = {
+        .clockOff = false,
+	.mux = 0, // 24MHz oscillator source
+	.div = 1
+    };
+    /* clang-format on */    
+
+	const clock_root_config_t tpmClkCfg = {
+        .clockOff = false,
+        .mux = 0, /* 24MHz oscillator source */
+        .div = 1
+    };
+
+    /* Hardware Initialization. */
+	BOARD_ConfigMPU();
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    CLOCK_SetRootClock(kCLOCK_Root_WakeupAxi, &enetClkCfg);
+    CLOCK_SetRootClock(kCLOCK_Root_EnetRef, &enetRefClkCfg);
+    CLOCK_EnableClock(kCLOCK_Enet1);
+    CLOCK_SetRootClock(BOARD_PCAL6524_I2C_CLOCK_ROOT, &lpi2cClkCfg);
+    CLOCK_EnableClock(kCLOCK_Lpi2c2);
+	CLOCK_SetRootClock(LPTPM_CLOCK_ROOT, &tpmClkCfg);
+    CLOCK_EnableClock(LPTPM_CLOCK_GATE);
+
+    /* For a complete PHY reset of RTL8211FDI-CG, this pin must be asserted low for at least 10ms. And
+     * wait for a further 30ms(for internal circuits settling time) before accessing the PHY register */
+    pcal6524_handle_t handle;
+    BOARD_InitPCAL6524(&handle);
+    PCAL6524_SetDirection(&handle, (1 << BOARD_PCAL6524_ENET2_NRST), kPCAL6524_Output);
+    PCAL6524_ClearPins(&handle, (1 << BOARD_PCAL6524_ENET2_NRST));
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    PCAL6524_SetPins(&handle, (1 << BOARD_PCAL6524_ENET2_NRST));
+	SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+	EnableIRQ(ENET_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET_MAC0_Rx_Tx_Done2_IRQn);
+    EnableIRQ(ENET_IRQn);
+
+    MDIO_Init();
+}
+
+/*${function:end}*/
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/pin_mux.c b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/pin_mux.c
new file mode 100644
index 000000000..7909c9bbf
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/pin_mux.c
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2022 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v12.0
+processor: MIMX9352xxxxM
+package_id: MIMX9352DVVXM
+mcu_data: ksdk2_0
+processor_version: 0.12.3
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', coreID: cm33}
+- pin_list:
+  - {pin_num: F20, peripheral: LPUART2, signal: lpuart_rx, pin_signal: UART2_RXD, HYS: DISABLED, FSEL1: SlOW_SLEW_RATE, DSE: NO_DRIVE}
+  - {pin_num: F21, peripheral: LPUART2, signal: lpuart_tx, pin_signal: UART2_TXD, HYS: DISABLED, PD: DISABLED, FSEL1: SlOW_SLEW_RATE}
+  - {pin_num: Y7, peripheral: ENET1, signal: enet_mdc, pin_signal: ENET2_MDC, HYS: DISABLED, DSE: X6}
+  - {pin_num: AA6, peripheral: ENET1, signal: enet_mdio, pin_signal: ENET2_MDIO, HYS: DISABLED, DSE: X6}
+  - {pin_num: AA4, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: ENET2_RD0, HYS: DISABLED, DSE: X6}
+  - {pin_num: Y5, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: ENET2_RD1, HYS: DISABLED, DSE: X6}
+  - {pin_num: AA5, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: ENET2_RD2, HYS: DISABLED, DSE: X6}
+  - {pin_num: Y6, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: ENET2_RD3, HYS: DISABLED, DSE: X6}
+  - {pin_num: Y4, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: ENET2_RX_CTL, HYS: DISABLED, DSE: X6}
+  - {pin_num: AA3, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: ENET2_RXC, HYS: DISABLED, FSEL1: FAST_SLEW_RATE, DSE: X6}
+  - {pin_num: T8, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: ENET2_TD0, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: U8, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: ENET2_TD1, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: V8, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: ENET2_TD2, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: T10, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: ENET2_TD3, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: V6, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: ENET2_TX_CTL, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: U6, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: ENET2_TXC, HYS: DISABLED, PD: DISABLED, FSEL1: FAST_SLEW_RATE, DSE: X6}
+  - {pin_num: D20, peripheral: LPI2C2, signal: lpi2c_scl, pin_signal: I2C2_SCL, SION: ENABLED, HYS: DISABLED, OD: ENABLED, PD: DISABLED}
+  - {pin_num: D21, peripheral: LPI2C2, signal: lpi2c_sda, pin_signal: I2C2_SDA, SION: ENABLED, HYS: DISABLED, OD: ENABLED, PD: DISABLED}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: undefined[cm33] */
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_MDC__ENET1_MDC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_MDIO__ENET1_MDIO, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RD0__ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RD1__ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RD2__ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RD3__ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RXC__ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RX_CTL__ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TD0__ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TD1__ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TD2__ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TD3__ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TXC__ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TX_CTL__ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_I2C2_SCL__LPI2C2_SCL, 1U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_I2C2_SDA__LPI2C2_SDA, 1U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_UART2_RXD__LPUART2_RX, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_UART2_TXD__LPUART2_TX, 0U);
+
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_MDC__ENET1_MDC, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_MDIO__ENET1_MDIO, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RD0__ENET1_RGMII_RD0, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RD1__ENET1_RGMII_RD1, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RD2__ENET1_RGMII_RD2, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RD3__ENET1_RGMII_RD3, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RXC__ENET1_RGMII_RXC, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(3U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RX_CTL__ENET1_RGMII_RX_CTL, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TD0__ENET1_RGMII_TD0, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TD1__ENET1_RGMII_TD1, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TD2__ENET1_RGMII_TD2, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TD3__ENET1_RGMII_TD3, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TXC__ENET1_RGMII_TXC, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(3U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TX_CTL__ENET1_RGMII_TX_CTL, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_I2C2_SCL__LPI2C2_SCL, 
+                        IOMUXC_PAD_DSE(15U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_OD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_I2C2_SDA__LPI2C2_SDA, 
+                        IOMUXC_PAD_DSE(15U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_OD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_UART2_RXD__LPUART2_RX, 
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_UART2_TXD__LPUART2_TX, 
+                        IOMUXC_PAD_DSE(15U));
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/pin_mux.h b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/pin_mux.h
new file mode 100644
index 000000000..8c50e05d4
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/pin_mux.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2022 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "fsl_iomuxc.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: undefined[cm33] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/prj.conf b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/prj.conf
new file mode 100644
index 000000000..7d233ac0f
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MCUX_COMPONENT_component.phyrtl8211f=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.lpi2c=y
+CONFIG_MCUX_COMPONENT_driver.pcal6524=y
+CONFIG_MCUX_ABSTRACT_COMPONENT_component_expander=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.tpm=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.bm=y
\ No newline at end of file
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/reconfig.cmake b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/reconfig.cmake
new file mode 100644
index 000000000..e5c7b4bf8
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor/bm/reconfig.cmake
@@ -0,0 +1,10 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DSDK_I2C_BASED_COMPONENT_USED=1\
+       -DBOARD_USE_PCAL6524=1"
+)
\ No newline at end of file
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/app.h b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/app.h
new file mode 100644
index 000000000..f6bef0d53
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/app.h
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2022-2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _APP_H_
+#define _APP_H_
+
+#include "fsl_phyrtl8211f.h"
+#include "fsl_pcal6524.h"
+#include "fsl_rgpio.h"
+#include "fsl_tpm.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "enet/enet.h"
+#include "soem_port.h"
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+#define EXAMPLE_ENET_NUM    1U
+#define CYCLE_SHIFT_NS  440000  // 440us
+#define DC_FILTER_CNT   64
+
+#define MASTER_SLAVE_SYNC 1U
+#define EXAMPLE_NETC_HAS_NO_SWITCH 1U
+
+#define EXAMPLE_ENET         ENET
+#define EXAMPLE_PHY_ADDRESS  0x02U
+#define ENET_CLOCK_ROOT      kCLOCK_Root_WakeupAxi
+#define EXAMPLE_CLOCK_FREQ   CLOCK_GetIpFreq(ENET_CLOCK_ROOT)
+#define EXAMPLE_PHY_INTERFACE_RGMII
+
+#define CLOCK_GRANULARITY_NS 40UL
+#define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
+#define CLOCK_INCREASE_PER_SEC 1000000000UL 
+/*${macro:end}*/
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (800000U)
+#endif
+
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (500000U)
+#endif
+
+#define SOEM_PORT_NAME "enet0"
+#define ENET_RXBD_NUM          (4)
+#define ENET_TXBD_NUM          (4)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define BOARD_TPM            TPM2
+#define DEMO_TIMER_PERIOD_US (1000000U)
+
+/* Interrupt number and interrupt handler for the TPM instance used */
+#define BOARD_TPM_IRQ_NUM TPM2_IRQn
+#define BOARD_TPM_HANDLER TPM2_IRQHandler
+
+/* Get source clock for TPM driver */
+#define LPTPM_CLOCK_ROOT kCLOCK_Root_Tpm2
+#define LPTPM_CLOCK_GATE kCLOCK_Tpm2
+#define TPM_SOURCE_CLOCK CLOCK_GetIpFreq(LPTPM_CLOCK_ROOT)
+
+/* Calculate the clock division based on the PWM frequency to be obtained */
+#define TPM_PRESCALER TPM_CalculateCounterClkDiv(BOARD_TPM, 1000000U / DEMO_TIMER_PERIOD_US, TPM_SOURCE_CLOCK);
+     
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+void osal_timer_init(uint32_t priority);
+uint64_t system_time64_ns(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+int if_port_init(void);
+void update_master_clock(void);
+void BOARD_InitHardware(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/board.readme b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/board.readme
new file mode 100644
index 000000000..e9cb9205d
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/board.readme
@@ -0,0 +1,25 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX93-EVK board
+- One BECKHOFF EK1100 EtherCAT Coupler
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md
new file mode 100644
index 000000000..5f6c63dc2
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md
@@ -0,0 +1,27 @@
+Hardware requirements
+===================
+- Mini/micro USB cable
+- Network cable RJ45 standard
+- IMX93-EVK board
+- BECKHOFF EK1100 EtherCAT Coupler *1
+- BECKHOFF EL2008 *1
+- BECKHOFF EL1018 *1
+- Personal Computer
+
+Board settings
+============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board.
+2.  Power up the EtherCAT Coupler and connect it to the target board via an Ethernet Cable.
+3.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+4.  Write the program to the flash of the target board.
+5.  Press the reset button on your board to start the demo.
+
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
new file mode 100644
index 000000000..4050191de
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
@@ -0,0 +1,316 @@
+/*
+ * Copyright 2022-2025 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*${header:start}*/
+#include "app.h"
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet.h"
+/*${header:end}*/
+
+/*${variable:start}*/
+/* dc sync time */
+uint8_t  dc_started = 0;
+int32_t  dc_diff_ns = 0;
+int32_t  prev_dc_diff_ns = 0;
+int64_t  dc_adjust_ns;
+int64_t  system_time_offset = 0LL;
+
+phy_rtl8211f_resource_t g_phy_resource;
+double rate_counter_ns = 0;
+
+volatile uint64_t system_time_ns = 0;
+
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+
+enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+/*${variable:end}*/
+
+/*${function:start}*/
+static void MDIO_Init(void)
+{
+    (void)CLOCK_EnableClock(s_enetClock[ENET_GetInstance(EXAMPLE_ENET)]);
+    ENET_SetSMI(EXAMPLE_ENET, EXAMPLE_CLOCK_FREQ, false);
+}
+
+static status_t MDIO_Write(uint8_t phyAddr, uint8_t regAddr, uint16_t data)
+{
+    return ENET_MDIOWrite(EXAMPLE_ENET, phyAddr, regAddr, data);
+}
+
+static status_t MDIO_Read(uint8_t phyAddr, uint8_t regAddr, uint16_t *pData)
+{
+    return ENET_MDIORead(EXAMPLE_ENET, phyAddr, regAddr, pData);
+}
+
+uint64_t system_time64_ns()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = TPM_GetCurrentTimerCount(BOARD_TPM);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = TPM_GetCurrentTimerCount(BOARD_TPM);
+	}
+	return nsec_base + cur_nsec * rate_counter_ns - system_time_offset;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > system_time64_ns());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = system_time64_ns();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+uint64_t dc_diff_accu = 0;
+int32_t dc_diff_accu_arrary[DC_FILTER_CNT];
+int32_t dc_diff_accu_index = 0;
+
+static void dc_diff_init(int32_t dc_diff_ns)
+{
+	int i;
+	for (i = 0; i < DC_FILTER_CNT; i++) {
+		dc_diff_accu_arrary[i] = dc_diff_ns;
+		dc_diff_accu += dc_diff_ns;
+	}
+}
+
+static int32_t dc_diff_update(int32_t dc_diff_ns)
+{
+	dc_diff_accu += dc_diff_ns;
+	dc_diff_accu -= dc_diff_accu_arrary[dc_diff_accu_index];
+	dc_diff_accu_arrary[dc_diff_accu_index++] = dc_diff_ns;
+	if (dc_diff_accu_index >= DC_FILTER_CNT) {
+		dc_diff_accu_index = 0;
+	}
+	return dc_diff_accu / DC_FILTER_CNT;
+}
+
+#define PID_P  3 / 2
+#define PID_I  3 / 2
+#define PID_D  1 / 5 
+void update_master_clock()
+{
+	int32_t dc_diff_ns_avg;
+    // calc drift (via un-normalised time diff)
+    int32_t delta = dc_diff_ns - prev_dc_diff_ns;
+    prev_dc_diff_ns = dc_diff_ns;
+
+    if (dc_started == 2) {
+		dc_diff_ns_avg = dc_diff_update(dc_diff_ns);
+       dc_adjust_ns = dc_diff_ns * PID_P  + dc_diff_ns_avg * PID_I  + delta * PID_D;
+        if (dc_adjust_ns < -10000) {
+            dc_adjust_ns = -10000;
+        }
+        if (dc_adjust_ns > 10000) {
+            dc_adjust_ns =  10000;
+        }
+		// add cycles adjustment to time base (including a spot adjustment)
+        system_time_offset += dc_adjust_ns;
+    }
+    else {
+		if (dc_started == 0) {
+        	dc_started = (dc_diff_ns != 0);
+			system_time_offset = dc_diff_ns;
+		} else {
+			dc_started = 2;
+			dc_diff_init(dc_diff_ns);
+			system_time_offset += dc_diff_ns / 2;
+		}
+    }
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	TPM_ClearStatusFlags(BOARD_TPM, kTPM_TimeOverflowFlag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void BOARD_TPM_HANDLER(void)
+{
+    /* Clear interrupt flag.*/
+    TPM_ClearStatusFlags(BOARD_TPM, kTPM_TimeOverflowFlag);
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+    SDK_ISR_EXIT_BARRIER;
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	tpm_config_t tpmInfo;
+	TPM_GetDefaultConfig(&tpmInfo);
+
+	/* TPM clock divide by TPM_PRESCALER */
+    tpmInfo.prescale = TPM_PRESCALER;
+
+	/* Initialize TPM module */
+    TPM_Init(BOARD_TPM, &tpmInfo);
+
+	rate_counter_ns = 1000000000.0 / (TPM_SOURCE_CLOCK / (1U << tpmInfo.prescale));
+
+	/* Set timer period */
+    TPM_SetTimerPeriod(BOARD_TPM, USEC_TO_COUNT(DEMO_TIMER_PERIOD_US, TPM_SOURCE_CLOCK / (1U << tpmInfo.prescale)));
+
+    TPM_EnableInterrupts(BOARD_TPM, kTPM_TimeOverflowInterruptEnable);
+
+	/* Enable at the Interrupt */
+	EnableIRQ(BOARD_TPM_IRQ_NUM);
+	TPM_StartTimer(BOARD_TPM, kTPM_SystemClock);
+
+	system_time_ns = TPM_GetCurrentTimerCount(BOARD_TPM);
+}
+
+struct enet_if_port if_port;
+
+int if_port_init()
+{
+	struct soem_if_port soem_port;
+	memset(&if_port, 0, sizeof(if_port));
+	if_port.bufferConfig = buffConfig;
+	if_port.base = EXAMPLE_ENET;
+/* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+	if_port.mii_mode = kENET_RgmiiMode;
+#else
+	if_port.mii_mode = kENET_RmiiMode;
+#endif
+	g_phy_resource.read  = MDIO_Read;
+    g_phy_resource.write = MDIO_Write;
+
+    if_port.phy_config.autoNeg = true;
+    if_port.phy_config.phyAddr = EXAMPLE_PHY_ADDRESS;
+	if_port.phy_config.ops = &phyrtl8211f_ops;
+	if_port.phy_config.resource = &g_phy_resource;
+
+    if_port.srcClock_Hz = EXAMPLE_CLOCK_FREQ;
+    if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+    if_port.phy_stability_delay_us = PHY_STABILITY_DELAY_US;
+
+    soem_port.port_init = enet_init;
+    soem_port.port_send = enet_send;
+    soem_port.port_recv = enet_recv;
+    soem_port.port_link_status = enet_link_status;
+    soem_port.port_close = enet_close;
+    strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+    strncpy(soem_port.dev_name, "enet", SOEM_DEV_NAME_MAXLEN);
+    soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+void BOARD_InitHardware()
+{
+    /* Hardware Initialization. */
+    /* clang-format off */
+    /* enetClk 250MHz */
+    const clock_root_config_t enetClkCfg = {
+        .clockOff = false,
+	.mux = kCLOCK_WAKEUPAXI_ClockRoot_MuxSysPll1Pfd0, // 1000MHz
+	.div = 4
+    };
+
+    /* enetRefClk 250MHz (For 125MHz TX_CLK ) */
+    const clock_root_config_t enetRefClkCfg = {
+        .clockOff = false,
+	.mux = kCLOCK_ENETREF_ClockRoot_MuxSysPll1Pfd0Div2, // 500MHz
+	.div = 2
+    };
+
+    const clock_root_config_t lpi2cClkCfg = {
+        .clockOff = false,
+	.mux = 0, // 24MHz oscillator source
+	.div = 1
+    };
+    /* clang-format on */    
+
+	const clock_root_config_t tpmClkCfg = {
+        .clockOff = false,
+        .mux = 0, /* 24MHz oscillator source */
+        .div = 1
+    };
+
+    /* Hardware Initialization. */
+	BOARD_ConfigMPU();
+    BOARD_InitBootPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    CLOCK_SetRootClock(kCLOCK_Root_WakeupAxi, &enetClkCfg);
+    CLOCK_SetRootClock(kCLOCK_Root_EnetRef, &enetRefClkCfg);
+    CLOCK_EnableClock(kCLOCK_Enet1);
+    CLOCK_SetRootClock(BOARD_PCAL6524_I2C_CLOCK_ROOT, &lpi2cClkCfg);
+    CLOCK_EnableClock(kCLOCK_Lpi2c2);
+	CLOCK_SetRootClock(LPTPM_CLOCK_ROOT, &tpmClkCfg);
+    CLOCK_EnableClock(LPTPM_CLOCK_GATE);
+
+    /* For a complete PHY reset of RTL8211FDI-CG, this pin must be asserted low for at least 10ms. And
+     * wait for a further 30ms(for internal circuits settling time) before accessing the PHY register */
+    pcal6524_handle_t handle;
+    BOARD_InitPCAL6524(&handle);
+    PCAL6524_SetDirection(&handle, (1 << BOARD_PCAL6524_ENET2_NRST), kPCAL6524_Output);
+    PCAL6524_ClearPins(&handle, (1 << BOARD_PCAL6524_ENET2_NRST));
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    PCAL6524_SetPins(&handle, (1 << BOARD_PCAL6524_ENET2_NRST));
+	SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+	EnableIRQ(ENET_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET_MAC0_Rx_Tx_Done2_IRQn);
+    EnableIRQ(ENET_IRQn);
+
+    MDIO_Init();
+}
+
+/*${function:end}*/
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c
new file mode 100644
index 000000000..7909c9bbf
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.c
@@ -0,0 +1,154 @@
+/*
+ * Copyright 2022 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v12.0
+processor: MIMX9352xxxxM
+package_id: MIMX9352DVVXM
+mcu_data: ksdk2_0
+processor_version: 0.12.3
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', coreID: cm33}
+- pin_list:
+  - {pin_num: F20, peripheral: LPUART2, signal: lpuart_rx, pin_signal: UART2_RXD, HYS: DISABLED, FSEL1: SlOW_SLEW_RATE, DSE: NO_DRIVE}
+  - {pin_num: F21, peripheral: LPUART2, signal: lpuart_tx, pin_signal: UART2_TXD, HYS: DISABLED, PD: DISABLED, FSEL1: SlOW_SLEW_RATE}
+  - {pin_num: Y7, peripheral: ENET1, signal: enet_mdc, pin_signal: ENET2_MDC, HYS: DISABLED, DSE: X6}
+  - {pin_num: AA6, peripheral: ENET1, signal: enet_mdio, pin_signal: ENET2_MDIO, HYS: DISABLED, DSE: X6}
+  - {pin_num: AA4, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: ENET2_RD0, HYS: DISABLED, DSE: X6}
+  - {pin_num: Y5, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: ENET2_RD1, HYS: DISABLED, DSE: X6}
+  - {pin_num: AA5, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: ENET2_RD2, HYS: DISABLED, DSE: X6}
+  - {pin_num: Y6, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: ENET2_RD3, HYS: DISABLED, DSE: X6}
+  - {pin_num: Y4, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: ENET2_RX_CTL, HYS: DISABLED, DSE: X6}
+  - {pin_num: AA3, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: ENET2_RXC, HYS: DISABLED, FSEL1: FAST_SLEW_RATE, DSE: X6}
+  - {pin_num: T8, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: ENET2_TD0, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: U8, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: ENET2_TD1, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: V8, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: ENET2_TD2, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: T10, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: ENET2_TD3, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: V6, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: ENET2_TX_CTL, HYS: DISABLED, PD: DISABLED, DSE: X6}
+  - {pin_num: U6, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: ENET2_TXC, HYS: DISABLED, PD: DISABLED, FSEL1: FAST_SLEW_RATE, DSE: X6}
+  - {pin_num: D20, peripheral: LPI2C2, signal: lpi2c_scl, pin_signal: I2C2_SCL, SION: ENABLED, HYS: DISABLED, OD: ENABLED, PD: DISABLED}
+  - {pin_num: D21, peripheral: LPI2C2, signal: lpi2c_sda, pin_signal: I2C2_SDA, SION: ENABLED, HYS: DISABLED, OD: ENABLED, PD: DISABLED}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: undefined[cm33] */
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_MDC__ENET1_MDC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_MDIO__ENET1_MDIO, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RD0__ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RD1__ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RD2__ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RD3__ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RXC__ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_RX_CTL__ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TD0__ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TD1__ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TD2__ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TD3__ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TXC__ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_ENET2_TX_CTL__ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_I2C2_SCL__LPI2C2_SCL, 1U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_I2C2_SDA__LPI2C2_SDA, 1U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_UART2_RXD__LPUART2_RX, 0U);
+    IOMUXC_SetPinMux(IOMUXC_PAD_UART2_TXD__LPUART2_TX, 0U);
+
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_MDC__ENET1_MDC, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_MDIO__ENET1_MDIO, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RD0__ENET1_RGMII_RD0, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RD1__ENET1_RGMII_RD1, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RD2__ENET1_RGMII_RD2, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RD3__ENET1_RGMII_RD3, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RXC__ENET1_RGMII_RXC, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(3U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_RX_CTL__ENET1_RGMII_RX_CTL, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TD0__ENET1_RGMII_TD0, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TD1__ENET1_RGMII_TD1, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TD2__ENET1_RGMII_TD2, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TD3__ENET1_RGMII_TD3, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TXC__ENET1_RGMII_TXC, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(3U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_ENET2_TX_CTL__ENET1_RGMII_TX_CTL, 
+                        IOMUXC_PAD_DSE(63U) |
+                        IOMUXC_PAD_FSEL1(2U));
+    IOMUXC_SetPinConfig(IOMUXC_PAD_I2C2_SCL__LPI2C2_SCL, 
+                        IOMUXC_PAD_DSE(15U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_OD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_I2C2_SDA__LPI2C2_SDA, 
+                        IOMUXC_PAD_DSE(15U) |
+                        IOMUXC_PAD_FSEL1(2U) |
+                        IOMUXC_PAD_OD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_UART2_RXD__LPUART2_RX, 
+                        IOMUXC_PAD_PD_MASK);
+    IOMUXC_SetPinConfig(IOMUXC_PAD_UART2_TXD__LPUART2_TX, 
+                        IOMUXC_PAD_DSE(15U));
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h
new file mode 100644
index 000000000..8c50e05d4
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/pin_mux.h
@@ -0,0 +1,53 @@
+/*
+ * Copyright 2022 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "fsl_iomuxc.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: undefined[cm33] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/prj.conf b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/prj.conf
new file mode 100644
index 000000000..7d233ac0f
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/prj.conf
@@ -0,0 +1,9 @@
+CONFIG_MCUX_COMPONENT_component.phyrtl8211f=y
+CONFIG_MCUX_COMPONENT_component.silicon_id=y
+CONFIG_MCUX_COMPONENT_driver.lpi2c=y
+CONFIG_MCUX_COMPONENT_driver.pcal6524=y
+CONFIG_MCUX_ABSTRACT_COMPONENT_component_expander=y
+CONFIG_MCUX_COMPONENT_driver.enet=y
+CONFIG_MCUX_COMPONENT_driver.tpm=y
+CONFIG_MCUX_COMPONENT_middleware.soem.enet=y
+CONFIG_MCUX_COMPONENT_middleware.soem.bm=y
\ No newline at end of file
diff --git a/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake
new file mode 100644
index 000000000..e5c7b4bf8
--- /dev/null
+++ b/_boards/mcimx93evk/soem_examples/soem_servo_motor_rt1180/bm/reconfig.cmake
@@ -0,0 +1,10 @@
+
+# Add additional configuration
+mcux_add_macro(
+    CC "-DSDK_DEBUGCONSOLE_UART\
+        -DSERIAL_PORT_TYPE_UART=1\
+       -DPRINTF_ADVANCED_ENABLE=1\
+       -DEC_MAXSLAVE=32\
+       -DSDK_I2C_BASED_COMPONENT_USED=1\
+       -DBOARD_USE_PCAL6524=1"
+)
\ No newline at end of file
diff --git a/soem_examples/soem_gpio_pulse/bm/soem_gpio_pulse.c b/soem_examples/soem_gpio_pulse/bm/soem_gpio_pulse.c
index 1caebb7a7..eb6b431ff 100644
--- a/soem_examples/soem_gpio_pulse/bm/soem_gpio_pulse.c
+++ b/soem_examples/soem_gpio_pulse/bm/soem_gpio_pulse.c
@@ -188,7 +188,11 @@ static int if_port_init(void)
     if_port.bufferConfig = buffConfig;
     if_port.base         = EXAMPLE_ENET;
     /* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+	if_port.mii_mode                   = kENET_RgmiiMode;
+#else
     if_port.mii_mode                   = kENET_RmiiMode;
+#endif
     if_port.phy_config.autoNeg         = true;
     if_port.phy_config.phyAddr         = EXAMPLE_PHY_ADDRESS;
     if_port.phy_config.resource        = EXAMPLE_PHY_RESOURCE;
diff --git a/soem_examples/soem_gpio_pulse/freertos/CMakeLists.txt b/soem_examples/soem_gpio_pulse/freertos/CMakeLists.txt
index 80b4a994e..8d46edec0 100644
--- a/soem_examples/soem_gpio_pulse/freertos/CMakeLists.txt
+++ b/soem_examples/soem_gpio_pulse/freertos/CMakeLists.txt
@@ -17,18 +17,6 @@ mcux_add_include(
     INCLUDES examples/soem_examples/soem_gpio_pulse/freertos
 )
 
-mcux_add_armgcc_configuration(
-    LD "-Xlinker --defsym=__stack_size__=0x2000 -Xlinker --defsym=__heap_size__=0x10000"
-)
-
-mcux_add_iar_configuration(
-    LD "--config_def=__stack_size__=0x2000 --config_def=__heap_size__=0x10000"
-)
-
-mcux_add_mdk_configuration(
-    LD "--predefine=\"-D__stack_size__=0x2000\" --predefine=\"-D__heap_size__=0x10000\""
-)
-
 include(${SdkRootDirPath}/${board_root}/${board}/soem_examples/soem_gpio_pulse/freertos/${multicore_foldername}/reconfig.cmake OPTIONAL)
 
 mcux_convert_binary(BINARY ${APPLICATION_BINARY_DIR}/${MCUX_SDK_PROJECT_NAME}.bin)
\ No newline at end of file
diff --git a/soem_examples/soem_gpio_pulse/freertos/soem_gpio_pulse.c b/soem_examples/soem_gpio_pulse/freertos/soem_gpio_pulse.c
index 61138b0fb..3d54de98c 100644
--- a/soem_examples/soem_gpio_pulse/freertos/soem_gpio_pulse.c
+++ b/soem_examples/soem_gpio_pulse/freertos/soem_gpio_pulse.c
@@ -218,9 +218,13 @@ static int if_port_init(void)
     struct soem_if_port soem_port;
     memset(&if_port, 0, sizeof(if_port));
     if_port.bufferConfig = buffConfig;
-    if_port.base         = ENET;
+    if_port.base         = EXAMPLE_ENET;
     /* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+    if_port.mii_mode                   = kENET_RgmiiMode;
+#else
     if_port.mii_mode                   = kENET_RmiiMode;
+#endif
     if_port.phy_config.autoNeg         = true;
     if_port.phy_config.phyAddr         = EXAMPLE_PHY_ADDRESS;
     if_port.phy_config.resource        = EXAMPLE_PHY_RESOURCE;
diff --git a/soem_examples/soem_servo_motor/bm/soem_servo_motor.c b/soem_examples/soem_servo_motor/bm/soem_servo_motor.c
index 66174013b..066d64b9c 100644
--- a/soem_examples/soem_servo_motor/bm/soem_servo_motor.c
+++ b/soem_examples/soem_servo_motor/bm/soem_servo_motor.c
@@ -299,27 +299,6 @@ void control_task(char *ifname)
 				ec_statecheck(1, EC_STATE_OPERATIONAL, 50000);
 			} while (chk-- && (ec_slave[0].state != EC_STATE_OPERATIONAL));
 
-			for (i = 0; i < MAX_AXIS; i++) {
-				PDO_write_targe_position(&axis[i], axis[i].current_position);
-			}
-
-			PRINTF("Request operational state for all slaves\r\n");
-			expectedWKC = (ec_group[0].outputsWKC * 2) + ec_group[0].inputsWKC;
-			PRINTF("Calculated workcounter %d\r\n", expectedWKC);
-			ec_slave[0].state = EC_STATE_OPERATIONAL;
-			/* send one valid process data to make outputs in slaves happy*/
-			ec_send_processdata();
-			ec_receive_processdata(EC_TIMEOUTRET);
-			/* request OP state for all slaves */
-			ec_writestate(0);
-			chk = 500;
-			/* wait for all slaves to reach OP state */
-			do {
-				ec_send_processdata();
-				ec_receive_processdata(EC_TIMEOUTRET);
-				ec_statecheck(1, EC_STATE_OPERATIONAL, 50000);
-			} while (chk-- && (ec_slave[0].state != EC_STATE_OPERATIONAL));
-
 			
 			if (ec_slave[0].state != EC_STATE_OPERATIONAL) {
 				PRINTF("Not all slaves reached operational state.\r\n");
@@ -406,7 +385,7 @@ int main(void)
 
 	osal_timer_init(0);
 
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+#if ((defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM) || (defined(EXAMPLE_ENET_NUM) && EXAMPLE_ENET_NUM))
 	if_port_init();
 #endif
 #if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
diff --git a/soem_examples/soem_servo_motor/freertos/CMakeLists.txt b/soem_examples/soem_servo_motor/freertos/CMakeLists.txt
new file mode 100644
index 000000000..1f3f69942
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/CMakeLists.txt
@@ -0,0 +1,27 @@
+
+cmake_minimum_required(VERSION 3.22.0)
+
+include(${SdkRootDirPath}/cmake/extension/mcux.cmake)
+
+project(soem_servo_motor_freertos LANGUAGES C CXX ASM PROJECT_BOARD_PORT_PATH ${board_root}/${board}/soem_examples/soem_servo_motor/freertos)
+
+include(${SdkRootDirPath}/CMakeLists.txt)
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES examples/soem_examples/soem_servo_motor/freertos/soem_servo_motor.c
+    SOURCES examples/soem_examples/soem_servo_motor/freertos/axis_nc.c
+    SOURCES examples/soem_examples/soem_servo_motor/freertos/axis_nc.h
+    SOURCES examples/soem_examples/soem_servo_motor/freertos/cia402.c
+    SOURCES examples/soem_examples/soem_servo_motor/freertos/cia402.h
+    SOURCES examples/soem_examples/soem_servo_motor/freertos/servo.c
+    SOURCES examples/soem_examples/soem_servo_motor/freertos/servo.h
+)
+
+mcux_add_include(
+    BASE_PATH ${SdkRootDirPath}
+    INCLUDES examples/soem_examples/soem_servo_motor/freertos
+)
+
+include(${SdkRootDirPath}/${board_root}/${board}/soem_examples/soem_servo_motor/freertos/${core_id}/reconfig.cmake OPTIONAL)
+
+mcux_convert_binary(BINARY ${APPLICATION_BINARY_DIR}/${MCUX_SDK_PROJECT_NAME}.bin)
\ No newline at end of file
diff --git a/soem_examples/soem_servo_motor/freertos/FreeRTOSConfig.h b/soem_examples/soem_servo_motor/freertos/FreeRTOSConfig.h
new file mode 100644
index 000000000..a26fe8ccd
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/FreeRTOSConfig.h
@@ -0,0 +1,122 @@
+/*
+FreeRTOS Kernel V10.3.0
+Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+ http://aws.amazon.com/freertos
+ http://www.FreeRTOS.org
+*/
+
+#ifndef FREERTOS_CONFIG_H
+#define FREERTOS_CONFIG_H
+
+/*-----------------------------------------------------------
+ * Application specific definitions.
+ *
+ * These definitions should be adjusted for your particular hardware and
+ * application requirements.
+ *
+ * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
+ * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
+ *
+ * See http://www.freertos.org/a00110.html.
+ *----------------------------------------------------------*/
+
+#define configUSE_PREEMPTION                    1
+#define configUSE_TICKLESS_IDLE                 0
+#define configCPU_CLOCK_HZ                      (SystemCoreClock)
+#define configTICK_RATE_HZ                      ((TickType_t)200)
+#define configMAX_PRIORITIES                    5
+#define configMINIMAL_STACK_SIZE                ((unsigned short)90)
+#define configMAX_TASK_NAME_LEN                 20
+#define configUSE_16_BIT_TICKS                  0
+#define configIDLE_SHOULD_YIELD                 1
+#define configUSE_TASK_NOTIFICATIONS            1
+#define configUSE_MUTEXES                       1
+#define configUSE_RECURSIVE_MUTEXES             1
+#define configUSE_COUNTING_SEMAPHORES           1
+#define configUSE_ALTERNATIVE_API               0 /* Deprecated! */
+#define configQUEUE_REGISTRY_SIZE               8
+#define configUSE_QUEUE_SETS                    0
+#define configUSE_TIME_SLICING                  0
+#define configUSE_NEWLIB_REENTRANT              0
+#define configENABLE_BACKWARD_COMPATIBILITY     0
+#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 5
+
+/* Used memory allocation (heap_x.c) */
+#define configFRTOS_MEMORY_SCHEME               1
+/* Tasks.c additions (e.g. Thread Aware Debug capability) */
+#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0
+
+/* Memory allocation related definitions. */
+#define configSUPPORT_STATIC_ALLOCATION         1
+#define configSUPPORT_DYNAMIC_ALLOCATION        0
+#define configTOTAL_HEAP_SIZE                   ((size_t)(10 * 1024))
+#define configAPPLICATION_ALLOCATED_HEAP        0
+
+/* Hook function related definitions. */
+#define configUSE_IDLE_HOOK                     0
+#define configUSE_TICK_HOOK                     0
+#define configCHECK_FOR_STACK_OVERFLOW          0
+#define configUSE_MALLOC_FAILED_HOOK            0
+#define configUSE_DAEMON_TASK_STARTUP_HOOK      0
+
+/* Run time and task stats gathering related definitions. */
+#define configGENERATE_RUN_TIME_STATS           0
+#define configUSE_TRACE_FACILITY                0
+#define configUSE_STATS_FORMATTING_FUNCTIONS    0
+
+/* Task aware debugging. */
+#define configRECORD_STACK_HIGH_ADDRESS         0
+
+/* Co-routine related definitions. */
+#define configUSE_CO_ROUTINES                   0
+#define configMAX_CO_ROUTINE_PRIORITIES         0
+
+/* Software timer related definitions. */
+#define configUSE_TIMERS                        1
+#define configTIMER_TASK_PRIORITY               (configMAX_PRIORITIES - 1)
+#define configTIMER_QUEUE_LENGTH                10
+#define configTIMER_TASK_STACK_DEPTH            (configMINIMAL_STACK_SIZE * 2)
+
+/* Define to trap errors during development. */
+#define configASSERT(x) if(( x) == 0) {taskDISABLE_INTERRUPTS(); for (;;);}
+
+/* Optional functions - most linkers will remove unused functions anyway. */
+#define INCLUDE_vTaskPrioritySet                1
+#define INCLUDE_uxTaskPriorityGet               1
+#define INCLUDE_vTaskDelete                     1
+#define INCLUDE_vTaskSuspend                    1
+#define INCLUDE_vTaskDelayUntil                 1
+#define INCLUDE_vTaskDelay                      1
+#define INCLUDE_xTaskGetSchedulerState          0
+#define INCLUDE_xTaskGetCurrentTaskHandle       1
+#define INCLUDE_uxTaskGetStackHighWaterMark     0
+#define INCLUDE_xTaskGetIdleTaskHandle          0
+#define INCLUDE_eTaskGetState                   1
+#define INCLUDE_xTimerPendFunctionCall          1
+#define INCLUDE_xTaskAbortDelay                 0
+#define INCLUDE_xTaskGetHandle                  0
+#define INCLUDE_xTaskResumeFromISR              1
+
+/****************** Macro definitions ***************/
+
+#include "FreeRTOSConfigBoard.h"
+
+#endif /* FREERTOS_CONFIG_H */
diff --git a/soem_examples/soem_servo_motor/freertos/axis_nc.c b/soem_examples/soem_servo_motor/freertos/axis_nc.c
new file mode 100644
index 000000000..453faff27
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/axis_nc.c
@@ -0,0 +1,308 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include <math.h>
+#include "axis_nc.h"
+#include "cia402.h"
+#include "ethercat.h"
+#include "servo.h"
+
+#define skip_blank(p) while ((*(p)) == ' ') (p) += 1
+inline static int skip_semicolon(char **str)
+{
+	char *p = strchr((char *)*str, ';');
+	if (!p) {
+		printf("Each instruction must end with ';'\r\n");
+		return -1;
+	}
+	*str = p + 1;
+	return 0;
+}
+
+static int parameter_parser(char **str, char *parameter_name, int32_t *parameter)
+{
+	int len = strlen(parameter_name);
+	int n;
+	char *s = *str;
+	if (strncmp(parameter_name, s, len) == 0) {
+		s += len;
+		n = sscanf(s, "=%ld", parameter);
+		if (n != 1) {
+			printf("The parameter \"%s\" can not be assigned\r\n", parameter_name);
+			return -1;
+		}
+		if (skip_semicolon(str) < 0) {
+			return -1;
+		}
+		return 1;
+	}
+	return 0;
+
+}
+
+int32_t axis_nc_get_next_pos(struct axis_t *axis)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	struct trajectory_planner_t *tp = &status->tp[status->current_tp];
+	double value;
+	int32_t ret;
+	uint32_t index = tp->current_point;
+	if (index <  tp->point_accel_end)
+		value = 0.5 * status->acceleration * index * index;
+	else if (index > tp->point_decel_start)
+		value = tp->decel_pos + 0.5 * status->deceleration * pow((index - tp->point_decel_start), 2);
+	else
+		value = tp->accel_pos + tp->uniform_speed * ( index - tp->point_accel_end);
+	value *= tp->direction;
+	value += tp->origin_pos;
+	value *= axis->scale;
+	ret = (int64_t)value & 0xFFFFFFFF;
+
+	tp->current_point++;
+	if (tp->current_point < tp->points_num) {
+		return ret;
+	}
+
+	tp->current_point = 0;
+	status->current_tp++;
+	if (status->current_tp < status->tp_num) {
+		return ret;
+	}
+
+	if (status->is_cyclic && status->csp_status != csp_status_pre_stop) {
+		status->current_tp = 1;
+	} else {
+		status->csp_status = csp_status_stop;
+		status->current_tp = 0;
+	}
+	return ret;
+}
+
+/* Uising trapezoidal move profile */
+static int trajectory_planner(struct axis_t *axis, struct trajectory_planner_t *tp)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	double delta_pos = tp->target_pos - tp->origin_pos;
+	double accel = status->acceleration;
+	double decel = status->deceleration;
+	double point_num = tp->points_num;
+	double a0 = 0.5*(accel + accel * accel / decel);
+	double b0 = -accel*point_num;
+	double c0;
+
+	tp->direction = 1;
+	if (delta_pos < 0) {
+		tp->direction = -1;
+	}
+
+	delta_pos *= tp->direction;
+
+	c0 = delta_pos;
+	double delta = b0 * b0 - 4 * a0 * c0;
+	if ( delta < 0 ) {
+		return -1;
+	}
+	double t0 = (-1 * b0 - sqrt(delta)) / 2 / a0;
+	double t1 = point_num - accel * t0 / decel;
+	if (t0 * accel > status->max_speed) {
+		return -2;
+	}
+
+	tp->accel_pos = 0.5 * accel * t0 * t0;
+	tp->decel_pos = tp->accel_pos + accel * t0 * (t1 - t0);
+	tp->point_accel_end = (uint32_t)(t0 + 0.5);
+	tp->point_decel_start = (uint32_t)(t1 + 0.5);
+	tp->uniform_speed = accel * t0;
+	return 0;
+}
+
+static int Tp_arrays_parser(struct axis_t *axis, char *tp_str, uint32_t period_ns)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	double next_pos;
+	uint32_t time;
+	int n = 0, i = 0;
+	char *p = tp_str;
+	char *tp_arrays = NULL;
+	int ret;
+	int32_t value;
+	double origin_pos = 0; // = (double)axis->current_position / axis->scale;
+	double bias = 0;
+	if (axis->mode != op_mode_csp) {
+		return -1;
+	}
+
+	if (status->csp_status == csp_status_running) {
+		return -2;
+	}
+
+	while (*p != '\0') {
+		skip_blank(p);
+		ret = parameter_parser(&p, "Cyclic", &value);
+		if (ret < 0)
+			return -5;
+		else if ( ret == 1) {
+			status->is_cyclic = value > 0 ? 1 : 0;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Scale", &value);
+		if (ret < 0)
+			return -5;
+		else if ( ret == 1) {
+			axis->scale = value;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Bias", &value);
+		if (ret < 0)
+			return -1;
+		else if ( ret == 1) {
+			status->bias = value;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Accel", &value);
+		if (ret < 0)
+			return -1;
+		else if ( ret == 1) {
+			status->acceleration = value;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Decel", &value);
+		if (ret < 0)
+			return -1;
+		else if ( ret == 1) {
+			status->deceleration = value;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Max_speed", &value);
+		if (ret < 0)
+			return -1;
+		else if ( ret == 1) {
+			status->max_speed = value;
+			continue;
+		}
+
+		if (strncmp("TpArrays", p, 8) == 0) {
+			p += 8;
+			tp_arrays = strchr(p, '[');
+			if (!tp_arrays) {
+				return -5;
+			}
+			char *pp = strchr(p, ']');
+			if (!pp) {
+				return -5;
+			}
+			tp_arrays += 1; // skip '['
+			pp = strchr(pp + 1, ';');
+			if (!pp) {
+				return -5;
+			}
+			p = pp + 1;
+			continue;
+		}
+		p++;
+	}
+	p = tp_arrays;
+	while (1) {
+		if (p == NULL) {
+			break;
+		}
+		if ((p = strchr(p, '(')) == NULL)
+			break;
+		n++;
+		p++;
+	}
+
+	if (n == 0) {
+		return -3;
+	}
+
+	if (n >= TRAJECTORY_PLANNER_MAX) {
+		return -4;
+	}
+
+	if (status->is_cyclic) {
+		n += 1;
+	}
+
+	status->tp_num = n;
+
+	p = tp_arrays;
+	bias = (double)status->bias + (double)axis->current_position / axis->scale;
+	origin_pos = bias;
+	while (1) {
+		skip_blank(p);
+		n = sscanf(p, "(%ld:%ld)", &value, &time);
+		if (n != 2)
+			return -5;
+		next_pos = bias + value;
+		status->tp[i].points_num = (uint64_t)time * 1000000 / period_ns;
+		status->tp[i].current_point = 0;
+		status->tp[i].origin_pos = origin_pos;
+		status->tp[i].target_pos = next_pos;
+		trajectory_planner(axis, status->tp + i);
+		i++;
+		origin_pos = next_pos;
+		skip_blank(p);
+		if ((p = strchr(p, ',')) == NULL)
+			break;
+		p++;
+	}
+	if (status->is_cyclic) {
+		n = sscanf(tp_arrays, "(%ld:%ld)", &value, &time);
+		if (n != 2)
+			return -5;
+		next_pos = bias + value;
+		status->tp[i].points_num = (uint64_t)time * 1000000 / period_ns;
+		status->tp[i].current_point = 0;
+		status->tp[i].origin_pos = origin_pos;
+		status->tp[i].target_pos = next_pos;
+		trajectory_planner(axis, status->tp + i);
+	}
+	status->csp_status = csp_status_ready;
+	return 0;
+}
+
+int axis_nc_init(struct axis_t *axis, char *tp, uint32_t period_ns)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	ec_slavet *slave = axis->servo->slave;
+	int ret;
+	int psize = 4;
+	axis->mode = op_mode_csp;
+	status->csp_status = csp_status_stop;
+	axis->scale = 1;
+	axis->output_offset = slave->outputs + axis->axis_offset * rxpdos_axis_size;
+	axis->input_offset = slave->inputs + axis->axis_offset * txpdos_axis_size;
+	ec_SDOread(axis->servo->slave_id + 1, 0x6064 + axis->axis_offset * 0x800, 0, FALSE, &psize, &axis->current_position, EC_TIMEOUTSAFE);
+	ret = Tp_arrays_parser(axis, tp, period_ns);
+	if (ret < 0) {
+		return ret;
+	}
+	status->csp_status = csp_status_ready;
+	return 0;
+}
+
+int axis_nc_start(struct axis_t *axis)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	status->csp_status = csp_status_running;
+	return 0;
+}
+
+int axis_nc_stop(struct axis_t *axis)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	status->csp_status = csp_status_pre_stop;
+	return 0;
+}
diff --git a/soem_examples/soem_servo_motor/freertos/axis_nc.h b/soem_examples/soem_servo_motor/freertos/axis_nc.h
new file mode 100644
index 000000000..c7fbecb1e
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/axis_nc.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __AXIS__NC____H__
+#define __AXIS__NC____H__
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+
+#define TRAJECTORY_PLANNER_MAX  20
+#define NSEC_PER_SEC (1000000000)
+#define timespec_add(a, b, result)                          \
+    do {                                                      \
+        (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;           \
+        (result)->tv_nsec = (a)->tv_nsec + (b)->tv_nsec;        \
+        if ((result)->tv_nsec >= NSEC_PER_SEC)                  \
+        {                                                       \
+            ++(result)->tv_sec;                             \
+            (result)->tv_nsec -= NSEC_PER_SEC;              \
+        }                                                       \
+    } while (0)
+
+struct trajectory_planner_t
+{
+	uint32_t points_num;
+	uint32_t current_point;
+	double origin_pos;
+	double target_pos;
+	double uniform_speed;
+	double accel_pos;
+	double decel_pos;
+	uint32_t point_accel_end;
+	uint32_t point_decel_start;
+	int32_t direction;
+};
+
+typedef enum {
+	csp_status_stop = 0,
+	csp_status_ready = 1,
+	csp_status_running = 2,
+	csp_status_pre_stop = 3,
+} csp_status_t;
+
+struct axis_csp_status_t {
+	int32_t bias;
+	uint32_t tp_num;
+	uint32_t is_cyclic;
+	uint32_t current_tp;
+	double acceleration;
+	double deceleration;
+	double max_speed;
+	csp_status_t csp_status;
+	struct trajectory_planner_t tp[TRAJECTORY_PLANNER_MAX];
+};
+
+struct axis_t {
+	struct servo_t *servo;
+	int axis_offset;
+	uint8_t *output_offset;
+	uint8_t *input_offset;
+	char *tp;
+	uint8_t mode;
+	int32_t current_position;
+	int32_t current_velocity;
+	uint32_t scale;
+	struct axis_csp_status_t axis_status;
+};
+
+int32_t axis_nc_get_next_pos(struct axis_t *axis);
+int axis_nc_slave_check(struct axis_t *axis, int axis_num);
+int axis_nc_synced_check(struct axis_t *axis, int axis_num);
+int axis_nc_init(struct axis_t *axis, char *tp, uint32_t period_ns);
+int axis_nc_start(struct axis_t *axis);
+int axis_nc_stop(struct axis_t *axis);
+
+#endif
diff --git a/soem_examples/soem_servo_motor/freertos/cia402.c b/soem_examples/soem_servo_motor/freertos/cia402.c
new file mode 100644
index 000000000..f10bc6e35
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/cia402.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include "ethercat.h"
+#include "axis_nc.h"
+#include "servo.h"
+#include "cia402.h"
+
+uint32_t tx_pdo_entry[1][4] = {
+	{ // axis 0
+	0x60410010, // statusword
+	0x60640020, // actual_position
+	0x606C0020, // actual_velocity
+	0x60610008  // op_mode_display
+	}
+};
+
+uint32_t rx_pdo_entry[1][4] = {
+	{ // axis 0
+	0x60400010, // controlword
+	0x607A0020, // Target position
+	0x60FF0020, // Target velocity
+	0x60600010  // op_mode
+	}
+};
+
+int servo_pdo_activate_map(struct servo_t *servo)
+{
+	int slave = servo->slave_id + 1;
+	uint16 map_1c12[2] = {0x0001, 0x1600};
+	uint16 map_1c13[2] = {0x0001, 0x1a00};
+	uint8_t map_6060 = 8;
+	uint16 num_16b = 0;
+
+	ec_SDOwrite(slave, 0x1c12, 0x00, 0, 2, &num_16b, EC_TIMEOUTSAFE);
+	ec_SDOwrite(slave, 0x1c13, 0x00, 0, 2, &num_16b, EC_TIMEOUTSAFE);
+	
+	ec_SDOwrite(slave, 0x1c12, 0x01, 0, sizeof(map_1c12[1]), &map_1c12[1], EC_TIMEOUTSAFE);
+	ec_SDOwrite(slave, 0x1c12, 0x00, 0, sizeof(map_1c12[0]), &map_1c12[0], EC_TIMEOUTSAFE);
+
+	ec_SDOwrite(slave, 0x1c13, 0x01, 0, sizeof(map_1c13[1]), &map_1c13[1], EC_TIMEOUTSAFE);
+	ec_SDOwrite(slave, 0x1c13, 0x00, 0, sizeof(map_1c13[0]), &map_1c13[0], EC_TIMEOUTSAFE);
+	
+	ec_SDOwrite(slave, 0x6060, 0x00, 0, 1, &map_6060, EC_TIMEOUTSAFE);
+	return 0;
+}
+
+int servo_pdo_remap(struct servo_t *servo)
+{
+	int slave = servo->slave_id + 1;
+	int wkc = 0, wkc_expected = 10;
+	int i;
+	uint8 num_8b = 0;
+	uint16 map_1c12[2] = {0x0001, 0x1600};
+	uint16 map_1c13[2] = {0x0001, 0x1a00};
+	uint16 num_16b = 0;
+	wkc += ec_SDOwrite(slave, 0x1c12, 0x00, 0, 2, &num_16b, EC_TIMEOUTSAFE);
+	wkc += ec_SDOwrite(slave, 0x1c13, 0x00, 0, 2, &num_16b, EC_TIMEOUTSAFE);
+
+	num_8b = 0;
+	wkc += ec_SDOwrite(slave, 0x1600, 0x00, 0, 1, &num_8b, EC_TIMEOUTSAFE);
+	for (i = 0; i < servo->axis_num; i++) {
+		wkc += ec_SDOwrite(slave, 0x1600, i * 3 + 0x01, 0, 4, &rx_pdo_entry[i][0], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1600, i * 3 + 0x02, 0, 4, &rx_pdo_entry[i][1], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1600, i * 3 + 0x03, 0, 4, &rx_pdo_entry[i][2], EC_TIMEOUTSAFE);
+		num_8b += 3;
+		wkc_expected += 3;
+	}
+	wkc += ec_SDOwrite(slave, 0x1600, 0x00, 0, 1, &num_8b, EC_TIMEOUTSAFE);
+
+	num_8b = 0;
+	wkc += ec_SDOwrite(slave, 0x1a00, 0x00, 0, 1, &num_8b, EC_TIMEOUTSAFE);
+	for (i = 0; i < servo->axis_num; i++) {
+		wkc += ec_SDOwrite(slave, 0x1a00, i * 4 + 0x01, 0, 4, &tx_pdo_entry[i][0], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1a00, i * 4 + 0x02, 0, 4, &tx_pdo_entry[i][1], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1a00, i * 4 + 0x03, 0, 4, &tx_pdo_entry[i][2], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1a00, i * 4 + 0x04, 0, 4, &tx_pdo_entry[i][3], EC_TIMEOUTSAFE);
+		num_8b += 4;
+		wkc_expected += 4;
+	}
+	wkc += ec_SDOwrite(slave, 0x1a00, 0x00, 0, 1, &num_8b, EC_TIMEOUTSAFE);
+
+	wkc += ec_SDOwrite(slave, 0x1c12, 0x01, 0, sizeof(map_1c12[1]), &map_1c12[1], EC_TIMEOUTSAFE);
+	wkc += ec_SDOwrite(slave, 0x1c12, 0x00, 0, sizeof(map_1c12[0]), &map_1c12[0], EC_TIMEOUTSAFE);
+
+	wkc += ec_SDOwrite(slave, 0x1c13, 0x01, 0, sizeof(map_1c13[1]), &map_1c13[1], EC_TIMEOUTSAFE);
+	wkc += ec_SDOwrite(slave, 0x1c13, 0x00, 0, sizeof(map_1c13[0]), &map_1c13[0], EC_TIMEOUTSAFE);
+
+	return wkc >= wkc_expected ? 1 : 0;
+}
+
+#define contrlword_shutdown(c)				(((c) | 0x6) & ~0x81)
+#define contrlword_switch_on(c)		 		(((c) | 0x7) & ~0x88)
+#define contrlword_disable_voltage(c)		((c)	& ~0x82)
+#define contrlword_quick_stop(c)			(((c) | 0x2) & ~0x84)
+#define contrlword_disable_operation(c)	 	(((c) | 0x7) & ~0x88)
+#define contrlword_enable_operation(c)		(((c) | 0xF) & ~0x80)
+#define contrlword_fault_reset(c)			((c) | 0x80)
+#define contrlword_new_set_point(c)	 		((c) | 0x10)
+#define contrlword_new_set_point_imm(c)	 	((c) | 0x30)
+
+static int get_axle_state(uint16_t status_word) {
+	if ((status_word & 0x4F) == 0x40)
+		return switch_on_disable;
+	if ((status_word & 0x6F) == 0x21)
+		return ready_to_switch_on;
+	if ((status_word & 0x6F) == 0x23)
+		return switched_on;
+	if ((status_word & 0x6F) == 0x27)
+		return operation_enable;
+	if ((status_word & 0x6F) == 0x07)
+		return quick_stop_active;
+	if ((status_word & 0x4F) == 0xF)
+		return fault_reaction_active;
+	if ((status_word & 0x4F) == 0x08)
+		return fault;
+	else
+		return no_ready_to_switch_on;
+}
+
+int axis_start(struct axis_t *si, uint8_t mode) {
+	int ret = 0;
+	int ss;
+	uint16 s = PDO_read_status_word(si);
+	ss = get_axle_state(s);
+
+	if (s & 0x8) {
+		PDO_write_control_word(si, 0x80);
+		return 0;
+	}
+
+	switch (ss) {
+		case (no_ready_to_switch_on):
+		case (switch_on_disable):
+			PDO_write_control_word(si, contrlword_shutdown(0));
+			break;
+		case (ready_to_switch_on):
+			PDO_write_control_word(si, contrlword_switch_on(0));
+			break;
+		case (switched_on):
+			PDO_write_control_word(si, contrlword_enable_operation(0));
+			PDO_write_op_mode(si, mode);
+			break;
+		case (operation_enable):
+			ret = 1;
+			break;
+		case (quick_stop_active):
+		case (fault_reaction_active):
+		case (fault):
+		default:
+			ret = -1;
+	}
+	return ret;
+}
diff --git a/soem_examples/soem_servo_motor/freertos/cia402.h b/soem_examples/soem_servo_motor/freertos/cia402.h
new file mode 100644
index 000000000..35bc5b716
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/cia402.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __CIA_402__H__
+#define __CIA_402__H__
+#include <inttypes.h>
+
+#include "axis_nc.h"
+
+#define status_word_offset 0
+#define actual_position_offset 2
+#define actual_velocity_offset 6
+#define op_mode_display_offset 10
+
+#define control_word_offset 0
+#define target_position_offset 2
+#define target_velocity_offset 6
+#define op_mode_offset 10
+
+#define txpdos_axis_size 12 
+#define rxpdos_axis_size  12
+
+#define PDO_write_control_word(si, value) 		*((uint16 *)((si)->output_offset + control_word_offset)) = (value)
+#define PDO_write_op_mode(si, value) 			*((uint16 *)((si)->output_offset + op_mode_offset)) = (value)
+#define PDO_write_targe_position(si, value) 	*((int32 *)((si)->output_offset + target_position_offset)) = (value)
+
+#define PDO_read_control_word(si) 		*((uint16 *)((si)->output_offset + control_word_offset))
+#define PDO_read_op_mode(si) 			*((uint16 *)((si)->output_offset + op_mode_offset))
+#define PDO_read_targe_position(si) 	*((uint32 *)((si)->output_offset + target_position_offset))
+
+#define PDO_read_status_word(si) 		*((uint16 *)((si)->input_offset + status_word_offset))
+#define PDO_read_actual_position(si) 	*((uint32 *)((si)->input_offset + actual_position_offset))
+#define PDO_read_op_mode_display(si) 	*((uint16 *)((si)->input_offset + op_mode_display_offset))
+#define PDO_read_actual_velocity(si) 	*((uint32 *)((si)->input_offset + actual_velocity_offset))
+
+#define	no_ready_to_switch_on 0
+#define	switch_on_disable 1
+#define ready_to_switch_on 2
+#define	switched_on 3
+#define	operation_enable 4
+#define quick_stop_active 5
+#define fault_reaction_active 6
+#define fault 7
+
+#define    op_mode_no   0
+#define    op_mode_pp   1
+#define    op_mode_vl   2
+#define    op_mode_pv   3
+#define    op_mode_hm   6
+#define    op_mode_ip   7
+#define    op_mode_csp  8
+#define    op_mode_csv  9
+#define    op_mode_cst  10
+
+int servo_pdo_remap(struct servo_t *servo);
+int servo_pdo_activate_map(struct servo_t *servo);
+int axis_start(struct axis_t *axis, uint8_t mode);
+#endif
+
diff --git a/soem_examples/soem_servo_motor/freertos/example.yml b/soem_examples/soem_servo_motor/freertos/example.yml
new file mode 100644
index 000000000..90794faf1
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/example.yml
@@ -0,0 +1,14 @@
+soem_servo_motor_freertos:
+  section-type: application
+  contents:
+    meta_path: examples/soem_examples/soem_servo_motor/freertos
+    project-root-path: boards/${board}/soem_examples/soem_servo_motor/freertos/${multicore_foldername}
+    document:
+      name: soem_servo_motor${core_id_suffix_name}
+      category: soem_examples
+      brief: SOEM servo motor example
+      example_readme:
+      - examples/soem_examples/soem_servo_motor/freertos/readme.md
+      - ${board_root}/${board}/soem_examples/soem_servo_motor/freertos/example_board_readme.md
+      - ${board_root}/${board}/examples_shared_readme.md
+  boards:
diff --git a/soem_examples/soem_servo_motor/freertos/prj.conf b/soem_examples/soem_servo_motor/freertos/prj.conf
new file mode 100644
index 000000000..f89b1c2f0
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/prj.conf
@@ -0,0 +1 @@
+CONFIG_configSUPPORT_STATIC_ALLOCATION=y
\ No newline at end of file
diff --git a/soem_examples/soem_servo_motor/freertos/readme.md b/soem_examples/soem_servo_motor/freertos/readme.md
new file mode 100644
index 000000000..bce7af89a
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/readme.md
@@ -0,0 +1,60 @@
+# soem_servo_motor_rt1180_bm
+
+## Overview
+This example demonstrates how to use the Simple Open EtherCAT Master (SOEM) Library to control motor.
+
+In this example there are 2 NXP EVK board:
+
+	SOEM as EtherCAT MainDevice running on EVK board(i.MXRT1180/FRDM-1186/i.MX943)
+
+	ecat_servo_motor example as EtherCAT SubDevice running on i.MXRT1180 EVK board
+
+	Note: 
+
+		ecat_servo_motor path: .../boards/evkmimxrt1180/ecat_examples/servo_motor
+
+
+## Running the demo
+If the test passes, the motor will start to retate.
+
+When the demo is running, the serial port will output:
+
+NETC EP frame loopback example start.
+
+Starting motion task
+
+ec_init on netc0 succeeded.
+
+ec_config_init 0
+
+...
+
+1 slaves found and configured.
+
+ec_config_map_group IOmap:20000664 group:0
+
+>Slave 1, configadr 1001, state  2
+
+...
+
+Slaves mapped, state to SAFE_OP.
+
+Request operational state for all slaves
+
+Calculated workcounter 3
+
+Request operational state for all slaves
+
+Calculated workcounter 3
+
+Operational state reached for all slaves.
+
+
+Note: Modify GPT timer frequncy >= 200MHz to get more accurate timer.
+
+Note: Detailed SOEM performance please refter to EtherCAT Benchamrk. 
+
+## Supported Boards
+- [MIMXRT1180-EVK](../../../_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md)
+- [FRDM-MIMXRT1186](../../../_boards/frdmimxrt1186/soem_examples/soem_gpio_pulse/bm/example_board_readme.md)
+- [IMX943-EVK](../../../_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md)
diff --git a/soem_examples/soem_servo_motor/freertos/servo.c b/soem_examples/soem_servo_motor/freertos/servo.c
new file mode 100644
index 000000000..7df6af9b4
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/servo.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <string.h>
+#include <stdio.h>
+#include <inttypes.h>
+#include <math.h>
+#include <stdlib.h>
+#include "axis_nc.h"
+#include "servo.h"
+
+int servo_slave_check(struct servo_t *servo, int servo_num)
+{
+	int index;
+	int ret = -1;
+	int i;
+	for (i = 0; i < servo_num; i++) {
+		index = servo[i].slave_id + 1;
+		if (index > ec_slavecount) {
+			ret = -i;
+		} else if (ec_slave[index].eep_man != servo[i].VendorId || ec_slave[index].eep_id != servo[i].ProductID) {
+			ret = -i;
+		} else {
+			ret = 1;
+		}
+
+		if (ret < 0) {
+			servo[i].slave = NULL;
+			break;
+		} else {
+			servo[i].slave = &ec_slave[index];
+		}
+	}
+	return ret;
+}
+
+int servo_synced_check(struct servo_t *servo, int servo_num)
+{
+	int ret = 1;
+	int i;
+	int wkc;
+	int32_t diff;
+	for (i = 0; i < servo_num; i++) {
+		if (!servo[i].synced) {
+			wkc=ecx_FPRD(ecx_context.port, servo[i].slave->configadr, ECT_REG_DCSYSDIFF, sizeof(diff), &diff, EC_TIMEOUTRET);	
+			if (wkc == 1 && abs(diff) < 100000) {
+				servo[i].synced = 1;
+			} else {
+				ret = -i;
+				break;
+			}
+		}
+	}
+	return ret;
+}
diff --git a/soem_examples/soem_servo_motor/freertos/servo.h b/soem_examples/soem_servo_motor/freertos/servo.h
new file mode 100644
index 000000000..36bbe10af
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/servo.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __SERVO__NC____H__
+#define __SERVO__NC____H__
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "ethercat.h"
+
+struct servo_t {
+	uint32 VendorId;
+	uint32 ProductID;
+	int slave_id;
+	ec_slavet *slave;
+	int (*setup)(uint16 slave);
+	int synced;
+	int axis_num;
+};
+
+int servo_synced_check(struct servo_t *servo, int servo_num);
+int servo_slave_check(struct servo_t *servo, int servo_num);
+#endif
diff --git a/soem_examples/soem_servo_motor/freertos/soem_servo_motor.c b/soem_examples/soem_servo_motor/freertos/soem_servo_motor.c
new file mode 100644
index 000000000..549d72060
--- /dev/null
+++ b/soem_examples/soem_servo_motor/freertos/soem_servo_motor.c
@@ -0,0 +1,534 @@
+/*
+ * Copyright (c) 2015, Freescale Semiconductor, Inc.
+ * Copyright 2016-2025 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*******************************************************************************
+ * Includes
+ ******************************************************************************/
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "cia402.h"
+#include "servo.h"
+
+#include "app.h"
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+#define NUM_1M (1000000UL)
+#define CYCLE_PERIOD_NS 1000000 // 1ms
+#define SOEM_PERIOD 	(CYCLE_PERIOD_NS / 1000) // 1ms
+
+#define asda_b3_VendorId 0x000001dd
+#define asda_b3_ProductID 0x00006080
+
+#define sv680_VendorId 0x00100000
+#define sv680_ProductID 0x000c0116
+
+#define nxp_VendorId 0x00000CC2
+#define nxp_ProductID 0x00000002
+
+#define MAX_SERVO 2
+#define MAX_AXIS 2
+
+#define RT_TASK_STACK_SIZE 1024
+/*******************************************************************************
+ * Variables
+ ******************************************************************************/
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(static enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(static enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+AT_NONCACHEABLE_SECTION_ALIGN(
+    static uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+    ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(
+    static uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+    ENET_BUFF_ALIGNMENT);
+
+static enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+
+static char IOmap[1500];
+
+static char *tp[MAX_SERVO] = {
+
+// DELTA
+"Cyclic=1; Scale=46603; Bias=0; Accel=8; Decel=8; Max_speed=3600; TpArrays=[(0:2000),(270:1000),(270:2000),(180:1000),(180:2000),(0:1000),(0:2000),(0:1000)];",
+
+// INOVANCE
+"Cyclic=1; Scale=186414; Bias=0; Accel=8; Decel=8; Max_speed=3600; TpArrays=[(0:2000),(270:1000),(270:2000),(180:1000),(180:2000),(0:1000),(0:2000),(0:1000)];",
+
+};
+
+static StackType_t IdleTaskStack[configMINIMAL_STACK_SIZE];
+static StaticTask_t IdleTaskTCB;
+
+static StackType_t TimerTaskStacj[configMINIMAL_STACK_SIZE];
+static StaticTask_t TimerTaskTCB;
+
+static TaskHandle_t rt_task = NULL;
+static StaticTask_t xTaskBuffer;
+static StackType_t rt_task_stack[RT_TASK_STACK_SIZE];
+
+static struct enet_if_port if_port;
+
+static uint32_t timer_irq_period = 0; /* unit: microsecond*/
+
+static struct timeval system_time_base = {
+	.tv_sec = 0,
+	.tv_usec =  0
+};
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+/*******************************************************************************
+ * Code
+ ******************************************************************************/
+void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,
+                                   StackType_t **ppxIdleTaskStackBuffer,
+                                   configSTACK_DEPTH_TYPE *pulIdleTaskStackSize)
+{
+    *ppxIdleTaskTCBBuffer   = &IdleTaskTCB;
+    *ppxIdleTaskStackBuffer = &IdleTaskStack[0];
+    *pulIdleTaskStackSize   = configMINIMAL_STACK_SIZE;
+}
+
+void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer,
+                                    StackType_t **ppxTimerTaskStackBuffer,
+                                    uint32_t *pulTimerTaskStackSize)
+{
+    *ppxTimerTaskTCBBuffer   = &TimerTaskTCB;
+    *ppxTimerTaskStackBuffer = &TimerTaskStacj[0];
+    *pulTimerTaskStackSize   = configMINIMAL_STACK_SIZE;
+}
+
+struct servo_t servo[MAX_SERVO];
+struct axis_t axis[MAX_AXIS];
+
+static void EtherCAT_servo_init(struct servo_t *svo, struct axis_t *ax)
+{
+	int i;
+	memset(svo, 0, sizeof(struct servo_t) * MAX_SERVO);
+	memset(ax, 0, sizeof(struct axis_t) * MAX_AXIS);
+	for (i = 0; i < MAX_SERVO; i++) {
+		svo[i].slave_id = i;
+		svo[i].axis_num = 1;
+	}
+	
+	for (i = 0; i < 1; i++) {
+		svo[i].VendorId = asda_b3_VendorId;
+		svo[i].ProductID = asda_b3_ProductID;
+	}
+
+    for (i = 1; i < 2; i++) {
+		svo[i].VendorId = sv680_VendorId;
+		svo[i].ProductID = sv680_ProductID;
+	}
+
+	for (i = 0; i < MAX_SERVO; i++) {
+		ax[i].servo = svo + i;
+		ax[i].axis_offset = 0;
+	}
+}
+
+static int general_servo_setup(uint16 slave) {
+	int i;
+	int ret = 0;
+	int chk = 10;
+	struct servo_t *svo = NULL;
+	for (i = 0; i < MAX_SERVO; i++) {
+		if (servo[i].slave_id + 1 == slave) {
+			svo = &servo[i];
+			break;
+		}
+	}
+	if (svo) {
+		while (chk--) {
+			ret = servo_pdo_remap(svo);
+			if (ret)
+				break;
+		}
+	}
+
+	if (!ret)
+		return 0;
+	else
+		return -1;
+}
+
+static int nxp_servo_setup(uint16 slave) {
+	int i;
+	int ret = 0;
+	int chk = 10;
+	struct servo_t *svo = NULL;
+	for (i = 0; i < MAX_SERVO; i++) {
+		if (servo[i].slave_id + 1 == slave) {
+			svo = &servo[i];
+			break;
+		}
+	}
+	if (svo) {
+		while (chk--) {
+			ret = servo_pdo_activate_map(svo);
+			if (ret)
+				break;
+		}
+	}
+
+	if (!ret)
+		return 0;
+	else
+		return -1;
+}
+
+static int asda_b3_servo_setup(uint16 slave) {
+	int i;
+	int ret = 0;
+	int chk = 10;
+	struct servo_t *svo = NULL;
+	for (i = 0; i < MAX_SERVO; i++) {
+		if (servo[i].slave_id + 1 == slave) {
+			svo = &servo[i];
+			break;
+		}
+	}
+	if (svo) {
+		while (chk--) {
+			ret = servo_pdo_remap(svo);
+			if (ret)
+				break;
+		}
+	}
+
+	if (!ret)
+		return 0;
+
+	int8_t  Obj60c2[9][2] = {{12, -5},{25, -5}, {37, -5}, {5, -4},{62, -5}, {75, -5},{87, -5},{1, -3}, {2, -3}};
+	int8_t num_8b[2];
+	int wkc = 0;
+	if (CYCLE_PERIOD_NS > 1000000) {
+		num_8b[0] = CYCLE_PERIOD_NS / 1000000;
+		num_8b[1] = -3;
+	} else {
+		int index = ((CYCLE_PERIOD_NS - 1) / 125000);
+		num_8b[0] = Obj60c2[index][0];
+		num_8b[1] = Obj60c2[index][1];
+	}
+	int obj_60c2_index = 0x60c2;
+	for ( i = 0; i < svo->axis_num; i++) {
+		obj_60c2_index += i * 0x800;
+		wkc += ec_SDOwrite(slave, obj_60c2_index, 0x01, 0, 1, &num_8b[0], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, obj_60c2_index, 0x02, 0, 1, &num_8b[1], EC_TIMEOUTSAFE);
+	}
+	return wkc == svo->axis_num * 2 ? 1 : 0;
+}
+
+static void servo_setup(struct servo_t *servo, int servo_num) {
+	int i;
+	for (i = 0; i < servo_num; i++) {
+		if (servo[i].VendorId == asda_b3_VendorId && servo[i].ProductID == asda_b3_ProductID) {
+			servo[i].slave->PO2SOconfig = asda_b3_servo_setup;
+			PRINTF("\r\n delta_servo_setup success!\r\n");
+		} else if (servo[i].VendorId == nxp_VendorId && servo[i].ProductID == nxp_ProductID) {
+			servo[i].slave->PO2SOconfig = nxp_servo_setup;
+			PRINTF("\r\n nxp_servo_setup success!\r\n");
+		} else {
+			servo[i].slave->PO2SOconfig = general_servo_setup;
+		}
+
+	}
+}
+
+void irq_wake_task(void)
+{
+    BaseType_t xHigherPriorityTaskWoken;
+
+    if (rt_task)
+    {
+        xHigherPriorityTaskWoken = pdFALSE;
+        vTaskNotifyGiveFromISR(rt_task, &xHigherPriorityTaskWoken);
+        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
+    }
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+    /* Clear interrupt flag. */
+    GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+    system_time_base.tv_usec += SOEM_PERIOD;
+
+    if (system_time_base.tv_usec >= NUM_1M)
+    {
+        system_time_base.tv_sec += system_time_base.tv_usec / NUM_1M;
+        system_time_base.tv_usec = system_time_base.tv_usec % NUM_1M;
+    }
+
+    irq_wake_task();
+
+    /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F
+     * Store immediate overlapping
+     * exception return operation might vector to incorrect interrupt
+     */
+    SDK_ISR_EXIT_BARRIER;
+}
+
+static void osal_timer_init(uint32_t usec, uint32_t priority)
+{
+    uint32_t gptFreq;
+    gpt_config_t gptConfig;
+
+    assert(usec != 0);
+    assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+    timer_irq_period = usec;
+    GPT_GetDefaultConfig(&gptConfig);
+    GPT_Init(OSAL_TIMER, &gptConfig);
+    gptFreq = OSAL_TIMER_CLK_FREQ;
+    /* Divide GPT clock source frequency to 1MHz */
+    GPT_SetClockDivider(OSAL_TIMER, gptFreq / NUM_1M);
+    /* Set both GPT modules to 1 second duration */
+    GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, timer_irq_period);
+    /* Enable GPT Output Compare1 interrupt */
+    GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+    /* Enable at the Interrupt */
+    NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+    EnableIRQ(OSAL_TIMER_IRQ_ID);
+    GPT_StartTimer(OSAL_TIMER);
+}
+
+/* OSHW: register enet port to SOEM stack */
+static int if_port_init(void)
+{
+    struct soem_if_port soem_port;
+    memset(&if_port, 0, sizeof(if_port));
+    if_port.bufferConfig = buffConfig;
+    if_port.base         = EXAMPLE_ENET;
+    /* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+    if_port.mii_mode                   = kENET_RgmiiMode;
+#else
+    if_port.mii_mode                   = kENET_RmiiMode;
+#endif
+    if_port.phy_config.autoNeg         = true;
+    if_port.phy_config.phyAddr         = EXAMPLE_PHY_ADDRESS;
+    if_port.phy_config.resource        = EXAMPLE_PHY_RESOURCE;
+    if_port.phy_config.ops             = EXAMPLE_PHY_OPS;
+    if_port.srcClock_Hz                = EXAMPLE_CLOCK_FREQ;
+    if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+    if_port.phy_stability_delay_us     = PHY_STABILITY_DELAY_US;
+    
+    soem_port.port_init = enet_init;
+    soem_port.port_send = enet_send;
+    soem_port.port_recv = enet_recv;
+    soem_port.port_link_status = enet_link_status;
+    soem_port.port_close = enet_close;
+    strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+    strncpy(soem_port.dev_name, "enet", SOEM_DEV_NAME_MAXLEN);
+    soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+void control_task(void *ifname)
+{
+	int expectedWKC;
+	volatile int wkc;
+	int chk, i;
+    int wkc_lost = 0;
+	PRINTF("Starting motion task\r\n");
+	const TickType_t xBlockTime = pdMS_TO_TICKS(500);
+	EtherCAT_servo_init(servo, axis);
+
+	/* initialise SOEM, and if_port */
+	if (ec_init(ifname)) {
+		printf("ec_init on %s succeeded.\n",ifname);
+		/* find and auto-config slaves */
+		if ( ec_config_init(FALSE) > 0 ) {
+			printf("%d slaves found and configured.\n",ec_slavecount);
+			if (ec_slavecount < MAX_SERVO) {
+				printf("The number of Servo scanned is not consistent with configed, please reconfirm\n");
+				return;
+			}
+
+			i = servo_slave_check(servo, MAX_SERVO);
+			if (i < 0) {
+				printf("The infomation of Servo:%d is not consistent with scanned, please reconfirm\n", -i);
+				return;
+			}
+
+			ec_configdc();
+			chk = 100;
+			while (chk--) {
+				if (servo_synced_check(servo, MAX_SERVO) == 1) {
+					break;
+				}
+			}
+
+			for (i = 0; i < MAX_SERVO; i++) {
+				if(servo[i].slave->hasdc > 0) {
+				ec_dcsync0(servo[i].slave_id + 1, TRUE, CYCLE_PERIOD_NS, CYCLE_PERIOD_NS * 3);
+				}
+			}
+
+			servo_setup(servo, MAX_SERVO);	
+			ec_config_map(&IOmap);
+			for (i = 0; i < MAX_AXIS; i++) {
+				axis_nc_init(&axis[i], tp[i], CYCLE_PERIOD_NS);
+			}
+			printf("Slaves mapped, state to SAFE_OP.\n");
+			/* wait for all slaves to reach SAFE_OP state */
+			ec_statecheck(0, EC_STATE_SAFE_OP,  EC_TIMEOUTSTATE * 4);
+			for (i = 0; i < MAX_AXIS; i++) {
+				PDO_write_targe_position(&axis[i], axis[i].current_position);
+				axis_nc_start(&axis[i]);
+			}
+			printf("segments : %d : %lu %lu %lu %lu\n",ec_group[0].nsegments ,ec_group[0].IOsegment[0],ec_group[0].IOsegment[1],ec_group[0].IOsegment[2],ec_group[0].IOsegment[3]);
+
+			printf("Request operational state for all slaves\n");
+			expectedWKC = (ec_group[0].outputsWKC * 2) + ec_group[0].inputsWKC;
+			printf("Calculated workcounter %d\n", expectedWKC);
+			ec_slave[0].state = EC_STATE_OPERATIONAL;
+			/* send one valid process data to make outputs in slaves happy*/
+			ec_send_processdata();
+			ec_receive_processdata(EC_TIMEOUTRET);
+			/* request OP state for all slaves */
+			ec_writestate(0);
+			chk = 500;
+			/* wait for all slaves to reach OP state */
+			do {
+				ec_send_processdata();
+				ec_receive_processdata(EC_TIMEOUTRET);
+				ec_statecheck(1, EC_STATE_OPERATIONAL, 50000);
+			} while (chk-- && (ec_slave[0].state != EC_STATE_OPERATIONAL));
+
+			for (i = 0; i < MAX_AXIS; i++) {
+				PDO_write_targe_position(&axis[i], axis[i].current_position);
+			}
+
+			PRINTF("Request operational state for all slaves\r\n");
+			expectedWKC = (ec_group[0].outputsWKC * 2) + ec_group[0].inputsWKC;
+			PRINTF("Calculated workcounter %d\r\n", expectedWKC);
+			ec_slave[0].state = EC_STATE_OPERATIONAL;
+			/* send one valid process data to make outputs in slaves happy*/
+			ec_send_processdata();
+			ec_receive_processdata(EC_TIMEOUTRET);
+			/* request OP state for all slaves */
+			ec_writestate(0);
+			chk = 500;
+			/* wait for all slaves to reach OP state */
+			do {
+				ec_send_processdata();
+				ec_receive_processdata(EC_TIMEOUTRET);
+				ec_statecheck(1, EC_STATE_OPERATIONAL, 50000);
+			} while (chk-- && (ec_slave[0].state != EC_STATE_OPERATIONAL));
+
+			
+			if (ec_slave[0].state != EC_STATE_OPERATIONAL) {
+				PRINTF("Not all slaves reached operational state.\r\n");
+			} else {
+				PRINTF("Operational state reached for all slaves.\r\n");
+				/* send one valid process data to make outputs in slaves happy*/
+				ec_send_processdata();
+			
+				int op_num = 0;
+				while (1) {
+					/* SOEM receive data */
+					wkc = ec_receive_processdata(EC_TIMEOUTRET);
+					
+					/* servo motor application processing code */
+					for(i = 0; i < MAX_AXIS; i++) {
+						if (axis_start(&axis[i], op_mode_csp) != 1) {
+								op_num++;
+						}
+					}
+					if (op_num == 0) {
+						if(wkc >= expectedWKC) {
+							for(i = 0; i < MAX_AXIS; i++) {
+								axis[i].current_velocity = PDO_read_actual_velocity(&axis[i]);
+								axis[i].current_position = PDO_read_actual_position(&axis[i]);
+								if (axis[i].axis_status.csp_status == csp_status_running || axis[i].axis_status.csp_status == csp_status_pre_stop) {
+									int pos = axis_nc_get_next_pos(&axis[i]);
+									PDO_write_targe_position(&axis[i], pos);
+								}
+							} 
+							if (axis[MAX_AXIS-1].axis_status.csp_status == csp_status_stop) {
+								break;
+							}
+						} else {
+							wkc_lost++;
+							ec_slave[0].state = EC_STATE_OPERATIONAL;
+							ec_writestate(0);
+						}
+					} else {
+						op_num = 0;
+					}
+
+					/* SOEM tramsmit data */
+					ec_send_processdata();
+					ulTaskNotifyTake(pdFALSE, xBlockTime);
+				}
+				printf("wkc_lost = %d\r\n", wkc_lost);
+				printf("\r\nRequest init state for all slaves\r\n");
+				for(i = 1; i<=ec_slavecount ; i++) {
+					if(ec_slave[i].state != EC_STATE_OPERATIONAL) {
+						PRINTF("Slave %d State=0x%2.2x StatusCode=0x%4.4x : %s\r\n",
+						i, ec_slave[i].state, ec_slave[i].ALstatuscode, ec_ALstatuscode2string(ec_slave[i].ALstatuscode));
+					}
+				}
+
+				ec_slave[0].state = EC_STATE_INIT;
+				/* request INIT state for all slaves */
+				ec_writestate(0);
+			}
+			/* stop SOEM, close socket */
+			ec_close();
+		} else {
+			printf("No socket connection on %s\nExecute as root\r\n",ifname);
+		}
+	} else {
+		PRINTF("ec_init error\r\n");
+	}
+}
+
+/*!
+ * @brief Main function
+ */
+int main(void)
+{
+    BOARD_InitHardware();
+
+    PRINTF("Start the soem_servo_rt1180 FreeRTOS example...\r\n");
+
+    osal_timer_init(SOEM_PERIOD, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY);
+    if_port_init();
+    rt_task = xTaskCreateStatic(/* The function that implements the task. */
+                                control_task, "RT_task", RT_TASK_STACK_SIZE, SOEM_PORT_NAME, configMAX_PRIORITIES - 1,
+                                rt_task_stack, &xTaskBuffer);
+
+    vTaskStartScheduler();
+    return 0;
+}
+
diff --git a/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c b/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c
index 16eb4404e..d5cc39910 100644
--- a/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c
+++ b/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c
@@ -373,7 +373,7 @@ int main(void)
 	
 	osal_timer_init(0);
 
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+#if ((defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM) || (defined(EXAMPLE_ENET_NUM) && EXAMPLE_ENET_NUM))
 	if_port_init();
 #endif
 #if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/CMakeLists.txt b/soem_examples/soem_servo_motor_rt1180/freertos/CMakeLists.txt
new file mode 100644
index 000000000..b341e5443
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/CMakeLists.txt
@@ -0,0 +1,27 @@
+
+cmake_minimum_required(VERSION 3.22.0)
+
+include(${SdkRootDirPath}/cmake/extension/mcux.cmake)
+
+project(soem_servo_motor_rt1180_freertos LANGUAGES C CXX ASM PROJECT_BOARD_PORT_PATH ${board_root}/${board}/soem_examples/soem_servo_motor_rt1180/freertos)
+
+include(${SdkRootDirPath}/CMakeLists.txt)
+mcux_add_source(
+    BASE_PATH ${SdkRootDirPath}
+    SOURCES examples/soem_examples/soem_servo_motor_rt1180/freertos/soem_servo_motor.c
+    SOURCES examples/soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.c
+    SOURCES examples/soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.h
+    SOURCES examples/soem_examples/soem_servo_motor_rt1180/freertos/cia402.c
+    SOURCES examples/soem_examples/soem_servo_motor_rt1180/freertos/cia402.h
+    SOURCES examples/soem_examples/soem_servo_motor_rt1180/freertos/servo.c
+    SOURCES examples/soem_examples/soem_servo_motor_rt1180/freertos/servo.h
+)
+
+mcux_add_include(
+    BASE_PATH ${SdkRootDirPath}
+    INCLUDES examples/soem_examples/soem_servo_motor_rt1180/freertos
+)
+
+include(${SdkRootDirPath}/${board_root}/${board}/soem_examples/soem_servo_motor_rt1180/freertos/${core_id}/reconfig.cmake OPTIONAL)
+
+mcux_convert_binary(BINARY ${APPLICATION_BINARY_DIR}/${MCUX_SDK_PROJECT_NAME}.bin)
\ No newline at end of file
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/FreeRTOSConfig.h b/soem_examples/soem_servo_motor_rt1180/freertos/FreeRTOSConfig.h
new file mode 100644
index 000000000..a26fe8ccd
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/FreeRTOSConfig.h
@@ -0,0 +1,122 @@
+/*
+FreeRTOS Kernel V10.3.0
+Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+ http://aws.amazon.com/freertos
+ http://www.FreeRTOS.org
+*/
+
+#ifndef FREERTOS_CONFIG_H
+#define FREERTOS_CONFIG_H
+
+/*-----------------------------------------------------------
+ * Application specific definitions.
+ *
+ * These definitions should be adjusted for your particular hardware and
+ * application requirements.
+ *
+ * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
+ * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
+ *
+ * See http://www.freertos.org/a00110.html.
+ *----------------------------------------------------------*/
+
+#define configUSE_PREEMPTION                    1
+#define configUSE_TICKLESS_IDLE                 0
+#define configCPU_CLOCK_HZ                      (SystemCoreClock)
+#define configTICK_RATE_HZ                      ((TickType_t)200)
+#define configMAX_PRIORITIES                    5
+#define configMINIMAL_STACK_SIZE                ((unsigned short)90)
+#define configMAX_TASK_NAME_LEN                 20
+#define configUSE_16_BIT_TICKS                  0
+#define configIDLE_SHOULD_YIELD                 1
+#define configUSE_TASK_NOTIFICATIONS            1
+#define configUSE_MUTEXES                       1
+#define configUSE_RECURSIVE_MUTEXES             1
+#define configUSE_COUNTING_SEMAPHORES           1
+#define configUSE_ALTERNATIVE_API               0 /* Deprecated! */
+#define configQUEUE_REGISTRY_SIZE               8
+#define configUSE_QUEUE_SETS                    0
+#define configUSE_TIME_SLICING                  0
+#define configUSE_NEWLIB_REENTRANT              0
+#define configENABLE_BACKWARD_COMPATIBILITY     0
+#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 5
+
+/* Used memory allocation (heap_x.c) */
+#define configFRTOS_MEMORY_SCHEME               1
+/* Tasks.c additions (e.g. Thread Aware Debug capability) */
+#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0
+
+/* Memory allocation related definitions. */
+#define configSUPPORT_STATIC_ALLOCATION         1
+#define configSUPPORT_DYNAMIC_ALLOCATION        0
+#define configTOTAL_HEAP_SIZE                   ((size_t)(10 * 1024))
+#define configAPPLICATION_ALLOCATED_HEAP        0
+
+/* Hook function related definitions. */
+#define configUSE_IDLE_HOOK                     0
+#define configUSE_TICK_HOOK                     0
+#define configCHECK_FOR_STACK_OVERFLOW          0
+#define configUSE_MALLOC_FAILED_HOOK            0
+#define configUSE_DAEMON_TASK_STARTUP_HOOK      0
+
+/* Run time and task stats gathering related definitions. */
+#define configGENERATE_RUN_TIME_STATS           0
+#define configUSE_TRACE_FACILITY                0
+#define configUSE_STATS_FORMATTING_FUNCTIONS    0
+
+/* Task aware debugging. */
+#define configRECORD_STACK_HIGH_ADDRESS         0
+
+/* Co-routine related definitions. */
+#define configUSE_CO_ROUTINES                   0
+#define configMAX_CO_ROUTINE_PRIORITIES         0
+
+/* Software timer related definitions. */
+#define configUSE_TIMERS                        1
+#define configTIMER_TASK_PRIORITY               (configMAX_PRIORITIES - 1)
+#define configTIMER_QUEUE_LENGTH                10
+#define configTIMER_TASK_STACK_DEPTH            (configMINIMAL_STACK_SIZE * 2)
+
+/* Define to trap errors during development. */
+#define configASSERT(x) if(( x) == 0) {taskDISABLE_INTERRUPTS(); for (;;);}
+
+/* Optional functions - most linkers will remove unused functions anyway. */
+#define INCLUDE_vTaskPrioritySet                1
+#define INCLUDE_uxTaskPriorityGet               1
+#define INCLUDE_vTaskDelete                     1
+#define INCLUDE_vTaskSuspend                    1
+#define INCLUDE_vTaskDelayUntil                 1
+#define INCLUDE_vTaskDelay                      1
+#define INCLUDE_xTaskGetSchedulerState          0
+#define INCLUDE_xTaskGetCurrentTaskHandle       1
+#define INCLUDE_uxTaskGetStackHighWaterMark     0
+#define INCLUDE_xTaskGetIdleTaskHandle          0
+#define INCLUDE_eTaskGetState                   1
+#define INCLUDE_xTimerPendFunctionCall          1
+#define INCLUDE_xTaskAbortDelay                 0
+#define INCLUDE_xTaskGetHandle                  0
+#define INCLUDE_xTaskResumeFromISR              1
+
+/****************** Macro definitions ***************/
+
+#include "FreeRTOSConfigBoard.h"
+
+#endif /* FREERTOS_CONFIG_H */
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.c b/soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.c
new file mode 100644
index 000000000..453faff27
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.c
@@ -0,0 +1,308 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include <math.h>
+#include "axis_nc.h"
+#include "cia402.h"
+#include "ethercat.h"
+#include "servo.h"
+
+#define skip_blank(p) while ((*(p)) == ' ') (p) += 1
+inline static int skip_semicolon(char **str)
+{
+	char *p = strchr((char *)*str, ';');
+	if (!p) {
+		printf("Each instruction must end with ';'\r\n");
+		return -1;
+	}
+	*str = p + 1;
+	return 0;
+}
+
+static int parameter_parser(char **str, char *parameter_name, int32_t *parameter)
+{
+	int len = strlen(parameter_name);
+	int n;
+	char *s = *str;
+	if (strncmp(parameter_name, s, len) == 0) {
+		s += len;
+		n = sscanf(s, "=%ld", parameter);
+		if (n != 1) {
+			printf("The parameter \"%s\" can not be assigned\r\n", parameter_name);
+			return -1;
+		}
+		if (skip_semicolon(str) < 0) {
+			return -1;
+		}
+		return 1;
+	}
+	return 0;
+
+}
+
+int32_t axis_nc_get_next_pos(struct axis_t *axis)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	struct trajectory_planner_t *tp = &status->tp[status->current_tp];
+	double value;
+	int32_t ret;
+	uint32_t index = tp->current_point;
+	if (index <  tp->point_accel_end)
+		value = 0.5 * status->acceleration * index * index;
+	else if (index > tp->point_decel_start)
+		value = tp->decel_pos + 0.5 * status->deceleration * pow((index - tp->point_decel_start), 2);
+	else
+		value = tp->accel_pos + tp->uniform_speed * ( index - tp->point_accel_end);
+	value *= tp->direction;
+	value += tp->origin_pos;
+	value *= axis->scale;
+	ret = (int64_t)value & 0xFFFFFFFF;
+
+	tp->current_point++;
+	if (tp->current_point < tp->points_num) {
+		return ret;
+	}
+
+	tp->current_point = 0;
+	status->current_tp++;
+	if (status->current_tp < status->tp_num) {
+		return ret;
+	}
+
+	if (status->is_cyclic && status->csp_status != csp_status_pre_stop) {
+		status->current_tp = 1;
+	} else {
+		status->csp_status = csp_status_stop;
+		status->current_tp = 0;
+	}
+	return ret;
+}
+
+/* Uising trapezoidal move profile */
+static int trajectory_planner(struct axis_t *axis, struct trajectory_planner_t *tp)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	double delta_pos = tp->target_pos - tp->origin_pos;
+	double accel = status->acceleration;
+	double decel = status->deceleration;
+	double point_num = tp->points_num;
+	double a0 = 0.5*(accel + accel * accel / decel);
+	double b0 = -accel*point_num;
+	double c0;
+
+	tp->direction = 1;
+	if (delta_pos < 0) {
+		tp->direction = -1;
+	}
+
+	delta_pos *= tp->direction;
+
+	c0 = delta_pos;
+	double delta = b0 * b0 - 4 * a0 * c0;
+	if ( delta < 0 ) {
+		return -1;
+	}
+	double t0 = (-1 * b0 - sqrt(delta)) / 2 / a0;
+	double t1 = point_num - accel * t0 / decel;
+	if (t0 * accel > status->max_speed) {
+		return -2;
+	}
+
+	tp->accel_pos = 0.5 * accel * t0 * t0;
+	tp->decel_pos = tp->accel_pos + accel * t0 * (t1 - t0);
+	tp->point_accel_end = (uint32_t)(t0 + 0.5);
+	tp->point_decel_start = (uint32_t)(t1 + 0.5);
+	tp->uniform_speed = accel * t0;
+	return 0;
+}
+
+static int Tp_arrays_parser(struct axis_t *axis, char *tp_str, uint32_t period_ns)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	double next_pos;
+	uint32_t time;
+	int n = 0, i = 0;
+	char *p = tp_str;
+	char *tp_arrays = NULL;
+	int ret;
+	int32_t value;
+	double origin_pos = 0; // = (double)axis->current_position / axis->scale;
+	double bias = 0;
+	if (axis->mode != op_mode_csp) {
+		return -1;
+	}
+
+	if (status->csp_status == csp_status_running) {
+		return -2;
+	}
+
+	while (*p != '\0') {
+		skip_blank(p);
+		ret = parameter_parser(&p, "Cyclic", &value);
+		if (ret < 0)
+			return -5;
+		else if ( ret == 1) {
+			status->is_cyclic = value > 0 ? 1 : 0;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Scale", &value);
+		if (ret < 0)
+			return -5;
+		else if ( ret == 1) {
+			axis->scale = value;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Bias", &value);
+		if (ret < 0)
+			return -1;
+		else if ( ret == 1) {
+			status->bias = value;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Accel", &value);
+		if (ret < 0)
+			return -1;
+		else if ( ret == 1) {
+			status->acceleration = value;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Decel", &value);
+		if (ret < 0)
+			return -1;
+		else if ( ret == 1) {
+			status->deceleration = value;
+			continue;
+		}
+
+		ret = parameter_parser(&p, "Max_speed", &value);
+		if (ret < 0)
+			return -1;
+		else if ( ret == 1) {
+			status->max_speed = value;
+			continue;
+		}
+
+		if (strncmp("TpArrays", p, 8) == 0) {
+			p += 8;
+			tp_arrays = strchr(p, '[');
+			if (!tp_arrays) {
+				return -5;
+			}
+			char *pp = strchr(p, ']');
+			if (!pp) {
+				return -5;
+			}
+			tp_arrays += 1; // skip '['
+			pp = strchr(pp + 1, ';');
+			if (!pp) {
+				return -5;
+			}
+			p = pp + 1;
+			continue;
+		}
+		p++;
+	}
+	p = tp_arrays;
+	while (1) {
+		if (p == NULL) {
+			break;
+		}
+		if ((p = strchr(p, '(')) == NULL)
+			break;
+		n++;
+		p++;
+	}
+
+	if (n == 0) {
+		return -3;
+	}
+
+	if (n >= TRAJECTORY_PLANNER_MAX) {
+		return -4;
+	}
+
+	if (status->is_cyclic) {
+		n += 1;
+	}
+
+	status->tp_num = n;
+
+	p = tp_arrays;
+	bias = (double)status->bias + (double)axis->current_position / axis->scale;
+	origin_pos = bias;
+	while (1) {
+		skip_blank(p);
+		n = sscanf(p, "(%ld:%ld)", &value, &time);
+		if (n != 2)
+			return -5;
+		next_pos = bias + value;
+		status->tp[i].points_num = (uint64_t)time * 1000000 / period_ns;
+		status->tp[i].current_point = 0;
+		status->tp[i].origin_pos = origin_pos;
+		status->tp[i].target_pos = next_pos;
+		trajectory_planner(axis, status->tp + i);
+		i++;
+		origin_pos = next_pos;
+		skip_blank(p);
+		if ((p = strchr(p, ',')) == NULL)
+			break;
+		p++;
+	}
+	if (status->is_cyclic) {
+		n = sscanf(tp_arrays, "(%ld:%ld)", &value, &time);
+		if (n != 2)
+			return -5;
+		next_pos = bias + value;
+		status->tp[i].points_num = (uint64_t)time * 1000000 / period_ns;
+		status->tp[i].current_point = 0;
+		status->tp[i].origin_pos = origin_pos;
+		status->tp[i].target_pos = next_pos;
+		trajectory_planner(axis, status->tp + i);
+	}
+	status->csp_status = csp_status_ready;
+	return 0;
+}
+
+int axis_nc_init(struct axis_t *axis, char *tp, uint32_t period_ns)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	ec_slavet *slave = axis->servo->slave;
+	int ret;
+	int psize = 4;
+	axis->mode = op_mode_csp;
+	status->csp_status = csp_status_stop;
+	axis->scale = 1;
+	axis->output_offset = slave->outputs + axis->axis_offset * rxpdos_axis_size;
+	axis->input_offset = slave->inputs + axis->axis_offset * txpdos_axis_size;
+	ec_SDOread(axis->servo->slave_id + 1, 0x6064 + axis->axis_offset * 0x800, 0, FALSE, &psize, &axis->current_position, EC_TIMEOUTSAFE);
+	ret = Tp_arrays_parser(axis, tp, period_ns);
+	if (ret < 0) {
+		return ret;
+	}
+	status->csp_status = csp_status_ready;
+	return 0;
+}
+
+int axis_nc_start(struct axis_t *axis)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	status->csp_status = csp_status_running;
+	return 0;
+}
+
+int axis_nc_stop(struct axis_t *axis)
+{
+	struct axis_csp_status_t *status = &axis->axis_status;
+	status->csp_status = csp_status_pre_stop;
+	return 0;
+}
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.h b/soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.h
new file mode 100644
index 000000000..c7fbecb1e
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/axis_nc.h
@@ -0,0 +1,79 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __AXIS__NC____H__
+#define __AXIS__NC____H__
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+
+#define TRAJECTORY_PLANNER_MAX  20
+#define NSEC_PER_SEC (1000000000)
+#define timespec_add(a, b, result)                          \
+    do {                                                      \
+        (result)->tv_sec = (a)->tv_sec + (b)->tv_sec;           \
+        (result)->tv_nsec = (a)->tv_nsec + (b)->tv_nsec;        \
+        if ((result)->tv_nsec >= NSEC_PER_SEC)                  \
+        {                                                       \
+            ++(result)->tv_sec;                             \
+            (result)->tv_nsec -= NSEC_PER_SEC;              \
+        }                                                       \
+    } while (0)
+
+struct trajectory_planner_t
+{
+	uint32_t points_num;
+	uint32_t current_point;
+	double origin_pos;
+	double target_pos;
+	double uniform_speed;
+	double accel_pos;
+	double decel_pos;
+	uint32_t point_accel_end;
+	uint32_t point_decel_start;
+	int32_t direction;
+};
+
+typedef enum {
+	csp_status_stop = 0,
+	csp_status_ready = 1,
+	csp_status_running = 2,
+	csp_status_pre_stop = 3,
+} csp_status_t;
+
+struct axis_csp_status_t {
+	int32_t bias;
+	uint32_t tp_num;
+	uint32_t is_cyclic;
+	uint32_t current_tp;
+	double acceleration;
+	double deceleration;
+	double max_speed;
+	csp_status_t csp_status;
+	struct trajectory_planner_t tp[TRAJECTORY_PLANNER_MAX];
+};
+
+struct axis_t {
+	struct servo_t *servo;
+	int axis_offset;
+	uint8_t *output_offset;
+	uint8_t *input_offset;
+	char *tp;
+	uint8_t mode;
+	int32_t current_position;
+	int32_t current_velocity;
+	uint32_t scale;
+	struct axis_csp_status_t axis_status;
+};
+
+int32_t axis_nc_get_next_pos(struct axis_t *axis);
+int axis_nc_slave_check(struct axis_t *axis, int axis_num);
+int axis_nc_synced_check(struct axis_t *axis, int axis_num);
+int axis_nc_init(struct axis_t *axis, char *tp, uint32_t period_ns);
+int axis_nc_start(struct axis_t *axis);
+int axis_nc_stop(struct axis_t *axis);
+
+#endif
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/cia402.c b/soem_examples/soem_servo_motor_rt1180/freertos/cia402.c
new file mode 100644
index 000000000..f10bc6e35
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/cia402.c
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+
+#include "ethercat.h"
+#include "axis_nc.h"
+#include "servo.h"
+#include "cia402.h"
+
+uint32_t tx_pdo_entry[1][4] = {
+	{ // axis 0
+	0x60410010, // statusword
+	0x60640020, // actual_position
+	0x606C0020, // actual_velocity
+	0x60610008  // op_mode_display
+	}
+};
+
+uint32_t rx_pdo_entry[1][4] = {
+	{ // axis 0
+	0x60400010, // controlword
+	0x607A0020, // Target position
+	0x60FF0020, // Target velocity
+	0x60600010  // op_mode
+	}
+};
+
+int servo_pdo_activate_map(struct servo_t *servo)
+{
+	int slave = servo->slave_id + 1;
+	uint16 map_1c12[2] = {0x0001, 0x1600};
+	uint16 map_1c13[2] = {0x0001, 0x1a00};
+	uint8_t map_6060 = 8;
+	uint16 num_16b = 0;
+
+	ec_SDOwrite(slave, 0x1c12, 0x00, 0, 2, &num_16b, EC_TIMEOUTSAFE);
+	ec_SDOwrite(slave, 0x1c13, 0x00, 0, 2, &num_16b, EC_TIMEOUTSAFE);
+	
+	ec_SDOwrite(slave, 0x1c12, 0x01, 0, sizeof(map_1c12[1]), &map_1c12[1], EC_TIMEOUTSAFE);
+	ec_SDOwrite(slave, 0x1c12, 0x00, 0, sizeof(map_1c12[0]), &map_1c12[0], EC_TIMEOUTSAFE);
+
+	ec_SDOwrite(slave, 0x1c13, 0x01, 0, sizeof(map_1c13[1]), &map_1c13[1], EC_TIMEOUTSAFE);
+	ec_SDOwrite(slave, 0x1c13, 0x00, 0, sizeof(map_1c13[0]), &map_1c13[0], EC_TIMEOUTSAFE);
+	
+	ec_SDOwrite(slave, 0x6060, 0x00, 0, 1, &map_6060, EC_TIMEOUTSAFE);
+	return 0;
+}
+
+int servo_pdo_remap(struct servo_t *servo)
+{
+	int slave = servo->slave_id + 1;
+	int wkc = 0, wkc_expected = 10;
+	int i;
+	uint8 num_8b = 0;
+	uint16 map_1c12[2] = {0x0001, 0x1600};
+	uint16 map_1c13[2] = {0x0001, 0x1a00};
+	uint16 num_16b = 0;
+	wkc += ec_SDOwrite(slave, 0x1c12, 0x00, 0, 2, &num_16b, EC_TIMEOUTSAFE);
+	wkc += ec_SDOwrite(slave, 0x1c13, 0x00, 0, 2, &num_16b, EC_TIMEOUTSAFE);
+
+	num_8b = 0;
+	wkc += ec_SDOwrite(slave, 0x1600, 0x00, 0, 1, &num_8b, EC_TIMEOUTSAFE);
+	for (i = 0; i < servo->axis_num; i++) {
+		wkc += ec_SDOwrite(slave, 0x1600, i * 3 + 0x01, 0, 4, &rx_pdo_entry[i][0], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1600, i * 3 + 0x02, 0, 4, &rx_pdo_entry[i][1], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1600, i * 3 + 0x03, 0, 4, &rx_pdo_entry[i][2], EC_TIMEOUTSAFE);
+		num_8b += 3;
+		wkc_expected += 3;
+	}
+	wkc += ec_SDOwrite(slave, 0x1600, 0x00, 0, 1, &num_8b, EC_TIMEOUTSAFE);
+
+	num_8b = 0;
+	wkc += ec_SDOwrite(slave, 0x1a00, 0x00, 0, 1, &num_8b, EC_TIMEOUTSAFE);
+	for (i = 0; i < servo->axis_num; i++) {
+		wkc += ec_SDOwrite(slave, 0x1a00, i * 4 + 0x01, 0, 4, &tx_pdo_entry[i][0], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1a00, i * 4 + 0x02, 0, 4, &tx_pdo_entry[i][1], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1a00, i * 4 + 0x03, 0, 4, &tx_pdo_entry[i][2], EC_TIMEOUTSAFE);
+		wkc += ec_SDOwrite(slave, 0x1a00, i * 4 + 0x04, 0, 4, &tx_pdo_entry[i][3], EC_TIMEOUTSAFE);
+		num_8b += 4;
+		wkc_expected += 4;
+	}
+	wkc += ec_SDOwrite(slave, 0x1a00, 0x00, 0, 1, &num_8b, EC_TIMEOUTSAFE);
+
+	wkc += ec_SDOwrite(slave, 0x1c12, 0x01, 0, sizeof(map_1c12[1]), &map_1c12[1], EC_TIMEOUTSAFE);
+	wkc += ec_SDOwrite(slave, 0x1c12, 0x00, 0, sizeof(map_1c12[0]), &map_1c12[0], EC_TIMEOUTSAFE);
+
+	wkc += ec_SDOwrite(slave, 0x1c13, 0x01, 0, sizeof(map_1c13[1]), &map_1c13[1], EC_TIMEOUTSAFE);
+	wkc += ec_SDOwrite(slave, 0x1c13, 0x00, 0, sizeof(map_1c13[0]), &map_1c13[0], EC_TIMEOUTSAFE);
+
+	return wkc >= wkc_expected ? 1 : 0;
+}
+
+#define contrlword_shutdown(c)				(((c) | 0x6) & ~0x81)
+#define contrlword_switch_on(c)		 		(((c) | 0x7) & ~0x88)
+#define contrlword_disable_voltage(c)		((c)	& ~0x82)
+#define contrlword_quick_stop(c)			(((c) | 0x2) & ~0x84)
+#define contrlword_disable_operation(c)	 	(((c) | 0x7) & ~0x88)
+#define contrlword_enable_operation(c)		(((c) | 0xF) & ~0x80)
+#define contrlword_fault_reset(c)			((c) | 0x80)
+#define contrlword_new_set_point(c)	 		((c) | 0x10)
+#define contrlword_new_set_point_imm(c)	 	((c) | 0x30)
+
+static int get_axle_state(uint16_t status_word) {
+	if ((status_word & 0x4F) == 0x40)
+		return switch_on_disable;
+	if ((status_word & 0x6F) == 0x21)
+		return ready_to_switch_on;
+	if ((status_word & 0x6F) == 0x23)
+		return switched_on;
+	if ((status_word & 0x6F) == 0x27)
+		return operation_enable;
+	if ((status_word & 0x6F) == 0x07)
+		return quick_stop_active;
+	if ((status_word & 0x4F) == 0xF)
+		return fault_reaction_active;
+	if ((status_word & 0x4F) == 0x08)
+		return fault;
+	else
+		return no_ready_to_switch_on;
+}
+
+int axis_start(struct axis_t *si, uint8_t mode) {
+	int ret = 0;
+	int ss;
+	uint16 s = PDO_read_status_word(si);
+	ss = get_axle_state(s);
+
+	if (s & 0x8) {
+		PDO_write_control_word(si, 0x80);
+		return 0;
+	}
+
+	switch (ss) {
+		case (no_ready_to_switch_on):
+		case (switch_on_disable):
+			PDO_write_control_word(si, contrlword_shutdown(0));
+			break;
+		case (ready_to_switch_on):
+			PDO_write_control_word(si, contrlword_switch_on(0));
+			break;
+		case (switched_on):
+			PDO_write_control_word(si, contrlword_enable_operation(0));
+			PDO_write_op_mode(si, mode);
+			break;
+		case (operation_enable):
+			ret = 1;
+			break;
+		case (quick_stop_active):
+		case (fault_reaction_active):
+		case (fault):
+		default:
+			ret = -1;
+	}
+	return ret;
+}
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/cia402.h b/soem_examples/soem_servo_motor_rt1180/freertos/cia402.h
new file mode 100644
index 000000000..35bc5b716
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/cia402.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __CIA_402__H__
+#define __CIA_402__H__
+#include <inttypes.h>
+
+#include "axis_nc.h"
+
+#define status_word_offset 0
+#define actual_position_offset 2
+#define actual_velocity_offset 6
+#define op_mode_display_offset 10
+
+#define control_word_offset 0
+#define target_position_offset 2
+#define target_velocity_offset 6
+#define op_mode_offset 10
+
+#define txpdos_axis_size 12 
+#define rxpdos_axis_size  12
+
+#define PDO_write_control_word(si, value) 		*((uint16 *)((si)->output_offset + control_word_offset)) = (value)
+#define PDO_write_op_mode(si, value) 			*((uint16 *)((si)->output_offset + op_mode_offset)) = (value)
+#define PDO_write_targe_position(si, value) 	*((int32 *)((si)->output_offset + target_position_offset)) = (value)
+
+#define PDO_read_control_word(si) 		*((uint16 *)((si)->output_offset + control_word_offset))
+#define PDO_read_op_mode(si) 			*((uint16 *)((si)->output_offset + op_mode_offset))
+#define PDO_read_targe_position(si) 	*((uint32 *)((si)->output_offset + target_position_offset))
+
+#define PDO_read_status_word(si) 		*((uint16 *)((si)->input_offset + status_word_offset))
+#define PDO_read_actual_position(si) 	*((uint32 *)((si)->input_offset + actual_position_offset))
+#define PDO_read_op_mode_display(si) 	*((uint16 *)((si)->input_offset + op_mode_display_offset))
+#define PDO_read_actual_velocity(si) 	*((uint32 *)((si)->input_offset + actual_velocity_offset))
+
+#define	no_ready_to_switch_on 0
+#define	switch_on_disable 1
+#define ready_to_switch_on 2
+#define	switched_on 3
+#define	operation_enable 4
+#define quick_stop_active 5
+#define fault_reaction_active 6
+#define fault 7
+
+#define    op_mode_no   0
+#define    op_mode_pp   1
+#define    op_mode_vl   2
+#define    op_mode_pv   3
+#define    op_mode_hm   6
+#define    op_mode_ip   7
+#define    op_mode_csp  8
+#define    op_mode_csv  9
+#define    op_mode_cst  10
+
+int servo_pdo_remap(struct servo_t *servo);
+int servo_pdo_activate_map(struct servo_t *servo);
+int axis_start(struct axis_t *axis, uint8_t mode);
+#endif
+
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/example.yml b/soem_examples/soem_servo_motor_rt1180/freertos/example.yml
new file mode 100644
index 000000000..fd6e4948b
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/example.yml
@@ -0,0 +1,14 @@
+soem_servo_motor_rt1180_freertos:
+  section-type: application
+  contents:
+    meta_path: examples/soem_examples/soem_servo_motor_rt1180/freertos
+    project-root-path: boards/${board}/soem_examples/soem_servo_motor_rt1180/freertos/${multicore_foldername}
+    document:
+      name: soem_servo_motor_rt1180${core_id_suffix_name}
+      category: soem_examples
+      brief: SOEM servo motor example
+      example_readme:
+      - examples/soem_examples/soem_servo_motor_rt1180/freertos/readme.md
+      - ${board_root}/${board}/soem_examples/soem_servo_motor_rt1180/freertos/example_board_readme.md
+      - ${board_root}/${board}/examples_shared_readme.md
+  boards:
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf b/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf
new file mode 100644
index 000000000..f89b1c2f0
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/prj.conf
@@ -0,0 +1 @@
+CONFIG_configSUPPORT_STATIC_ALLOCATION=y
\ No newline at end of file
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/readme.md b/soem_examples/soem_servo_motor_rt1180/freertos/readme.md
new file mode 100644
index 000000000..bce7af89a
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/readme.md
@@ -0,0 +1,60 @@
+# soem_servo_motor_rt1180_bm
+
+## Overview
+This example demonstrates how to use the Simple Open EtherCAT Master (SOEM) Library to control motor.
+
+In this example there are 2 NXP EVK board:
+
+	SOEM as EtherCAT MainDevice running on EVK board(i.MXRT1180/FRDM-1186/i.MX943)
+
+	ecat_servo_motor example as EtherCAT SubDevice running on i.MXRT1180 EVK board
+
+	Note: 
+
+		ecat_servo_motor path: .../boards/evkmimxrt1180/ecat_examples/servo_motor
+
+
+## Running the demo
+If the test passes, the motor will start to retate.
+
+When the demo is running, the serial port will output:
+
+NETC EP frame loopback example start.
+
+Starting motion task
+
+ec_init on netc0 succeeded.
+
+ec_config_init 0
+
+...
+
+1 slaves found and configured.
+
+ec_config_map_group IOmap:20000664 group:0
+
+>Slave 1, configadr 1001, state  2
+
+...
+
+Slaves mapped, state to SAFE_OP.
+
+Request operational state for all slaves
+
+Calculated workcounter 3
+
+Request operational state for all slaves
+
+Calculated workcounter 3
+
+Operational state reached for all slaves.
+
+
+Note: Modify GPT timer frequncy >= 200MHz to get more accurate timer.
+
+Note: Detailed SOEM performance please refter to EtherCAT Benchamrk. 
+
+## Supported Boards
+- [MIMXRT1180-EVK](../../../_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md)
+- [FRDM-MIMXRT1186](../../../_boards/frdmimxrt1186/soem_examples/soem_gpio_pulse/bm/example_board_readme.md)
+- [IMX943-EVK](../../../_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md)
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/servo.c b/soem_examples/soem_servo_motor_rt1180/freertos/servo.c
new file mode 100644
index 000000000..7df6af9b4
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/servo.c
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <string.h>
+#include <stdio.h>
+#include <inttypes.h>
+#include <math.h>
+#include <stdlib.h>
+#include "axis_nc.h"
+#include "servo.h"
+
+int servo_slave_check(struct servo_t *servo, int servo_num)
+{
+	int index;
+	int ret = -1;
+	int i;
+	for (i = 0; i < servo_num; i++) {
+		index = servo[i].slave_id + 1;
+		if (index > ec_slavecount) {
+			ret = -i;
+		} else if (ec_slave[index].eep_man != servo[i].VendorId || ec_slave[index].eep_id != servo[i].ProductID) {
+			ret = -i;
+		} else {
+			ret = 1;
+		}
+
+		if (ret < 0) {
+			servo[i].slave = NULL;
+			break;
+		} else {
+			servo[i].slave = &ec_slave[index];
+		}
+	}
+	return ret;
+}
+
+int servo_synced_check(struct servo_t *servo, int servo_num)
+{
+	int ret = 1;
+	int i;
+	int wkc;
+	int32_t diff;
+	for (i = 0; i < servo_num; i++) {
+		if (!servo[i].synced) {
+			wkc=ecx_FPRD(ecx_context.port, servo[i].slave->configadr, ECT_REG_DCSYSDIFF, sizeof(diff), &diff, EC_TIMEOUTRET);	
+			if (wkc == 1 && abs(diff) < 100000) {
+				servo[i].synced = 1;
+			} else {
+				ret = -i;
+				break;
+			}
+		}
+	}
+	return ret;
+}
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/servo.h b/soem_examples/soem_servo_motor_rt1180/freertos/servo.h
new file mode 100644
index 000000000..36bbe10af
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/servo.h
@@ -0,0 +1,26 @@
+/*
+ * Copyright 2024 NXP
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __SERVO__NC____H__
+#define __SERVO__NC____H__
+#include <stdio.h>
+#include <string.h>
+#include <inttypes.h>
+#include "ethercat.h"
+
+struct servo_t {
+	uint32 VendorId;
+	uint32 ProductID;
+	int slave_id;
+	ec_slavet *slave;
+	int (*setup)(uint16 slave);
+	int synced;
+	int axis_num;
+};
+
+int servo_synced_check(struct servo_t *servo, int servo_num);
+int servo_slave_check(struct servo_t *servo, int servo_num);
+#endif
diff --git a/soem_examples/soem_servo_motor_rt1180/freertos/soem_servo_motor.c b/soem_examples/soem_servo_motor_rt1180/freertos/soem_servo_motor.c
new file mode 100644
index 000000000..0ffe68eb3
--- /dev/null
+++ b/soem_examples/soem_servo_motor_rt1180/freertos/soem_servo_motor.c
@@ -0,0 +1,479 @@
+/*
+ * Copyright (c) 2015, Freescale Semiconductor, Inc.
+ * Copyright 2016-2025 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+/*******************************************************************************
+ * Includes
+ ******************************************************************************/
+#include <stdlib.h>
+#include <stdio.h>
+
+#include "cia402.h"
+#include "servo.h"
+
+#include "app.h"
+
+/*******************************************************************************
+ * Definitions
+ ******************************************************************************/
+#define NUM_1M (1000000UL)
+#define CYCLE_PERIOD_NS 1000000 // 1ms
+#define SOEM_PERIOD 	(CYCLE_PERIOD_NS / 1000) // 1ms
+
+#define asda_b3_VendorId 0x000001dd
+#define asda_b3_ProductID 0x00006080
+
+#define nxp_VendorId 0x00000CC2
+#define nxp_ProductID 0x00000002
+
+#define MAX_SERVO 1
+#define MAX_AXIS 1
+
+#define RT_TASK_STACK_SIZE 1024
+/*******************************************************************************
+ * Variables
+ ******************************************************************************/
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(static enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(static enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+AT_NONCACHEABLE_SECTION_ALIGN(
+    static uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+    ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(
+    static uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+    ENET_BUFF_ALIGNMENT);
+
+static enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+
+static char IOmap[1500];
+
+static char *tp[MAX_SERVO] = {
+
+// NXP
+"Cyclic=1; Scale=364; Bias=0; Accel=8; Decel=8; Max_speed=3600; TpArrays=[(0:2000),(270:1000),(270:2000),(180:1000),(180:2000),(0:1000),(0:2000),(0:1000)];",
+
+};
+
+static StackType_t IdleTaskStack[configMINIMAL_STACK_SIZE];
+static StaticTask_t IdleTaskTCB;
+
+static StackType_t TimerTaskStacj[configMINIMAL_STACK_SIZE];
+static StaticTask_t TimerTaskTCB;
+
+static TaskHandle_t rt_task = NULL;
+static StaticTask_t xTaskBuffer;
+static StackType_t rt_task_stack[RT_TASK_STACK_SIZE];
+
+static struct enet_if_port if_port;
+
+static uint32_t timer_irq_period = 0; /* unit: microsecond*/
+
+static struct timeval system_time_base = {
+	.tv_sec = 0,
+	.tv_usec =  0
+};
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+
+/*******************************************************************************
+ * Code
+ ******************************************************************************/
+void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer,
+                                   StackType_t **ppxIdleTaskStackBuffer,
+                                   configSTACK_DEPTH_TYPE *pulIdleTaskStackSize)
+{
+    *ppxIdleTaskTCBBuffer   = &IdleTaskTCB;
+    *ppxIdleTaskStackBuffer = &IdleTaskStack[0];
+    *pulIdleTaskStackSize   = configMINIMAL_STACK_SIZE;
+}
+
+void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer,
+                                    StackType_t **ppxTimerTaskStackBuffer,
+                                    uint32_t *pulTimerTaskStackSize)
+{
+    *ppxTimerTaskTCBBuffer   = &TimerTaskTCB;
+    *ppxTimerTaskStackBuffer = &TimerTaskStacj[0];
+    *pulTimerTaskStackSize   = configMINIMAL_STACK_SIZE;
+}
+
+struct servo_t servo[MAX_SERVO];
+struct axis_t axis[MAX_AXIS];
+
+static void EtherCAT_servo_init(struct servo_t *svo, struct axis_t *ax)
+{
+	int i;
+	memset(svo, 0, sizeof(struct servo_t) * MAX_SERVO);
+	memset(ax, 0, sizeof(struct axis_t) * MAX_AXIS);
+	for (i = 0; i < MAX_SERVO; i++) {
+		svo[i].slave_id = i;
+		svo[i].axis_num = 1;
+	}
+	
+	for (i = 0; i < MAX_SERVO; i++) {
+		svo[i].VendorId = nxp_VendorId;
+		svo[i].ProductID = nxp_ProductID;
+	}
+
+	for (i = 0; i < MAX_SERVO; i++) {
+		ax[i].servo = svo + i;
+		ax[i].axis_offset = 0;
+	}
+}
+
+static int general_servo_setup(uint16 slave) {
+	int i;
+	int ret = 0;
+	int chk = 10;
+	struct servo_t *svo = NULL;
+	for (i = 0; i < MAX_SERVO; i++) {
+		if (servo[i].slave_id + 1 == slave) {
+			svo = &servo[i];
+			break;
+		}
+	}
+	if (svo) {
+		while (chk--) {
+			ret = servo_pdo_remap(svo);
+			if (ret)
+				break;
+		}
+	}
+
+	if (!ret)
+		return 0;
+	else
+		return -1;
+}
+
+
+static int nxp_servo_setup(uint16 slave) {
+	int i;
+	int ret = 0;
+	int chk = 10;
+	struct servo_t *svo = NULL;
+	for (i = 0; i < MAX_SERVO; i++) {
+		if (servo[i].slave_id + 1 == slave) {
+			svo = &servo[i];
+			break;
+		}
+	}
+	if (svo) {
+		while (chk--) {
+			ret = servo_pdo_activate_map(svo);
+			if (ret)
+				break;
+		}
+	}
+
+	if (!ret)
+		return 0;
+	else
+		return -1;
+}
+
+static void servo_setup(struct servo_t *servo, int servo_num) {
+	int i;
+	for (i = 0; i < servo_num; i++) {
+		if (servo[i].VendorId == nxp_VendorId && servo[i].ProductID == nxp_ProductID) {
+			servo[i].slave->PO2SOconfig = nxp_servo_setup;
+			PRINTF("\r\n nxp_servo_setup success!\r\n");
+		} else {
+			servo[i].slave->PO2SOconfig = general_servo_setup;
+		}
+
+	}
+}
+
+void irq_wake_task(void)
+{
+    BaseType_t xHigherPriorityTaskWoken;
+
+    if (rt_task)
+    {
+        xHigherPriorityTaskWoken = pdFALSE;
+        vTaskNotifyGiveFromISR(rt_task, &xHigherPriorityTaskWoken);
+        portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
+    }
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+    /* Clear interrupt flag. */
+    GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+    system_time_base.tv_usec += SOEM_PERIOD;
+
+    if (system_time_base.tv_usec >= NUM_1M)
+    {
+        system_time_base.tv_sec += system_time_base.tv_usec / NUM_1M;
+        system_time_base.tv_usec = system_time_base.tv_usec % NUM_1M;
+    }
+
+    irq_wake_task();
+
+    /* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F
+     * Store immediate overlapping
+     * exception return operation might vector to incorrect interrupt
+     */
+    SDK_ISR_EXIT_BARRIER;
+}
+
+static void osal_timer_init(uint32_t usec, uint32_t priority)
+{
+    uint32_t gptFreq;
+    gpt_config_t gptConfig;
+
+    assert(usec != 0);
+    assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+    timer_irq_period = usec;
+    GPT_GetDefaultConfig(&gptConfig);
+    GPT_Init(OSAL_TIMER, &gptConfig);
+    gptFreq = OSAL_TIMER_CLK_FREQ;
+    /* Divide GPT clock source frequency to 1MHz */
+    GPT_SetClockDivider(OSAL_TIMER, gptFreq / NUM_1M);
+    /* Set both GPT modules to 1 second duration */
+    GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, timer_irq_period);
+    /* Enable GPT Output Compare1 interrupt */
+    GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+    /* Enable at the Interrupt */
+    NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+    EnableIRQ(OSAL_TIMER_IRQ_ID);
+    GPT_StartTimer(OSAL_TIMER);
+}
+
+/* OSHW: register enet port to SOEM stack */
+static int if_port_init(void)
+{
+    struct soem_if_port soem_port;
+    memset(&if_port, 0, sizeof(if_port));
+    if_port.bufferConfig = buffConfig;
+    if_port.base         = EXAMPLE_ENET;
+    /* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+    if_port.mii_mode                   = kENET_RgmiiMode;
+#else
+    if_port.mii_mode                   = kENET_RmiiMode;
+#endif
+    if_port.phy_config.autoNeg         = true;
+    if_port.phy_config.phyAddr         = EXAMPLE_PHY_ADDRESS;
+    if_port.phy_config.resource        = EXAMPLE_PHY_RESOURCE;
+    if_port.phy_config.ops             = EXAMPLE_PHY_OPS;
+    if_port.srcClock_Hz                = EXAMPLE_CLOCK_FREQ;
+    if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+    if_port.phy_stability_delay_us     = PHY_STABILITY_DELAY_US;
+    
+    soem_port.port_init = enet_init;
+    soem_port.port_send = enet_send;
+    soem_port.port_recv = enet_recv;
+    soem_port.port_link_status = enet_link_status;
+    soem_port.port_close = enet_close;
+    strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+    strncpy(soem_port.dev_name, "enet", SOEM_DEV_NAME_MAXLEN);
+    soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+void control_task(void *ifname)
+{
+	int expectedWKC;
+	volatile int wkc;
+	int chk, i;
+    int wkc_lost = 0;
+	PRINTF("Starting motion task\r\n");
+	const TickType_t xBlockTime = pdMS_TO_TICKS(500);
+	EtherCAT_servo_init(servo, axis);
+
+	/* initialise SOEM, and if_port */
+	if (ec_init(ifname)) {
+		printf("ec_init on %s succeeded.\n",ifname);
+		/* find and auto-config slaves */
+		if ( ec_config_init(FALSE) > 0 ) {
+			printf("%d slaves found and configured.\n",ec_slavecount);
+			if (ec_slavecount < MAX_SERVO) {
+				printf("The number of Servo scanned is not consistent with configed, please reconfirm\n");
+				return;
+			}
+
+			i = servo_slave_check(servo, MAX_SERVO);
+			if (i < 0) {
+				printf("The infomation of Servo:%d is not consistent with scanned, please reconfirm\n", -i);
+				return;
+			}
+
+			ec_configdc();
+			chk = 100;
+			while (chk--) {
+				if (servo_synced_check(servo, MAX_SERVO) == 1) {
+					break;
+				}
+			}
+
+			for (i = 0; i < MAX_SERVO; i++) {
+				if(servo[i].slave->hasdc > 0) {
+				ec_dcsync0(servo[i].slave_id + 1, TRUE, CYCLE_PERIOD_NS, CYCLE_PERIOD_NS * 3);
+				}
+			}
+
+			servo_setup(servo, MAX_SERVO);	
+			ec_config_map(&IOmap);
+			for (i = 0; i < MAX_AXIS; i++) {
+				axis_nc_init(&axis[i], tp[i], CYCLE_PERIOD_NS);
+			}
+			printf("Slaves mapped, state to SAFE_OP.\n");
+			/* wait for all slaves to reach SAFE_OP state */
+			ec_statecheck(0, EC_STATE_SAFE_OP,  EC_TIMEOUTSTATE * 4);
+			for (i = 0; i < MAX_AXIS; i++) {
+				PDO_write_targe_position(&axis[i], axis[i].current_position);
+				axis_nc_start(&axis[i]);
+			}
+			printf("segments : %d : %lu %lu %lu %lu\n",ec_group[0].nsegments ,ec_group[0].IOsegment[0],ec_group[0].IOsegment[1],ec_group[0].IOsegment[2],ec_group[0].IOsegment[3]);
+
+			printf("Request operational state for all slaves\n");
+			expectedWKC = (ec_group[0].outputsWKC * 2) + ec_group[0].inputsWKC;
+			printf("Calculated workcounter %d\n", expectedWKC);
+			ec_slave[0].state = EC_STATE_OPERATIONAL;
+			/* send one valid process data to make outputs in slaves happy*/
+			ec_send_processdata();
+			ec_receive_processdata(EC_TIMEOUTRET);
+			/* request OP state for all slaves */
+			ec_writestate(0);
+			chk = 500;
+			/* wait for all slaves to reach OP state */
+			do {
+				ec_send_processdata();
+				ec_receive_processdata(EC_TIMEOUTRET);
+				ec_statecheck(1, EC_STATE_OPERATIONAL, 50000);
+			} while (chk-- && (ec_slave[0].state != EC_STATE_OPERATIONAL));
+
+			for (i = 0; i < MAX_AXIS; i++) {
+				PDO_write_targe_position(&axis[i], axis[i].current_position);
+			}
+
+			PRINTF("Request operational state for all slaves\r\n");
+			expectedWKC = (ec_group[0].outputsWKC * 2) + ec_group[0].inputsWKC;
+			PRINTF("Calculated workcounter %d\r\n", expectedWKC);
+			ec_slave[0].state = EC_STATE_OPERATIONAL;
+			/* send one valid process data to make outputs in slaves happy*/
+			ec_send_processdata();
+			ec_receive_processdata(EC_TIMEOUTRET);
+			/* request OP state for all slaves */
+			ec_writestate(0);
+			chk = 500;
+			/* wait for all slaves to reach OP state */
+			do {
+				ec_send_processdata();
+				ec_receive_processdata(EC_TIMEOUTRET);
+				ec_statecheck(1, EC_STATE_OPERATIONAL, 50000);
+			} while (chk-- && (ec_slave[0].state != EC_STATE_OPERATIONAL));
+
+			
+			if (ec_slave[0].state != EC_STATE_OPERATIONAL) {
+				PRINTF("Not all slaves reached operational state.\r\n");
+			} else {
+				PRINTF("Operational state reached for all slaves.\r\n");
+				/* send one valid process data to make outputs in slaves happy*/
+				ec_send_processdata();
+			
+				int op_num = 0;
+				while (1) {
+					/* SOEM receive data */
+					wkc = ec_receive_processdata(EC_TIMEOUTRET);
+					
+					/* servo motor application processing code */
+					for(i = 0; i < MAX_AXIS; i++) {
+						if (axis_start(&axis[i], op_mode_csp) != 1) {
+								op_num++;
+						}
+					}
+					if (op_num == 0) {
+						if(wkc >= expectedWKC) {
+							for(i = 0; i < MAX_AXIS; i++) {
+								axis[i].current_velocity = PDO_read_actual_velocity(&axis[i]);
+								axis[i].current_position = PDO_read_actual_position(&axis[i]);
+								if (axis[i].axis_status.csp_status == csp_status_running || axis[i].axis_status.csp_status == csp_status_pre_stop) {
+									int pos = axis_nc_get_next_pos(&axis[i]);
+									PDO_write_targe_position(&axis[i], pos);
+								}
+							} 
+							if (axis[MAX_AXIS-1].axis_status.csp_status == csp_status_stop) {
+								break;
+							}
+						} else {
+							wkc_lost++;
+							ec_slave[0].state = EC_STATE_OPERATIONAL;
+							ec_writestate(0);
+						}
+					} else {
+						op_num = 0;
+					}
+
+					/* SOEM tramsmit data */
+					ec_send_processdata();
+					ulTaskNotifyTake(pdFALSE, xBlockTime);
+				}
+				printf("wkc_lost = %d\r\n", wkc_lost);
+				printf("\r\nRequest init state for all slaves\r\n");
+				for(i = 1; i<=ec_slavecount ; i++) {
+					if(ec_slave[i].state != EC_STATE_OPERATIONAL) {
+						PRINTF("Slave %d State=0x%2.2x StatusCode=0x%4.4x : %s\r\n",
+						i, ec_slave[i].state, ec_slave[i].ALstatuscode, ec_ALstatuscode2string(ec_slave[i].ALstatuscode));
+					}
+				}
+
+				ec_slave[0].state = EC_STATE_INIT;
+				/* request INIT state for all slaves */
+				ec_writestate(0);
+			}
+			/* stop SOEM, close socket */
+			ec_close();
+		} else {
+			printf("No socket connection on %s\nExecute as root\r\n",ifname);
+		}
+	} else {
+		PRINTF("ec_init error\r\n");
+	}
+}
+
+/*!
+ * @brief Main function
+ */
+int main(void)
+{
+    BOARD_InitHardware();
+
+    PRINTF("Start the soem_servo_rt1180 FreeRTOS example...\r\n");
+
+    osal_timer_init(SOEM_PERIOD, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY);
+    if_port_init();
+    rt_task = xTaskCreateStatic(/* The function that implements the task. */
+                                control_task, "RT_task", RT_TASK_STACK_SIZE, SOEM_PORT_NAME, configMAX_PRIORITIES - 1,
+                                rt_task_stack, &xTaskBuffer);
+
+    vTaskStartScheduler();
+    return 0;
+}
+
-- 
2.43.0

