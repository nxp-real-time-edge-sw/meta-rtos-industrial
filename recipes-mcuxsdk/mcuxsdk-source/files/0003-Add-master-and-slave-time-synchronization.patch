From 46fc0a25d4d21be39b865f4b6b92a7ba59590519 Mon Sep 17 00:00:00 2001
From: jony zhang <jony.zhang@nxp.com>
Date: Thu, 4 Sep 2025 13:12:11 +0800
Subject: [PATCH 3/6] Add master and slave time synchronization

Signed-off-by: jony zhang <jony.zhang@nxp.com>
Upstream-Status: Pending
---
 .../soem_servo_motor_rt1180/bm/cm33/app.h     |   4 +-
 .../soem_servo_motor_rt1180/bm/cm7/app.h      |   4 +-
 .../soem_servo_motor_rt1180/bm/app.h          |   4 +-
 .../bm/cm33_core1/app.h                       |   4 +-
 .../freertos/soem_gpio_pulse.c                |   1 -
 .../soem_servo_motor_rt1180/bm/axis_nc.h      |   2 +-
 .../soem_servo_motor_rt1180/bm/readme.md      |  25 ++-
 .../bm/soem_servo_motor.c                     | 163 +++++++++++-------
 8 files changed, 139 insertions(+), 68 deletions(-)

diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/app.h b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/app.h
index f28591a63..af9f3b476 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/app.h
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/app.h
@@ -19,11 +19,12 @@
  #include "netc_ep/soem_netc_ep.h"
  /*${header:end}*/
  
+ #define MASTER_SLAVE_SYNC 1U
  #define EXAMPLE_EP_NUM    1U
  #define EXAMPLE_NETC_HAS_NO_SWITCH 1U
  #define SOEM_PORT_NAME "ENET4"
 
- #define CLOCK_GRANULARITY_NS 25UL
+ #define CLOCK_GRANULARITY_NS 5UL
  #define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
  #define CLOCK_INCREASE_PER_SEC 1000000000UL 
  
@@ -70,6 +71,7 @@
  status_t BOARD_InitHardware(void);
  status_t NETC_EP_MDIO_Init(void);
  status_t NETC_EP_PHY_Init(void);
+ uint64_t system_time64_ns(void);
  /*${prototype:end}*/
  
  #endif /* _APP_H_ */
\ No newline at end of file
diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/app.h b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/app.h
index 1f70d5404..da9033f66 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/app.h
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/app.h
@@ -19,11 +19,12 @@
  #include "netc_ep/soem_netc_ep.h"
  /*${header:end}*/
  
+ #define MASTER_SLAVE_SYNC 1U
  #define EXAMPLE_EP_NUM    1U
  #define EXAMPLE_NETC_HAS_NO_SWITCH 1U
  #define SOEM_PORT_NAME "ENET4"
  
- #define CLOCK_GRANULARITY_NS 25UL
+ #define CLOCK_GRANULARITY_NS 5UL
  #define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
  #define CLOCK_INCREASE_PER_SEC 1000000000UL 
  
@@ -70,6 +71,7 @@
  status_t BOARD_InitHardware(void);
  status_t NETC_EP_MDIO_Init(void);
  status_t NETC_EP_PHY_Init(void);
+ uint64_t system_time64_ns(void);
  /*${prototype:end}*/
  
  #endif /* _APP_H_ */
\ No newline at end of file
diff --git a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/app.h b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/app.h
index 720f1a504..91d78122a 100644
--- a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/app.h
+++ b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/app.h
@@ -15,6 +15,7 @@
 #include "netc_swt/soem_netc_swt.h"
 /*${header:end}*/
 
+#define MASTER_SLAVE_SYNC 1U
 #define SOEM_PORT_NAME "ENET0"
 #define EXAMPLE_NETC_HAS_NO_SWITCH 0U
 #define EXAMPLE_EP_NUM    0U
@@ -22,7 +23,7 @@
 #define EXAMPLE_SWT_PORT0 0x01U
 #define EXAMPLE_SWT_PORT2 0x03U
 
- #define CLOCK_GRANULARITY_NS 25UL
+ #define CLOCK_GRANULARITY_NS 5UL
  #define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
  #define CLOCK_INCREASE_PER_SEC 1000000000UL 
  
@@ -70,6 +71,7 @@
 status_t BOARD_InitHardware(void);
 status_t NETC_MDIO_Init(void);
 status_t NETC_PHY_Init(void);
+uint64_t system_time64_ns(void);
 /*${prototype:end}*/
 
 #endif /* _APP_H_ */
\ No newline at end of file
diff --git a/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/app.h b/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/app.h
index 586879afe..17ecff434 100644
--- a/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/app.h
+++ b/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/app.h
@@ -19,8 +19,9 @@
 /*${header:end}*/
 
 #define SOEM_PORT_NAME "J26"
+#define MASTER_SLAVE_SYNC 1U
 
-#define CLOCK_GRANULARITY_NS 250UL
+#define CLOCK_GRANULARITY_NS 50UL
 #define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
 #define CLOCK_INCREASE_PER_SEC 1000000000UL 
 
@@ -87,6 +88,7 @@ status_t BOARD_InitHardware(void);
 status_t NETC_EP_MDIO_Init(void);
 status_t NETC_EP_PHY_Init(void);
 status_t NETC_EP_PHY_GetLinkStatus(phy_handle_t *handler, bool *link);
+uint64_t system_time64_ns(void);
 /*${prototype:end}*/
 
 #endif /* _APP_H_ */
\ No newline at end of file
diff --git a/soem_examples/soem_gpio_pulse/freertos/soem_gpio_pulse.c b/soem_examples/soem_gpio_pulse/freertos/soem_gpio_pulse.c
index 6c1266a7e..0f2483cff 100644
--- a/soem_examples/soem_gpio_pulse/freertos/soem_gpio_pulse.c
+++ b/soem_examples/soem_gpio_pulse/freertos/soem_gpio_pulse.c
@@ -144,7 +144,6 @@ void irq_wake_task(void)
     }
 }
 
-
 void OSAL_TIMER_IRQHandler(void)
 {
     /* Clear interrupt flag. */
diff --git a/soem_examples/soem_servo_motor_rt1180/bm/axis_nc.h b/soem_examples/soem_servo_motor_rt1180/bm/axis_nc.h
index b74799748..c7fbecb1e 100644
--- a/soem_examples/soem_servo_motor_rt1180/bm/axis_nc.h
+++ b/soem_examples/soem_servo_motor_rt1180/bm/axis_nc.h
@@ -10,7 +10,7 @@
 #include <string.h>
 #include <inttypes.h>
 
-#define TRAJECTORY_PLANNER_MAX  9
+#define TRAJECTORY_PLANNER_MAX  20
 #define NSEC_PER_SEC (1000000000)
 #define timespec_add(a, b, result)                          \
     do {                                                      \
diff --git a/soem_examples/soem_servo_motor_rt1180/bm/readme.md b/soem_examples/soem_servo_motor_rt1180/bm/readme.md
index 4c4493170..bce7af89a 100644
--- a/soem_examples/soem_servo_motor_rt1180/bm/readme.md
+++ b/soem_examples/soem_servo_motor_rt1180/bm/readme.md
@@ -4,11 +4,14 @@
 This example demonstrates how to use the Simple Open EtherCAT Master (SOEM) Library to control motor.
 
 In this example there are 2 NXP EVK board:
-	SOEM as EtherCAT MainDevice running on EVK board(i.MXRT1180/i.MX943)
+
+	SOEM as EtherCAT MainDevice running on EVK board(i.MXRT1180/FRDM-1186/i.MX943)
+
 	ecat_servo_motor example as EtherCAT SubDevice running on i.MXRT1180 EVK board
+
 	Note: 
+
 		ecat_servo_motor path: .../boards/evkmimxrt1180/ecat_examples/servo_motor
-		ecat_servo_motor User Guide path: .../docs/ecatServoMotor
 
 
 ## Running the demo
@@ -17,23 +20,39 @@ If the test passes, the motor will start to retate.
 When the demo is running, the serial port will output:
 
 NETC EP frame loopback example start.
+
 Starting motion task
+
 ec_init on netc0 succeeded.
+
 ec_config_init 0
+
 ...
+
 1 slaves found and configured.
+
 ec_config_map_group IOmap:20000664 group:0
+
 >Slave 1, configadr 1001, state  2
+
 ...
+
 Slaves mapped, state to SAFE_OP.
+
 Request operational state for all slaves
+
 Calculated workcounter 3
+
 Request operational state for all slaves
+
 Calculated workcounter 3
+
 Operational state reached for all slaves.
 
 
-Note: Detailed SOEM performance please refter to EtherCAT Benchamrk.
+Note: Modify GPT timer frequncy >= 200MHz to get more accurate timer.
+
+Note: Detailed SOEM performance please refter to EtherCAT Benchamrk. 
 
 ## Supported Boards
 - [MIMXRT1180-EVK](../../../_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/example_board_readme.md)
diff --git a/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c b/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c
index 5c66cabb8..41bfaa78b 100644
--- a/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c
+++ b/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c
@@ -41,6 +41,8 @@
  * Definitions
  ******************************************************************************/
 #define CYCLE_PERIOD_NS 1000000 // 1ms
+#define CYCLE_SHIFT_NS  440000  // 440us
+#define DC_FILTER_CNT   64
 
 #define asda_b3_VendorId 0x000001dd
 #define asda_b3_ProductID 0x00006080
@@ -71,6 +73,18 @@
 /* Rx buffer memeory type. */
 typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
 
+/* dc sync time */
+static uint64_t dc_start_time_ns = 0LL;
+static uint64_t dc_time_ns = 0;
+static uint8_t  dc_started = 0;
+static int32_t  dc_diff_ns = 0;
+static int32_t  prev_dc_diff_ns = 0;
+static int64_t  dc_diff_total_ns = 0LL;
+static int64_t  dc_delta_total_ns = 0LL;
+static int      dc_filter_idx = 0;
+static int64_t  dc_adjust_ns;
+static int64_t  system_time_offset = 0LL;
+
 /*******************************************************************************
  * Variables
  ******************************************************************************/
@@ -229,55 +243,10 @@ static int nxp_servo_setup(uint16 slave) {
 		return -1;
 }
 
-static int asda_b3_servo_setup(uint16 slave) {
-	int i;
-	int ret = 0;
-	int chk = 10;
-	struct servo_t *svo = NULL;
-	for (i = 0; i < MAX_SERVO; i++) {
-		if (servo[i].slave_id + 1 == slave) {
-			svo = &servo[i];
-			break;
-		}
-	}
-	if (svo) {
-		while (chk--) {
-			ret = servo_pdo_remap(svo);
-			if (ret)
-				break;
-		}
-	}
-
-	if (!ret)
-		return 0;
-
-	int8_t  Obj60c2[9][2] = {{12, -5},{25, -5}, {37, -5}, {5, -4},{62, -5}, {75, -5},{87, -5},{1, -3}, {2, -3}};
-	int8_t num_8b[2];
-	int wkc = 0;
-	if (CYCLE_PERIOD_NS > 1000000) {
-		num_8b[0] = CYCLE_PERIOD_NS / 1000000;
-		num_8b[1] = -3;
-	} else {
-		int index = ((CYCLE_PERIOD_NS - 1) / 125000);
-		num_8b[0] = Obj60c2[index][0];
-		num_8b[1] = Obj60c2[index][1];
-	}
-	int obj_60c2_index = 0x60c2;
-	for ( i = 0; i < svo->axis_num; i++) {
-		obj_60c2_index += i * 0x800;
-		wkc += ec_SDOwrite(slave, obj_60c2_index, 0x01, 0, 1, &num_8b[0], EC_TIMEOUTSAFE);
-		wkc += ec_SDOwrite(slave, obj_60c2_index, 0x02, 0, 1, &num_8b[1], EC_TIMEOUTSAFE);
-	}
-	return wkc == svo->axis_num * 2 ? 1 : 0;
-}
-
 static void servo_setup(struct servo_t *servo, int servo_num) {
 	int i;
 	for (i = 0; i < servo_num; i++) {
-		if (servo[i].VendorId == asda_b3_VendorId && servo[i].ProductID == asda_b3_ProductID) {
-			servo[i].slave->PO2SOconfig = asda_b3_servo_setup;
-			PRINTF("\r\n delta_servo_setup success!\r\n");
-		} else if (servo[i].VendorId == nxp_VendorId && servo[i].ProductID == nxp_ProductID) {
+		if (servo[i].VendorId == nxp_VendorId && servo[i].ProductID == nxp_ProductID) {
 			servo[i].slave->PO2SOconfig = nxp_servo_setup;
 			PRINTF("\r\n nxp_servo_setup success!\r\n");
 		} else {
@@ -314,8 +283,6 @@ static void osal_timer_init(uint32_t priority)
 	GPT_GetDefaultConfig(&gptConfig);
 	GPT_Init(OSAL_TIMER, &gptConfig);
 	gptFreq = OSAL_TIMER_CLK_FREQ;
-	PRINTF("\r\nGPT freq: %d\r\n", gptFreq);
-	PRINTF("\r\nGPT divider: %d\r\n", gptFreq / CLOCK_GRANULARITY_FRE);
 	/* Divide GPT clock source frequency to 1MHz */
 	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
 	/* Set both GPT modules to 1 second duration */
@@ -356,7 +323,7 @@ static status_t ReclaimCallback(ep_handle_t *handle, uint8_t ring, netc_tx_frame
     return kStatus_Success;
 }
 
-static uint64_t gettime()
+uint64_t system_time64_ns()
 {
 	uint64_t nsec_base;
 	uint32_t cur_nsec;
@@ -369,17 +336,17 @@ static uint64_t gettime()
 		nsec_base  = system_time_ns;
 		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
 	}
-	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS;
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS - system_time_offset;
 }
 
 static void nsleep_to (uint64_t nsec_target)
 {
-	while (nsec_target > gettime());
+	while (nsec_target > system_time64_ns());
 }
 
 void osal_gettime(struct timeval *current_time)
 {
-	uint64_t nsec = gettime();
+	uint64_t nsec = system_time64_ns();
 	
 	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
 	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
@@ -635,6 +602,62 @@ void irq_wake_task(void)
     return;
 }
 
+uint64_t dc_diff_accu = 0;
+int32_t dc_diff_accu_arrary[DC_FILTER_CNT];
+int32_t dc_diff_accu_index = 0;
+void dc_diff_init(int32_t dc_diff_ns)
+{
+	int i;
+	for (i = 0; i < DC_FILTER_CNT; i++) {
+		dc_diff_accu_arrary[i] = dc_diff_ns;
+		dc_diff_accu += dc_diff_ns;
+	}
+}
+int32_t dc_diff_update(int32_t dc_diff_ns)
+{
+	dc_diff_accu += dc_diff_ns;
+	dc_diff_accu -= dc_diff_accu_arrary[dc_diff_accu_index];
+	dc_diff_accu_arrary[dc_diff_accu_index++] = dc_diff_ns;
+	if (dc_diff_accu_index >= DC_FILTER_CNT) {
+		dc_diff_accu_index = 0;
+	}
+	return dc_diff_accu / DC_FILTER_CNT;
+}
+
+#define PID_P  3 / 2
+#define PID_I  3 / 2
+#define PID_D  1 / 5 
+void update_master_clock()
+{
+	int32_t dc_diff_ns_avg;
+    // calc drift (via un-normalised time diff)
+    int32_t delta = dc_diff_ns - prev_dc_diff_ns;
+    prev_dc_diff_ns = dc_diff_ns;
+
+    if (dc_started == 2) {
+		dc_diff_ns_avg = dc_diff_update(dc_diff_ns);
+       dc_adjust_ns = dc_diff_ns * PID_P  + dc_diff_ns_avg * PID_I  + delta * PID_D;
+        if (dc_adjust_ns < -10000) {
+            dc_adjust_ns = -10000;
+        }
+        if (dc_adjust_ns > 10000) {
+            dc_adjust_ns =  10000;
+        }
+		// add cycles adjustment to time base (including a spot adjustment)
+        system_time_offset += dc_adjust_ns;
+    }
+    else {
+		if (dc_started == 0) {
+        	dc_started = (dc_diff_ns != 0);
+			system_time_offset = dc_diff_ns;
+		} else {
+			dc_started = 2;
+			dc_diff_init(dc_diff_ns);
+			system_time_offset += dc_diff_ns / 2;
+		}
+    }
+}
+
 void control_task(char *ifname)
 {
 	int expectedWKC;
@@ -680,7 +703,7 @@ void control_task(char *ifname)
 
 			for (i = 0; i < MAX_SERVO; i++) {
 				if(servo[i].slave->hasdc > 0) {
-				ec_dcsync0(servo[i].slave_id + 1, TRUE, CYCLE_PERIOD_NS, CYCLE_PERIOD_NS * 3);
+				ec_dcsync0(servo[i].slave_id + 1, TRUE, CYCLE_PERIOD_NS, CYCLE_SHIFT_NS);
 				}
 			}
 
@@ -736,20 +759,41 @@ void control_task(char *ifname)
 				ec_statecheck(1, EC_STATE_OPERATIONAL, 50000);
 			} while (chk-- && (ec_slave[0].state != EC_STATE_OPERATIONAL));
 
-			
+			int64_t last_dc_start_time_ns = 0, last_dc = 0;
+			int64_t diff_sys = 0, diff_dc = 0;
+			int l = 0;
 			if (ec_slave[0].state != EC_STATE_OPERATIONAL) {
 				PRINTF("Not all slaves reached operational state.\r\n");
 			} else {
 				PRINTF("Operational state reached for all slaves.\r\n");
-				/* send one valid process data to make outputs in slaves happy*/
-				ec_send_processdata();
+				chk = 100;
+				target_time = system_time64_ns();
+				do {
+					dc_start_time_ns = system_time64_ns();
+					ec_send_processdata();
+					if (ec_receive_processdata(EC_TIMEOUTRET) >= expectedWKC) {
+						dc_diff_ns = dc_start_time_ns - *ecx_context.DCtime;
+						update_master_clock();
+					}
+					target_time += CYCLE_PERIOD_NS;
+					nsleep_to(target_time);
+				} while (chk--);
 				
-				target_time = gettime();
+				target_time = system_time64_ns();
+				target_time += CYCLE_PERIOD_NS;
+				target_time = target_time/CYCLE_PERIOD_NS * CYCLE_PERIOD_NS;
+				nsleep_to(target_time);
+				dc_start_time_ns = system_time64_ns();
+				ec_send_processdata();
 				int op_num = 0;
 				while (1) {
 					target_time += CYCLE_PERIOD_NS;
 					/* SOEM receive data */
 					wkc = ec_receive_processdata(EC_TIMEOUTRET);
+					if (wkc >= expectedWKC) {
+						dc_diff_ns = dc_start_time_ns - *ecx_context.DCtime;
+						update_master_clock();
+					}
 
 					/* servo motor application processing code */
 					for(i = 0; i < MAX_AXIS; i++) {
@@ -778,10 +822,11 @@ void control_task(char *ifname)
 					} else {
 						op_num = 0;
 					}
+					dc_start_time_ns = system_time64_ns();
+					ec_send_processdata();
 
 					/* SOEM transmit data */
-					ec_send_processdata();
-					curr_time = gettime();
+					curr_time = system_time64_ns();
 
 					if (curr_time < target_time) {
 						nsleep_to(target_time);
-- 
2.43.0

