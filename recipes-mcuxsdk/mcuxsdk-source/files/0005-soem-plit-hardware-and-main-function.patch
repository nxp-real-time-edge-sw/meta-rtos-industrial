From 130d812937fccd33b55be392a79c674409348b69 Mon Sep 17 00:00:00 2001
From: jony zhang <jony.zhang@nxp.com>
Date: Tue, 21 Oct 2025 11:30:01 +0800
Subject: [PATCH 5/6] soem: plit hardware and main function

Signed-off-by: jony zhang <jony.zhang@nxp.com>
Upstream-Status: Pending
---
 .../soem_servo_motor/bm/cm33/app.h            |  21 +-
 .../soem_servo_motor/bm/cm33/hardware_init.c  | 213 +++++++-
 .../soem_servo_motor/bm/cm7/app.h             | 157 +++---
 .../soem_servo_motor/bm/cm7/hardware_init.c   | 213 +++++++-
 .../soem_servo_motor_rt1180/bm/cm33/app.h     |  26 +-
 .../bm/cm33/hardware_init.c                   | 262 +++++++++-
 .../soem_servo_motor_rt1180/bm/cm7/app.h      |  27 +-
 .../bm/cm7/hardware_init.c                    | 262 +++++++++-
 .../soem_examples/soem_servo_motor/bm/app.h   |  32 +-
 .../soem_servo_motor/bm/hardware_init.c       | 293 +++++++++++
 .../soem_servo_motor_rt1180/bm/app.h          |  29 +-
 .../bm/hardware_init.c                        | 350 +++++++++++++
 .../soem_servo_motor/bm/cm33_core1/app.h      |  21 +-
 .../bm/cm33_core1/hardware_init.c             | 213 +++++++-
 .../bm/cm33_core1/app.h                       |  26 +-
 .../bm/cm33_core1/hardware_init.c             | 262 +++++++++-
 .../soem_servo_motor/bm/soem_servo_motor.c    | 418 +--------------
 .../bm/soem_servo_motor.c                     | 486 +-----------------
 18 files changed, 2325 insertions(+), 986 deletions(-)

diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm33/app.h b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm33/app.h
index 0dd3a37c9..067fc8b61 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm33/app.h
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm33/app.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,6 +9,7 @@
 
 /*${header:start}*/
 #include "board.h"
+#include "fsl_gpt.h"
 #include "fsl_netc_endpoint.h"
 #include "fsl_netc_switch.h"
 #include "fsl_netc_mdio.h"
@@ -16,7 +17,20 @@
 #include "fsl_phyrtl8201.h"
 #include "fsl_msgintr.h"
 #include "fsl_rgpio.h"
+
+#include "soem_port.h"
 #include "netc_ep/soem_netc_ep.h"
+#include "netc_ep/netc_ep.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
 /*${header:end}*/
 
 #define EXAMPLE_EP_NUM    1U
@@ -67,6 +81,11 @@
  * Prototypes
  ******************************************************************************/
 /*${prototype:start}*/
+uint64_t gettime(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+void osal_timer_init(uint32_t priority);
+int if_port_init(void);
 status_t BOARD_InitHardware(void);
 status_t NETC_EP_MDIO_Init(void);
 status_t NETC_EP_PHY_Init(void);
diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm33/hardware_init.c b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm33/hardware_init.c
index 209394067..48d96a122 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm33/hardware_init.c
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm33/hardware_init.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -11,6 +11,48 @@
 #include "app.h"
 /*${header:end}*/
 
+/*******************************************************************************
+ * Variables
+ ******************************************************************************/
+ /* Rx buffer memeory type. */
+typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
+
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+extern struct netc_ep_if_port if_port;
+#endif
+
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+extern struct netc_swt_if_port if_port;
+#endif
+
+volatile uint64_t system_time_ns = 0;
+
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+/* SWT resource. */
+static swt_config_t g_swt_config;
+static swt_transfer_config_t swtTxRxConfig;
+#endif
+
+/* Buffer descriptor resource. */
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BUFF_SIZE_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+#endif
+static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
+#endif
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
+                              EP_BD_ALIGN);
+static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
+#endif
+
 struct netc_ep_if_port if_port;
 
 status_t NETC_EP_MDIO_Init(void)
@@ -43,6 +85,175 @@ static status_t NETC_EP_EMDIORead(uint8_t phyAddr, uint8_t regAddr, uint16_t *pD
     return NETC_MDIORead(&if_port.s_emdio_handle, phyAddr, regAddr, pData);
 }
 
+uint64_t gettime()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > gettime());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = gettime();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
+{
+    /* Transmit interrupt */
+    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
+        if_port.txOver = true;
+    }
+    /* Receive interrupt */
+    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
+    }
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+static netc_rx_bdr_config_t rxBdrConfig = {0};
+static netc_tx_bdr_config_t txBdrConfig = {0};
+static netc_bdr_config_t bdrConfig;
+static netc_msix_entry_t msixEntry[2];
+static ep_config_t ep_config;
+
+/* OSHW: register enet port to SOEM stack */
+int if_port_init(void)
+{
+	struct soem_if_port soem_port;
+
+    bdrConfig.rxBdrConfig = &rxBdrConfig;
+	bdrConfig.txBdrConfig = &txBdrConfig;
+    uint32_t msgAddr;
+
+    PRINTF("\r\nNETC EP frame loopback example start.\r\n");
+
+    /* MSIX and interrupt configuration. */
+    MSGINTR_Init(MSGINTR1, &msgintrCallback);
+    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR1, 0);
+    msixEntry[0].control = kNETC_MsixIntrMaskBit;
+    msixEntry[0].msgAddr = msgAddr;
+    msixEntry[0].msgData = TX_INTR_MSG_DATA;
+    msixEntry[1].control = kNETC_MsixIntrMaskBit;
+    msixEntry[1].msgAddr = msgAddr;
+    msixEntry[1].msgData = RX_INTR_MSG_DATA;
+
+    /* BD ring configuration. */
+    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
+    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
+    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
+    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
+    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
+    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
+    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
+    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
+    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
+
+    bdrConfig.txBdrConfig[0].bdArray      = &g_txBuffDescrip[0][0];
+    bdrConfig.txBdrConfig[0].len          = EP_TXBD_NUM;
+    bdrConfig.txBdrConfig[0].dirtyArray   = &g_txDirty[0][0];
+    bdrConfig.txBdrConfig[0].msixEntryIdx = TX_MSIX_ENTRY_IDX;
+    bdrConfig.txBdrConfig[0].enIntr       = true;
+
+    /* Endpoint configuration. */
+    (void)EP_GetDefaultConfig(&ep_config);
+    ep_config.si                    = KNETC_EP_CONFIG_SI;
+    ep_config.siConfig.txRingUse    = 1;
+    ep_config.siConfig.rxRingUse    = 1;
+    //ep_config.reclaimCallback       = ReclaimCallback;
+    ep_config.msixEntry             = &msixEntry[0];
+    ep_config.entryNum              = 2;
+    ep_config.port.ethMac.miiMode   = KNETC_HW_MII_MODE;
+    ep_config.port.ethMac.miiSpeed  = kNETC_MiiSpeed100M;
+    ep_config.port.ethMac.miiDuplex = kNETC_MiiFullDuplex;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    ep_config.rxCacheMaintain = true;
+    ep_config.txCacheMaintain = true;
+#endif
+    
+	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
+    {
+        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
+        {
+            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
+        }
+    }
+	if_port.ep_config = &ep_config;
+	if_port.bdrConfig = &bdrConfig;
+	if_port.g_txFrame = g_txFrame;
+	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+	strncpy(soem_port.dev_name, "netc_ep", SOEM_DEV_NAME_MAXLEN);
+	soem_port.port_init = netc_ep_init;
+	soem_port.port_send = netc_ep_send;
+	soem_port.port_recv = netc_ep_recv;
+	soem_port.port_close = netc_ep_close;
+	soem_port.port_link_status= netc_ep_link_status;
+	soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
 static status_t NETC_EP_Phy8201SetUp(phy_handle_t *handle)
 {
     status_t result;
diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm7/app.h b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm7/app.h
index c95c7c356..067fc8b61 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm7/app.h
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm7/app.h
@@ -1,75 +1,94 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
 
- #ifndef _APP_H_
- #define _APP_H_
- 
- /*${header:start}*/
- #include "board.h"
- #include "fsl_netc_endpoint.h"
- #include "fsl_netc_switch.h"
- #include "fsl_netc_mdio.h"
- #include "fsl_phyrtl8211f.h"
- #include "fsl_phyrtl8201.h"
- #include "fsl_msgintr.h"
- #include "fsl_rgpio.h"
- #include "netc_ep/soem_netc_ep.h"
- /*${header:end}*/
- 
- #define EXAMPLE_EP_NUM    1U
+#ifndef _APP_H_
+#define _APP_H_
+
+/*${header:start}*/
+#include "board.h"
+#include "fsl_gpt.h"
+#include "fsl_netc_endpoint.h"
+#include "fsl_netc_switch.h"
+#include "fsl_netc_mdio.h"
+#include "fsl_phyrtl8211f.h"
+#include "fsl_phyrtl8201.h"
+#include "fsl_msgintr.h"
+#include "fsl_rgpio.h"
+
+#include "soem_port.h"
+#include "netc_ep/soem_netc_ep.h"
+#include "netc_ep/netc_ep.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+/*${header:end}*/
+
+#define EXAMPLE_EP_NUM    1U
 #define EXAMPLE_NETC_HAS_NO_SWITCH 1U
- #define SOEM_PORT_NAME "ENET4"
-
- #define CLOCK_GRANULARITY_NS 25UL
- #define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
- #define CLOCK_INCREASE_PER_SEC 1000000000UL 
- 
- #define BOARD_LED_RGPIO     BOARD_USER_LED_GPIO
- #define BOARD_LED_RGPIO_PIN BOARD_USER_LED_GPIO_PIN
- 
- #define MSGINTR       MSGINTR1
- 
- #define KNETC_EP_CONFIG_SI    kNETC_ENETC0PSI0
- 
- #define KNETC_HW_MII_MODE     kNETC_RmiiMode
- 
- /*! @brief GPT timer will be used to calculate the system time and delay */
- #define OSAL_TIMER_IRQ_ID     GPT1_IRQn
- #define OSAL_TIMER            GPT1
- #define OSAL_TIMER_IRQHandler GPT1_IRQHandler
- #define OSAL_TIMER_CLK_FREQ   CLOCK_GetRootClockFreq(kCLOCK_Root_Gpt1)
- 
- #define PHY_PAGE_SELECT_REG 0x1FU /*!< The PHY page select register. */
- #define EP0_PORT  0x00U
- 
- #define EP0_PHY_ADDR       0x03U
- #define NETC_FREQ          CLOCK_GetRootClockFreq(kCLOCK_Root_Netc)
- 
- #define EP_RING_NUM          3U
- #define EP_RXBD_NUM          8U
- #define EP_TXBD_NUM          8U
- #define EP_BD_ALIGN          128U
- #define EP_BUFF_SIZE_ALIGN   64U
- #define EP_RXBUFF_SIZE       1518U
- #define EP_TXBUFF_SIZE       1518U
- #define EP_RXBUFF_SIZE_ALIGN SDK_SIZEALIGN(EP_RXBUFF_SIZE, EP_BUFF_SIZE_ALIGN)
- 
- #define EP_TXFRAME_NUM 20U
- #define TX_INTR_MSG_DATA  1U
- #define RX_INTR_MSG_DATA  2U
- #define TX_MSIX_ENTRY_IDX 0U
- #define RX_MSIX_ENTRY_IDX 1U
- 
- /*******************************************************************************
-  * Prototypes
-  ******************************************************************************/
- /*${prototype:start}*/
- status_t BOARD_InitHardware(void);
- status_t NETC_EP_MDIO_Init(void);
- status_t NETC_EP_PHY_Init(void);
- /*${prototype:end}*/
- 
- #endif /* _APP_H_ */
\ No newline at end of file
+#define SOEM_PORT_NAME "ENET4"
+
+#define CLOCK_GRANULARITY_NS 25UL
+#define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
+#define CLOCK_INCREASE_PER_SEC 1000000000UL 
+
+#define BOARD_LED_RGPIO     BOARD_USER_LED_GPIO
+#define BOARD_LED_RGPIO_PIN BOARD_USER_LED_GPIO_PIN
+
+#define MSGINTR       MSGINTR1
+
+#define KNETC_EP_CONFIG_SI    kNETC_ENETC0PSI0
+
+#define KNETC_HW_MII_MODE     kNETC_RmiiMode
+
+/*! @brief GPT timer will be used to calculate the system time and delay */
+#define OSAL_TIMER_IRQ_ID     GPT1_IRQn
+#define OSAL_TIMER            GPT1
+#define OSAL_TIMER_IRQHandler GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ   CLOCK_GetRootClockFreq(kCLOCK_Root_Gpt1)
+
+#define PHY_PAGE_SELECT_REG 0x1FU /*!< The PHY page select register. */
+#define EP0_PORT  0x00U
+
+#define EP0_PHY_ADDR       0x03U
+#define NETC_FREQ          CLOCK_GetRootClockFreq(kCLOCK_Root_Netc)
+
+#define EP_RING_NUM          3U
+#define EP_RXBD_NUM          8U
+#define EP_TXBD_NUM          8U
+#define EP_BD_ALIGN          128U
+#define EP_BUFF_SIZE_ALIGN   64U
+#define EP_RXBUFF_SIZE       1518U
+#define EP_TXBUFF_SIZE       1518U
+#define EP_RXBUFF_SIZE_ALIGN SDK_SIZEALIGN(EP_RXBUFF_SIZE, EP_BUFF_SIZE_ALIGN)
+
+#define EP_TXFRAME_NUM 20U
+#define TX_INTR_MSG_DATA  1U
+#define RX_INTR_MSG_DATA  2U
+#define TX_MSIX_ENTRY_IDX 0U
+#define RX_MSIX_ENTRY_IDX 1U
+
+/*******************************************************************************
+ * Prototypes
+ ******************************************************************************/
+/*${prototype:start}*/
+uint64_t gettime(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+void osal_timer_init(uint32_t priority);
+int if_port_init(void);
+status_t BOARD_InitHardware(void);
+status_t NETC_EP_MDIO_Init(void);
+status_t NETC_EP_PHY_Init(void);
+/*${prototype:end}*/
+
+#endif /* _APP_H_ */
\ No newline at end of file
diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm7/hardware_init.c b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm7/hardware_init.c
index 209394067..48d96a122 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm7/hardware_init.c
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor/bm/cm7/hardware_init.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -11,6 +11,48 @@
 #include "app.h"
 /*${header:end}*/
 
+/*******************************************************************************
+ * Variables
+ ******************************************************************************/
+ /* Rx buffer memeory type. */
+typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
+
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+extern struct netc_ep_if_port if_port;
+#endif
+
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+extern struct netc_swt_if_port if_port;
+#endif
+
+volatile uint64_t system_time_ns = 0;
+
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+/* SWT resource. */
+static swt_config_t g_swt_config;
+static swt_transfer_config_t swtTxRxConfig;
+#endif
+
+/* Buffer descriptor resource. */
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BUFF_SIZE_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+#endif
+static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
+#endif
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
+                              EP_BD_ALIGN);
+static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
+#endif
+
 struct netc_ep_if_port if_port;
 
 status_t NETC_EP_MDIO_Init(void)
@@ -43,6 +85,175 @@ static status_t NETC_EP_EMDIORead(uint8_t phyAddr, uint8_t regAddr, uint16_t *pD
     return NETC_MDIORead(&if_port.s_emdio_handle, phyAddr, regAddr, pData);
 }
 
+uint64_t gettime()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > gettime());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = gettime();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
+{
+    /* Transmit interrupt */
+    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
+        if_port.txOver = true;
+    }
+    /* Receive interrupt */
+    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
+    }
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+static netc_rx_bdr_config_t rxBdrConfig = {0};
+static netc_tx_bdr_config_t txBdrConfig = {0};
+static netc_bdr_config_t bdrConfig;
+static netc_msix_entry_t msixEntry[2];
+static ep_config_t ep_config;
+
+/* OSHW: register enet port to SOEM stack */
+int if_port_init(void)
+{
+	struct soem_if_port soem_port;
+
+    bdrConfig.rxBdrConfig = &rxBdrConfig;
+	bdrConfig.txBdrConfig = &txBdrConfig;
+    uint32_t msgAddr;
+
+    PRINTF("\r\nNETC EP frame loopback example start.\r\n");
+
+    /* MSIX and interrupt configuration. */
+    MSGINTR_Init(MSGINTR1, &msgintrCallback);
+    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR1, 0);
+    msixEntry[0].control = kNETC_MsixIntrMaskBit;
+    msixEntry[0].msgAddr = msgAddr;
+    msixEntry[0].msgData = TX_INTR_MSG_DATA;
+    msixEntry[1].control = kNETC_MsixIntrMaskBit;
+    msixEntry[1].msgAddr = msgAddr;
+    msixEntry[1].msgData = RX_INTR_MSG_DATA;
+
+    /* BD ring configuration. */
+    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
+    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
+    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
+    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
+    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
+    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
+    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
+    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
+    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
+
+    bdrConfig.txBdrConfig[0].bdArray      = &g_txBuffDescrip[0][0];
+    bdrConfig.txBdrConfig[0].len          = EP_TXBD_NUM;
+    bdrConfig.txBdrConfig[0].dirtyArray   = &g_txDirty[0][0];
+    bdrConfig.txBdrConfig[0].msixEntryIdx = TX_MSIX_ENTRY_IDX;
+    bdrConfig.txBdrConfig[0].enIntr       = true;
+
+    /* Endpoint configuration. */
+    (void)EP_GetDefaultConfig(&ep_config);
+    ep_config.si                    = KNETC_EP_CONFIG_SI;
+    ep_config.siConfig.txRingUse    = 1;
+    ep_config.siConfig.rxRingUse    = 1;
+    //ep_config.reclaimCallback       = ReclaimCallback;
+    ep_config.msixEntry             = &msixEntry[0];
+    ep_config.entryNum              = 2;
+    ep_config.port.ethMac.miiMode   = KNETC_HW_MII_MODE;
+    ep_config.port.ethMac.miiSpeed  = kNETC_MiiSpeed100M;
+    ep_config.port.ethMac.miiDuplex = kNETC_MiiFullDuplex;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    ep_config.rxCacheMaintain = true;
+    ep_config.txCacheMaintain = true;
+#endif
+    
+	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
+    {
+        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
+        {
+            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
+        }
+    }
+	if_port.ep_config = &ep_config;
+	if_port.bdrConfig = &bdrConfig;
+	if_port.g_txFrame = g_txFrame;
+	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+	strncpy(soem_port.dev_name, "netc_ep", SOEM_DEV_NAME_MAXLEN);
+	soem_port.port_init = netc_ep_init;
+	soem_port.port_send = netc_ep_send;
+	soem_port.port_recv = netc_ep_recv;
+	soem_port.port_close = netc_ep_close;
+	soem_port.port_link_status= netc_ep_link_status;
+	soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
 static status_t NETC_EP_Phy8201SetUp(phy_handle_t *handle)
 {
     status_t result;
diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/app.h b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/app.h
index af9f3b476..b704b0818 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/app.h
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/app.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,6 +9,7 @@
  
  /*${header:start}*/
  #include "board.h"
+ #include "fsl_gpt.h"
  #include "fsl_netc_endpoint.h"
  #include "fsl_netc_switch.h"
  #include "fsl_netc_mdio.h"
@@ -16,9 +17,25 @@
  #include "fsl_phyrtl8201.h"
  #include "fsl_msgintr.h"
  #include "fsl_rgpio.h"
+
  #include "netc_ep/soem_netc_ep.h"
+ #include "netc_ep/netc_ep.h"
+ #include "soem_port.h"
+
+ #include "ethercattype.h"
+ #include "nicdrv.h"
+ #include "ethercatbase.h"
+ #include "ethercatmain.h"
+ #include "ethercatdc.h"
+ #include "ethercatcoe.h"
+ #include "ethercatfoe.h"
+ #include "ethercatconfig.h"
+ #include "ethercatprint.h"
  /*${header:end}*/
  
+ #define CYCLE_SHIFT_NS  440000  // 440us
+ #define DC_FILTER_CNT   64
+
  #define MASTER_SLAVE_SYNC 1U
  #define EXAMPLE_EP_NUM    1U
  #define EXAMPLE_NETC_HAS_NO_SWITCH 1U
@@ -68,10 +85,15 @@
   * Prototypes
   ******************************************************************************/
  /*${prototype:start}*/
+ void osal_timer_init(uint32_t priority);
+ uint64_t system_time64_ns(void);
+ void nsleep_to (uint64_t nsec_target);
+ void osal_gettime(struct timeval *current_time);
+ int if_port_init(void);
+ void update_master_clock(void);
  status_t BOARD_InitHardware(void);
  status_t NETC_EP_MDIO_Init(void);
  status_t NETC_EP_PHY_Init(void);
- uint64_t system_time64_ns(void);
  /*${prototype:end}*/
  
  #endif /* _APP_H_ */
\ No newline at end of file
diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/hardware_init.c b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/hardware_init.c
index 209394067..914237e54 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/hardware_init.c
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm33/hardware_init.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,10 +9,270 @@
 #include "clock_config.h"
 #include "board.h"
 #include "app.h"
+
 /*${header:end}*/
 
+/* Rx buffer memeory type. */
+typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
+
+/* dc sync time */
+uint8_t  dc_started = 0;
+int32_t  dc_diff_ns = 0;
+int32_t  prev_dc_diff_ns = 0;
+int64_t  dc_adjust_ns;
+int64_t  system_time_offset = 0LL;
+
 struct netc_ep_if_port if_port;
 
+volatile uint64_t system_time_ns = 0;
+
+/* Buffer descriptor resource. */
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BUFF_SIZE_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+#endif
+static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
+#endif
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
+                              EP_BD_ALIGN);
+static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
+#endif
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
+{
+    /* Transmit interrupt */
+    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
+        if_port.txOver = true;
+    }
+    /* Receive interrupt */
+    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
+    }
+}
+
+uint64_t system_time64_ns()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS - system_time_offset;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > system_time64_ns());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = system_time64_ns();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+static netc_rx_bdr_config_t rxBdrConfig = {0};
+static netc_tx_bdr_config_t txBdrConfig = {0};
+static netc_bdr_config_t bdrConfig;
+static netc_msix_entry_t msixEntry[2];
+static ep_config_t ep_config;
+
+/* OSHW: register enet port to SOEM stack */
+int if_port_init(void)
+{
+	struct soem_if_port soem_port;
+
+    bdrConfig.rxBdrConfig = &rxBdrConfig;
+	bdrConfig.txBdrConfig = &txBdrConfig;
+    uint32_t msgAddr;
+
+    PRINTF("\r\nNETC EP frame loopback example start.\r\n");
+
+    /* MSIX and interrupt configuration. */
+    MSGINTR_Init(MSGINTR1, &msgintrCallback);
+    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR1, 0);
+    msixEntry[0].control = kNETC_MsixIntrMaskBit;
+    msixEntry[0].msgAddr = msgAddr;
+    msixEntry[0].msgData = TX_INTR_MSG_DATA;
+    msixEntry[1].control = kNETC_MsixIntrMaskBit;
+    msixEntry[1].msgAddr = msgAddr;
+    msixEntry[1].msgData = RX_INTR_MSG_DATA;
+
+    /* BD ring configuration. */
+    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
+    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
+    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
+    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
+    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
+    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
+    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
+    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
+    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
+
+    bdrConfig.txBdrConfig[0].bdArray      = &g_txBuffDescrip[0][0];
+    bdrConfig.txBdrConfig[0].len          = EP_TXBD_NUM;
+    bdrConfig.txBdrConfig[0].dirtyArray   = &g_txDirty[0][0];
+    bdrConfig.txBdrConfig[0].msixEntryIdx = TX_MSIX_ENTRY_IDX;
+    bdrConfig.txBdrConfig[0].enIntr       = true;
+
+    /* Endpoint configuration. */
+    (void)EP_GetDefaultConfig(&ep_config);
+    ep_config.si                    = KNETC_EP_CONFIG_SI;
+    ep_config.siConfig.txRingUse    = 1;
+    ep_config.siConfig.rxRingUse    = 1;
+    //ep_config.reclaimCallback       = ReclaimCallback;
+    ep_config.msixEntry             = &msixEntry[0];
+    ep_config.entryNum              = 2;
+    ep_config.port.ethMac.miiMode   = KNETC_HW_MII_MODE;
+    ep_config.port.ethMac.miiSpeed  = kNETC_MiiSpeed100M;
+    ep_config.port.ethMac.miiDuplex = kNETC_MiiFullDuplex;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    ep_config.rxCacheMaintain = true;
+    ep_config.txCacheMaintain = true;
+#endif
+    
+	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
+    {
+        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
+        {
+            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
+        }
+    }
+	if_port.ep_config = &ep_config;
+	if_port.bdrConfig = &bdrConfig;
+	if_port.g_txFrame = g_txFrame;
+	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+	strncpy(soem_port.dev_name, "netc_ep", SOEM_DEV_NAME_MAXLEN);
+	soem_port.port_init = netc_ep_init;
+	soem_port.port_send = netc_ep_send;
+	soem_port.port_recv = netc_ep_recv;
+	soem_port.port_close = netc_ep_close;
+	soem_port.port_link_status= netc_ep_link_status;
+	soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+uint64_t dc_diff_accu = 0;
+int32_t dc_diff_accu_arrary[DC_FILTER_CNT];
+int32_t dc_diff_accu_index = 0;
+
+static void dc_diff_init(int32_t dc_diff_ns)
+{
+	int i;
+	for (i = 0; i < DC_FILTER_CNT; i++) {
+		dc_diff_accu_arrary[i] = dc_diff_ns;
+		dc_diff_accu += dc_diff_ns;
+	}
+}
+
+static int32_t dc_diff_update(int32_t dc_diff_ns)
+{
+	dc_diff_accu += dc_diff_ns;
+	dc_diff_accu -= dc_diff_accu_arrary[dc_diff_accu_index];
+	dc_diff_accu_arrary[dc_diff_accu_index++] = dc_diff_ns;
+	if (dc_diff_accu_index >= DC_FILTER_CNT) {
+		dc_diff_accu_index = 0;
+	}
+	return dc_diff_accu / DC_FILTER_CNT;
+}
+
+#define PID_P  3 / 2
+#define PID_I  3 / 2
+#define PID_D  1 / 5 
+void update_master_clock()
+{
+	int32_t dc_diff_ns_avg;
+    // calc drift (via un-normalised time diff)
+    int32_t delta = dc_diff_ns - prev_dc_diff_ns;
+    prev_dc_diff_ns = dc_diff_ns;
+
+    if (dc_started == 2) {
+		dc_diff_ns_avg = dc_diff_update(dc_diff_ns);
+       dc_adjust_ns = dc_diff_ns * PID_P  + dc_diff_ns_avg * PID_I  + delta * PID_D;
+        if (dc_adjust_ns < -10000) {
+            dc_adjust_ns = -10000;
+        }
+        if (dc_adjust_ns > 10000) {
+            dc_adjust_ns =  10000;
+        }
+		// add cycles adjustment to time base (including a spot adjustment)
+        system_time_offset += dc_adjust_ns;
+    }
+    else {
+		if (dc_started == 0) {
+        	dc_started = (dc_diff_ns != 0);
+			system_time_offset = dc_diff_ns;
+		} else {
+			dc_started = 2;
+			dc_diff_init(dc_diff_ns);
+			system_time_offset += dc_diff_ns / 2;
+		}
+    }
+}
+
 status_t NETC_EP_MDIO_Init(void)
 {
     status_t result = kStatus_Success;
diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/app.h b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/app.h
index da9033f66..b5f0dfde9 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/app.h
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/app.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,6 +9,7 @@
  
  /*${header:start}*/
  #include "board.h"
+ #include "fsl_gpt.h"
  #include "fsl_netc_endpoint.h"
  #include "fsl_netc_switch.h"
  #include "fsl_netc_mdio.h"
@@ -16,14 +17,30 @@
  #include "fsl_phyrtl8201.h"
  #include "fsl_msgintr.h"
  #include "fsl_rgpio.h"
+
  #include "netc_ep/soem_netc_ep.h"
+ #include "netc_ep/netc_ep.h"
+ #include "soem_port.h"
+
+ #include "ethercattype.h"
+ #include "nicdrv.h"
+ #include "ethercatbase.h"
+ #include "ethercatmain.h"
+ #include "ethercatdc.h"
+ #include "ethercatcoe.h"
+ #include "ethercatfoe.h"
+ #include "ethercatconfig.h"
+ #include "ethercatprint.h"
  /*${header:end}*/
  
+ #define CYCLE_SHIFT_NS  440000  // 440us
+ #define DC_FILTER_CNT   64
+
  #define MASTER_SLAVE_SYNC 1U
  #define EXAMPLE_EP_NUM    1U
  #define EXAMPLE_NETC_HAS_NO_SWITCH 1U
  #define SOEM_PORT_NAME "ENET4"
- 
+
  #define CLOCK_GRANULARITY_NS 5UL
  #define CLOCK_GRANULARITY_FRE (1000000000UL/CLOCK_GRANULARITY_NS)
  #define CLOCK_INCREASE_PER_SEC 1000000000UL 
@@ -68,6 +85,12 @@
   * Prototypes
   ******************************************************************************/
  /*${prototype:start}*/
+ void osal_timer_init(uint32_t priority);
+ uint64_t system_time64_ns(void);
+ void nsleep_to (uint64_t nsec_target);
+ void osal_gettime(struct timeval *current_time);
+ int if_port_init(void);
+ void update_master_clock(void);
  status_t BOARD_InitHardware(void);
  status_t NETC_EP_MDIO_Init(void);
  status_t NETC_EP_PHY_Init(void);
diff --git a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/hardware_init.c b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/hardware_init.c
index 209394067..914237e54 100644
--- a/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/hardware_init.c
+++ b/_boards/evkmimxrt1180/soem_examples/soem_servo_motor_rt1180/bm/cm7/hardware_init.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -9,10 +9,270 @@
 #include "clock_config.h"
 #include "board.h"
 #include "app.h"
+
 /*${header:end}*/
 
+/* Rx buffer memeory type. */
+typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
+
+/* dc sync time */
+uint8_t  dc_started = 0;
+int32_t  dc_diff_ns = 0;
+int32_t  prev_dc_diff_ns = 0;
+int64_t  dc_adjust_ns;
+int64_t  system_time_offset = 0LL;
+
 struct netc_ep_if_port if_port;
 
+volatile uint64_t system_time_ns = 0;
+
+/* Buffer descriptor resource. */
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BUFF_SIZE_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+#endif
+static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
+#endif
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
+                              EP_BD_ALIGN);
+static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
+#endif
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
+{
+    /* Transmit interrupt */
+    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
+        if_port.txOver = true;
+    }
+    /* Receive interrupt */
+    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
+    }
+}
+
+uint64_t system_time64_ns()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS - system_time_offset;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > system_time64_ns());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = system_time64_ns();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+static netc_rx_bdr_config_t rxBdrConfig = {0};
+static netc_tx_bdr_config_t txBdrConfig = {0};
+static netc_bdr_config_t bdrConfig;
+static netc_msix_entry_t msixEntry[2];
+static ep_config_t ep_config;
+
+/* OSHW: register enet port to SOEM stack */
+int if_port_init(void)
+{
+	struct soem_if_port soem_port;
+
+    bdrConfig.rxBdrConfig = &rxBdrConfig;
+	bdrConfig.txBdrConfig = &txBdrConfig;
+    uint32_t msgAddr;
+
+    PRINTF("\r\nNETC EP frame loopback example start.\r\n");
+
+    /* MSIX and interrupt configuration. */
+    MSGINTR_Init(MSGINTR1, &msgintrCallback);
+    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR1, 0);
+    msixEntry[0].control = kNETC_MsixIntrMaskBit;
+    msixEntry[0].msgAddr = msgAddr;
+    msixEntry[0].msgData = TX_INTR_MSG_DATA;
+    msixEntry[1].control = kNETC_MsixIntrMaskBit;
+    msixEntry[1].msgAddr = msgAddr;
+    msixEntry[1].msgData = RX_INTR_MSG_DATA;
+
+    /* BD ring configuration. */
+    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
+    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
+    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
+    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
+    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
+    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
+    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
+    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
+    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
+
+    bdrConfig.txBdrConfig[0].bdArray      = &g_txBuffDescrip[0][0];
+    bdrConfig.txBdrConfig[0].len          = EP_TXBD_NUM;
+    bdrConfig.txBdrConfig[0].dirtyArray   = &g_txDirty[0][0];
+    bdrConfig.txBdrConfig[0].msixEntryIdx = TX_MSIX_ENTRY_IDX;
+    bdrConfig.txBdrConfig[0].enIntr       = true;
+
+    /* Endpoint configuration. */
+    (void)EP_GetDefaultConfig(&ep_config);
+    ep_config.si                    = KNETC_EP_CONFIG_SI;
+    ep_config.siConfig.txRingUse    = 1;
+    ep_config.siConfig.rxRingUse    = 1;
+    //ep_config.reclaimCallback       = ReclaimCallback;
+    ep_config.msixEntry             = &msixEntry[0];
+    ep_config.entryNum              = 2;
+    ep_config.port.ethMac.miiMode   = KNETC_HW_MII_MODE;
+    ep_config.port.ethMac.miiSpeed  = kNETC_MiiSpeed100M;
+    ep_config.port.ethMac.miiDuplex = kNETC_MiiFullDuplex;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    ep_config.rxCacheMaintain = true;
+    ep_config.txCacheMaintain = true;
+#endif
+    
+	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
+    {
+        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
+        {
+            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
+        }
+    }
+	if_port.ep_config = &ep_config;
+	if_port.bdrConfig = &bdrConfig;
+	if_port.g_txFrame = g_txFrame;
+	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+	strncpy(soem_port.dev_name, "netc_ep", SOEM_DEV_NAME_MAXLEN);
+	soem_port.port_init = netc_ep_init;
+	soem_port.port_send = netc_ep_send;
+	soem_port.port_recv = netc_ep_recv;
+	soem_port.port_close = netc_ep_close;
+	soem_port.port_link_status= netc_ep_link_status;
+	soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+uint64_t dc_diff_accu = 0;
+int32_t dc_diff_accu_arrary[DC_FILTER_CNT];
+int32_t dc_diff_accu_index = 0;
+
+static void dc_diff_init(int32_t dc_diff_ns)
+{
+	int i;
+	for (i = 0; i < DC_FILTER_CNT; i++) {
+		dc_diff_accu_arrary[i] = dc_diff_ns;
+		dc_diff_accu += dc_diff_ns;
+	}
+}
+
+static int32_t dc_diff_update(int32_t dc_diff_ns)
+{
+	dc_diff_accu += dc_diff_ns;
+	dc_diff_accu -= dc_diff_accu_arrary[dc_diff_accu_index];
+	dc_diff_accu_arrary[dc_diff_accu_index++] = dc_diff_ns;
+	if (dc_diff_accu_index >= DC_FILTER_CNT) {
+		dc_diff_accu_index = 0;
+	}
+	return dc_diff_accu / DC_FILTER_CNT;
+}
+
+#define PID_P  3 / 2
+#define PID_I  3 / 2
+#define PID_D  1 / 5 
+void update_master_clock()
+{
+	int32_t dc_diff_ns_avg;
+    // calc drift (via un-normalised time diff)
+    int32_t delta = dc_diff_ns - prev_dc_diff_ns;
+    prev_dc_diff_ns = dc_diff_ns;
+
+    if (dc_started == 2) {
+		dc_diff_ns_avg = dc_diff_update(dc_diff_ns);
+       dc_adjust_ns = dc_diff_ns * PID_P  + dc_diff_ns_avg * PID_I  + delta * PID_D;
+        if (dc_adjust_ns < -10000) {
+            dc_adjust_ns = -10000;
+        }
+        if (dc_adjust_ns > 10000) {
+            dc_adjust_ns =  10000;
+        }
+		// add cycles adjustment to time base (including a spot adjustment)
+        system_time_offset += dc_adjust_ns;
+    }
+    else {
+		if (dc_started == 0) {
+        	dc_started = (dc_diff_ns != 0);
+			system_time_offset = dc_diff_ns;
+		} else {
+			dc_started = 2;
+			dc_diff_init(dc_diff_ns);
+			system_time_offset += dc_diff_ns / 2;
+		}
+    }
+}
+
 status_t NETC_EP_MDIO_Init(void)
 {
     status_t result = kStatus_Success;
diff --git a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor/bm/app.h b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor/bm/app.h
index 720f1a504..cd3968175 100644
--- a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor/bm/app.h
+++ b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor/bm/app.h
@@ -7,14 +7,32 @@
 #define _APP_H_
 
 /*${header:start}*/
+#include "fsl_gpt.h"
 #include "fsl_netc_endpoint.h"
 #include "fsl_netc_switch.h"
 #include "fsl_netc_mdio.h"
 #include "fsl_phyyt8521.h"
 #include "fsl_msgintr.h"
+
+#include "soem_port.h"
 #include "netc_swt/soem_netc_swt.h"
+#include "netc_swt/netc_swt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
 /*${header:end}*/
 
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (500000U)
+#endif
+
 #define SOEM_PORT_NAME "ENET0"
 #define EXAMPLE_NETC_HAS_NO_SWITCH 0U
 #define EXAMPLE_EP_NUM    0U
@@ -29,7 +47,13 @@
  #define BOARD_LED_RGPIO     BOARD_USER_LED_GPIO
  #define BOARD_LED_RGPIO_PIN BOARD_USER_LED_GPIO_PIN
 
-#define KNETC_EP_CONFIG_SI    kNETC_ENETC1PSI0
+#ifndef EXAMPLE_SWT_SI
+#define EXAMPLE_SWT_SI kNETC_ENETC1PSI0
+#endif
+/* Switch pseudo port */
+#ifndef EXAMPLE_SWT_PSEUDO_PORT
+#define EXAMPLE_SWT_PSEUDO_PORT 0x4U
+#endif
 
 #define NETC_FREQ             CLOCK_GetRootClockFreq(kCLOCK_Root_Netc)
 
@@ -67,6 +91,12 @@
  * Prototypes
  ******************************************************************************/
 /*${prototype:start}*/
+uint64_t gettime(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+void osal_timer_init(uint32_t priority);
+status_t APP_SWT_AddTableEntry(void);
+int if_port_swt_init(void);
 status_t BOARD_InitHardware(void);
 status_t NETC_MDIO_Init(void);
 status_t NETC_PHY_Init(void);
diff --git a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor/bm/hardware_init.c b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor/bm/hardware_init.c
index 1bd8faf33..d919a3399 100644
--- a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor/bm/hardware_init.c
+++ b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor/bm/hardware_init.c
@@ -23,6 +23,45 @@
 /*${macro:end}*/
 
 /*${variable:start}*/
+/* Rx buffer memeory type. */
+typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
+
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+extern struct netc_ep_if_port if_port;
+#endif
+
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+extern struct netc_swt_if_port if_port;
+#endif
+
+volatile uint64_t system_time_ns = 0;
+
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+/* SWT resource. */
+static swt_config_t g_swt_config;
+static swt_transfer_config_t swtTxRxConfig;
+#endif
+
+/* Buffer descriptor resource. */
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BUFF_SIZE_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+#endif
+static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
+#endif
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
+                              EP_BD_ALIGN);
+static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
+#endif
+
 /* PHY operation. */
 struct netc_swt_if_port if_port;
 static phy_yt8521_resource_t s_phy_resource[5];
@@ -58,6 +97,260 @@ static status_t NETC_EP_EMDIORead(uint8_t phyAddr, uint8_t regAddr, uint16_t *pD
     return NETC_MDIORead(&if_port.s_emdio_handle, phyAddr, regAddr, pData);
 }
 
+uint64_t gettime()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > gettime());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = gettime();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
+{
+    /* Transmit interrupt */
+    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
+        if_port.txOver = true;
+    }
+    /* Receive interrupt */
+    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
+    }
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+static netc_rx_bdr_config_t rxBdrConfig = {0};
+static netc_tx_bdr_config_t txBdrConfig = {0};
+static netc_bdr_config_t bdrConfig;
+static netc_msix_entry_t msixEntry[2];
+static ep_config_t ep_config;
+
+static status_t APP_SwtReclaimCallback(swt_handle_t *handle, netc_tx_frame_info_t *frameInfo, void *userData)
+{
+    return kStatus_Success;
+}
+
+status_t APP_SWT_AddTableEntry()
+{
+    status_t result = kStatus_Success;
+    uint32_t entryID;
+
+#if defined(EXAMPLE_SWT_USE_IPF) && EXAMPLE_SWT_USE_IPF
+    netc_tb_ipf_config_t ipfEntryCfg;
+
+    memset(&ipfEntryCfg, 0U, sizeof(netc_tb_ipf_config_t));
+    ipfEntryCfg.keye.srcPortMask = EXAMPLE_SWT_USED_PORT_BITMAP;
+    ipfEntryCfg.cfge.hr          = kNETC_SoftwareDefHR0;
+    ipfEntryCfg.cfge.fltfa       = kNETC_IPFRedirectToMgmtPort;
+
+    /* Frame from used port redirect to management port. */
+    for (uint32_t i = 0; i < EXAMPLE_SWT_MAX_PORT_NUM; i++)
+    {
+        /* Only check the enabled port. */
+        if (((1U << i) & EXAMPLE_SWT_USED_PORT_BITMAP) == 0U)
+        {
+            continue;
+        }
+
+        ipfEntryCfg.keye.srcPort = i;
+        result                   = SWT_RxIPFAddTableEntry(&if_port.g_swt_handle, &ipfEntryCfg, &entryID);
+        if ((kStatus_Success != result) && (entryID != 0xFFFFFFFF))
+        {
+            PRINTF("\r\n%s: %d, Failed to add IPF table!, result = %u\r\n, entryID = %u", __func__, __LINE__, result,
+                   entryID);
+            return kStatus_Fail;
+        }
+    }
+#else
+    /* Set FDB table, input frame only forwards to pseudo MAC port. */
+    netc_tb_fdb_config_t fdbEntryCfg = {
+        .keye.fid = FRAME_FID, .cfge.portBitmap = (1U << EXAMPLE_SWT_PSEUDO_PORT), .cfge.dynamic = 1};
+    memset(&fdbEntryCfg.keye.macAddr[0], 0xFF, 6U);
+    result = SWT_BridgeAddFDBTableEntry(&if_port.g_swt_handle, &fdbEntryCfg, &entryID);
+    if ((kStatus_Success != result) || (0xFFFFFFFFU == entryID))
+    {
+        PRINTF("\r\n%s: %d, Failed to add FDB table!, result = %d, entryID = %d\r\n", __func__, __LINE__, result,
+               entryID);
+        return kStatus_Fail;
+    }
+#endif
+
+    return result;
+}
+
+int if_port_swt_init(void)
+{
+	struct soem_if_port soem_port;
+    bdrConfig.rxBdrConfig = &rxBdrConfig;
+	bdrConfig.txBdrConfig = &txBdrConfig;
+    uint32_t msgAddr;
+
+    PRINTF("\r\nNETC swtich frame loopback example start.\r\n");
+
+    /* MSIX and interrupt configuration. */
+    MSGINTR_Init(MSGINTR, &msgintrCallback);
+    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR, 0);
+    msixEntry[0].control = kNETC_MsixIntrMaskBit;
+    msixEntry[0].msgAddr = msgAddr;
+    msixEntry[0].msgData = TX_INTR_MSG_DATA;
+    msixEntry[1].control = kNETC_MsixIntrMaskBit;
+    msixEntry[1].msgAddr = msgAddr;
+    msixEntry[1].msgData = RX_INTR_MSG_DATA;
+
+    /* BD ring configuration. */
+    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
+    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
+    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
+    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
+    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
+    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
+    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
+    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
+    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
+
+    /* Endpoint configuration. */
+    (void)EP_GetDefaultConfig(&ep_config);
+    ep_config.si                    = EXAMPLE_SWT_SI;
+    ep_config.siConfig.txRingUse    = 1;
+    ep_config.siConfig.rxRingUse    = 1;
+    //ep_config.reclaimCallback       = ReclaimCallback;
+    ep_config.msixEntry             = &msixEntry[0];
+    ep_config.entryNum              = 2;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    ep_config.rxCacheMaintain = true;
+    ep_config.txCacheMaintain = true;
+#endif
+
+    SWT_GetDefaultConfig(&g_swt_config);
+
+    for (int i = 0; i < EXAMPLE_SWT_MAX_PORT_NUM; i++)
+    {
+        g_swt_config.ports[i].ethMac.miiMode   = KNETC_HW_MII_MODE;
+        g_swt_config.ports[i].ethMac.miiSpeed  = kNETC_MiiSpeed100M;
+        g_swt_config.ports[i].ethMac.miiDuplex = kNETC_MiiFullDuplex;
+    }
+
+    /* Wait a moment for PHY status to be stable. */
+    SDK_DelayAtLeastUs(PHY_STABILITY_DELAY_US, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    g_swt_config.bridgeCfg.dVFCfg.portMembership = (1U << EXAMPLE_SWT_PSEUDO_PORT) | EXAMPLE_SWT_USED_PORT_BITMAP;
+#if defined(EXAMPLE_SWT_USE_IPF) && EXAMPLE_SWT_USE_IPF
+    g_swt_config.ports[0].commonCfg.ipfCfg.enIPFTable = true;
+    g_swt_config.ports[2].commonCfg.ipfCfg.enIPFTable = true;
+#else
+    g_swt_config.bridgeCfg.dVFCfg.enUseFilterID = true;
+    g_swt_config.bridgeCfg.dVFCfg.filterID      = FRAME_FID;
+    g_swt_config.bridgeCfg.dVFCfg.mfo           = kNETC_FDBLookUpWithDiscard;
+    g_swt_config.bridgeCfg.dVFCfg.mlo           = kNETC_DisableMACLearn;
+#endif
+
+    g_swt_config.cmdRingUse            = 1U;
+    g_swt_config.cmdBdrCfg[0].bdBase   = &g_cmdBuffDescrip[0];
+    g_swt_config.cmdBdrCfg[0].bdLength = 8U;
+
+    /* Configure switch transfer resource. */
+    swtTxRxConfig.enUseMgmtRxBdRing            = false;
+    swtTxRxConfig.enUseMgmtTxBdRing            = true;
+    swtTxRxConfig.mgmtTxBdrConfig.bdArray      = &g_mgmtTxBuffDescrip[0];
+    swtTxRxConfig.mgmtTxBdrConfig.len          = EP_TXBD_NUM;
+    swtTxRxConfig.mgmtTxBdrConfig.dirtyArray   = &g_mgmtTxDirty[0];
+    swtTxRxConfig.mgmtTxBdrConfig.msixEntryIdx = TX_MSIX_ENTRY_IDX;
+    swtTxRxConfig.mgmtTxBdrConfig.enIntr       = true;
+    swtTxRxConfig.reclaimCallback              = APP_SwtReclaimCallback;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    swtTxRxConfig.rxCacheMaintain = true;
+    swtTxRxConfig.txCacheMaintain = true;
+#endif
+
+	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
+    {
+        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
+        {
+            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
+        }
+    }
+	if_port.ep_config = &ep_config;
+    if_port.swt_config = &g_swt_config;
+	if_port.swtTxRxConfig = &swtTxRxConfig;
+    if_port.bdrConfig = &bdrConfig;
+	if_port.g_txFrame = g_txFrame;
+	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+	strncpy(soem_port.dev_name, "netc_swt", SOEM_DEV_NAME_MAXLEN);
+	soem_port.port_init = netc_swt_init;
+	soem_port.port_send = netc_swt_send;
+	soem_port.port_recv = netc_swt_recv;
+	soem_port.port_close = netc_swt_close;
+	soem_port.port_link_status= netc_swt_link_status;
+	soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
 static status_t APP_PHY_SetPort(uint32_t port, phy_config_t *phyConfig)
 {
     status_t result = kStatus_Success;
diff --git a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/app.h b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/app.h
index 91d78122a..71c45902f 100644
--- a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/app.h
+++ b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/app.h
@@ -7,14 +7,31 @@
 #define _APP_H_
 
 /*${header:start}*/
+#include "fsl_gpt.h"
 #include "fsl_netc_endpoint.h"
 #include "fsl_netc_switch.h"
 #include "fsl_netc_mdio.h"
 #include "fsl_phyyt8521.h"
 #include "fsl_msgintr.h"
+
 #include "netc_swt/soem_netc_swt.h"
+#include "netc_swt/netc_swt.h"
+#include "soem_port.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
 /*${header:end}*/
 
+#define CYCLE_SHIFT_NS  440000  // 440us
+#define DC_FILTER_CNT   64
+
 #define MASTER_SLAVE_SYNC 1U
 #define SOEM_PORT_NAME "ENET0"
 #define EXAMPLE_NETC_HAS_NO_SWITCH 0U
@@ -30,7 +47,9 @@
  #define BOARD_LED_RGPIO     BOARD_USER_LED_GPIO
  #define BOARD_LED_RGPIO_PIN BOARD_USER_LED_GPIO_PIN
 
-#define KNETC_EP_CONFIG_SI    kNETC_ENETC1PSI0
+#define EXAMPLE_SWT_SI       kNETC_ENETC1PSI0
+
+#define EXAMPLE_SWT_PSEUDO_PORT 0x4U
 
 #define NETC_FREQ             CLOCK_GetRootClockFreq(kCLOCK_Root_Netc)
 
@@ -68,10 +87,16 @@
  * Prototypes
  ******************************************************************************/
 /*${prototype:start}*/
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+void osal_timer_init(uint32_t priority);
+status_t APP_SWT_AddTableEntry(void);
+int if_port_swt_init(void);
+uint64_t system_time64_ns(void);
+void update_master_clock(void);
 status_t BOARD_InitHardware(void);
 status_t NETC_MDIO_Init(void);
 status_t NETC_PHY_Init(void);
-uint64_t system_time64_ns(void);
 /*${prototype:end}*/
 
 #endif /* _APP_H_ */
\ No newline at end of file
diff --git a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
index 1bd8faf33..f17edc1f7 100644
--- a/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
+++ b/_boards/frdmimxrt1186/soem_examples/soem_servo_motor_rt1180/bm/hardware_init.c
@@ -16,6 +16,10 @@
 #define EXAMPLE_SWT_PORT0_PHY_RESET_PIN RGPIO1, 15
 #define EXAMPLE_SWT_PORT2_PHY_RESET_PIN RGPIO1, 20
 
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (500000U)
+#endif
+
 #define PHY_EXT_ADDR_REG             0x1EU
 #define PHY_EXT_DATA_REG             0x1FU
 #define PHY_RGMII_CONFIG1_REG        0xA003U
@@ -23,11 +27,357 @@
 /*${macro:end}*/
 
 /*${variable:start}*/
+/* Rx buffer memeory type. */
+typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
+
+/* dc sync time */
+uint8_t  dc_started = 0;
+int32_t  dc_diff_ns = 0;
+int32_t  prev_dc_diff_ns = 0;
+int64_t  dc_adjust_ns;
+int64_t  system_time_offset = 0LL;
+
 /* PHY operation. */
 struct netc_swt_if_port if_port;
+static swt_config_t g_swt_config;
+static swt_transfer_config_t swtTxRxConfig;
 static phy_yt8521_resource_t s_phy_resource[5];
+
+volatile uint64_t system_time_ns = 0;
+
+/* Buffer descriptor resource. */
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BUFF_SIZE_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+#endif
+static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
+#endif
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
+                              EP_BD_ALIGN);
+static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
+#endif
 /*${variable:end}*/
 
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
+{
+    /* Transmit interrupt */
+    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
+        if_port.txOver = true;
+    }
+    /* Receive interrupt */
+    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
+    }
+}
+
+uint64_t system_time64_ns()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS - system_time_offset;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > system_time64_ns());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = system_time64_ns();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+static status_t APP_SwtReclaimCallback(swt_handle_t *handle, netc_tx_frame_info_t *frameInfo, void *userData)
+{
+    return kStatus_Success;
+}
+
+status_t APP_SWT_AddTableEntry()
+{
+    status_t result = kStatus_Success;
+    uint32_t entryID;
+
+#if defined(EXAMPLE_SWT_USE_IPF) && EXAMPLE_SWT_USE_IPF
+    netc_tb_ipf_config_t ipfEntryCfg;
+
+    memset(&ipfEntryCfg, 0U, sizeof(netc_tb_ipf_config_t));
+    ipfEntryCfg.keye.srcPortMask = EXAMPLE_SWT_USED_PORT_BITMAP;
+    ipfEntryCfg.cfge.hr          = kNETC_SoftwareDefHR0;
+    ipfEntryCfg.cfge.fltfa       = kNETC_IPFRedirectToMgmtPort;
+
+    /* Frame from used port redirect to management port. */
+    for (uint32_t i = 0; i < EXAMPLE_SWT_MAX_PORT_NUM; i++)
+    {
+        /* Only check the enabled port. */
+        if (((1U << i) & EXAMPLE_SWT_USED_PORT_BITMAP) == 0U)
+        {
+            continue;
+        }
+
+        ipfEntryCfg.keye.srcPort = i;
+        result                   = SWT_RxIPFAddTableEntry(&if_port.g_swt_handle, &ipfEntryCfg, &entryID);
+        if ((kStatus_Success != result) && (entryID != 0xFFFFFFFF))
+        {
+            PRINTF("\r\n%s: %d, Failed to add IPF table!, result = %u\r\n, entryID = %u", __func__, __LINE__, result,
+                   entryID);
+            return kStatus_Fail;
+        }
+    }
+#else
+    /* Set FDB table, input frame only forwards to pseudo MAC port. */
+    netc_tb_fdb_config_t fdbEntryCfg = {
+        .keye.fid = FRAME_FID, .cfge.portBitmap = (1U << EXAMPLE_SWT_PSEUDO_PORT), .cfge.dynamic = 1};
+    memset(&fdbEntryCfg.keye.macAddr[0], 0xFF, 6U);
+    result = SWT_BridgeAddFDBTableEntry(&if_port.g_swt_handle, &fdbEntryCfg, &entryID);
+    if ((kStatus_Success != result) || (0xFFFFFFFFU == entryID))
+    {
+        PRINTF("\r\n%s: %d, Failed to add FDB table!, result = %d, entryID = %d\r\n", __func__, __LINE__, result,
+               entryID);
+        return kStatus_Fail;
+    }
+#endif
+
+    return result;
+}
+
+static netc_rx_bdr_config_t rxBdrConfig = {0};
+static netc_tx_bdr_config_t txBdrConfig = {0};
+static netc_bdr_config_t bdrConfig;
+static netc_msix_entry_t msixEntry[2];
+static ep_config_t ep_config;
+
+int if_port_swt_init(void)
+{
+	struct soem_if_port soem_port;
+    bdrConfig.rxBdrConfig = &rxBdrConfig;
+	bdrConfig.txBdrConfig = &txBdrConfig;
+    uint32_t msgAddr;
+
+    PRINTF("\r\nNETC swtich frame loopback example start.\r\n");
+
+    /* MSIX and interrupt configuration. */
+    MSGINTR_Init(MSGINTR, &msgintrCallback);
+    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR, 0);
+    msixEntry[0].control = kNETC_MsixIntrMaskBit;
+    msixEntry[0].msgAddr = msgAddr;
+    msixEntry[0].msgData = TX_INTR_MSG_DATA;
+    msixEntry[1].control = kNETC_MsixIntrMaskBit;
+    msixEntry[1].msgAddr = msgAddr;
+    msixEntry[1].msgData = RX_INTR_MSG_DATA;
+
+    /* BD ring configuration. */
+    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
+    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
+    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
+    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
+    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
+    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
+    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
+    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
+    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
+
+    /* Endpoint configuration. */
+    (void)EP_GetDefaultConfig(&ep_config);
+    ep_config.si                    = EXAMPLE_SWT_SI;
+    ep_config.siConfig.txRingUse    = 1;
+    ep_config.siConfig.rxRingUse    = 1;
+    //ep_config.reclaimCallback       = ReclaimCallback;
+    ep_config.msixEntry             = &msixEntry[0];
+    ep_config.entryNum              = 2;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    ep_config.rxCacheMaintain = true;
+    ep_config.txCacheMaintain = true;
+#endif
+
+    SWT_GetDefaultConfig(&g_swt_config);
+
+    for (int i = 0; i < EXAMPLE_SWT_MAX_PORT_NUM; i++)
+    {
+        g_swt_config.ports[i].ethMac.miiMode   = KNETC_HW_MII_MODE;
+        g_swt_config.ports[i].ethMac.miiSpeed  = kNETC_MiiSpeed100M;
+        g_swt_config.ports[i].ethMac.miiDuplex = kNETC_MiiFullDuplex;
+    }
+
+    /* Wait a moment for PHY status to be stable. */
+    SDK_DelayAtLeastUs(PHY_STABILITY_DELAY_US, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    g_swt_config.bridgeCfg.dVFCfg.portMembership = (1U << EXAMPLE_SWT_PSEUDO_PORT) | EXAMPLE_SWT_USED_PORT_BITMAP;
+#if defined(EXAMPLE_SWT_USE_IPF) && EXAMPLE_SWT_USE_IPF
+    g_swt_config.ports[0].commonCfg.ipfCfg.enIPFTable = true;
+    g_swt_config.ports[2].commonCfg.ipfCfg.enIPFTable = true;
+#else
+    g_swt_config.bridgeCfg.dVFCfg.enUseFilterID = true;
+    g_swt_config.bridgeCfg.dVFCfg.filterID      = FRAME_FID;
+    g_swt_config.bridgeCfg.dVFCfg.mfo           = kNETC_FDBLookUpWithDiscard;
+    g_swt_config.bridgeCfg.dVFCfg.mlo           = kNETC_DisableMACLearn;
+#endif
+
+    g_swt_config.cmdRingUse            = 1U;
+    g_swt_config.cmdBdrCfg[0].bdBase   = &g_cmdBuffDescrip[0];
+    g_swt_config.cmdBdrCfg[0].bdLength = 8U;
+
+    /* Configure switch transfer resource. */
+    swtTxRxConfig.enUseMgmtRxBdRing            = false;
+    swtTxRxConfig.enUseMgmtTxBdRing            = true;
+    swtTxRxConfig.mgmtTxBdrConfig.bdArray      = &g_mgmtTxBuffDescrip[0];
+    swtTxRxConfig.mgmtTxBdrConfig.len          = EP_TXBD_NUM;
+    swtTxRxConfig.mgmtTxBdrConfig.dirtyArray   = &g_mgmtTxDirty[0];
+    swtTxRxConfig.mgmtTxBdrConfig.msixEntryIdx = TX_MSIX_ENTRY_IDX;
+    swtTxRxConfig.mgmtTxBdrConfig.enIntr       = true;
+    swtTxRxConfig.reclaimCallback              = APP_SwtReclaimCallback;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    swtTxRxConfig.rxCacheMaintain = true;
+    swtTxRxConfig.txCacheMaintain = true;
+#endif
+
+	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
+    {
+        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
+        {
+            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
+        }
+    }
+	if_port.ep_config = &ep_config;
+    if_port.swt_config = &g_swt_config;
+	if_port.swtTxRxConfig = &swtTxRxConfig;
+    if_port.bdrConfig = &bdrConfig;
+	if_port.g_txFrame = g_txFrame;
+	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+	strncpy(soem_port.dev_name, "netc_swt", SOEM_DEV_NAME_MAXLEN);
+	soem_port.port_init = netc_swt_init;
+	soem_port.port_send = netc_swt_send;
+	soem_port.port_recv = netc_swt_recv;
+	soem_port.port_close = netc_swt_close;
+	soem_port.port_link_status= netc_swt_link_status;
+	soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+uint64_t dc_diff_accu = 0;
+int32_t dc_diff_accu_arrary[DC_FILTER_CNT];
+int32_t dc_diff_accu_index = 0;
+
+static void dc_diff_init(int32_t dc_diff_ns)
+{
+	int i;
+	for (i = 0; i < DC_FILTER_CNT; i++) {
+		dc_diff_accu_arrary[i] = dc_diff_ns;
+		dc_diff_accu += dc_diff_ns;
+	}
+}
+
+static int32_t dc_diff_update(int32_t dc_diff_ns)
+{
+	dc_diff_accu += dc_diff_ns;
+	dc_diff_accu -= dc_diff_accu_arrary[dc_diff_accu_index];
+	dc_diff_accu_arrary[dc_diff_accu_index++] = dc_diff_ns;
+	if (dc_diff_accu_index >= DC_FILTER_CNT) {
+		dc_diff_accu_index = 0;
+	}
+	return dc_diff_accu / DC_FILTER_CNT;
+}
+
+#define PID_P  3 / 2
+#define PID_I  3 / 2
+#define PID_D  1 / 5 
+void update_master_clock()
+{
+	int32_t dc_diff_ns_avg;
+    // calc drift (via un-normalised time diff)
+    int32_t delta = dc_diff_ns - prev_dc_diff_ns;
+    prev_dc_diff_ns = dc_diff_ns;
+
+    if (dc_started == 2) {
+		dc_diff_ns_avg = dc_diff_update(dc_diff_ns);
+       dc_adjust_ns = dc_diff_ns * PID_P  + dc_diff_ns_avg * PID_I  + delta * PID_D;
+        if (dc_adjust_ns < -10000) {
+            dc_adjust_ns = -10000;
+        }
+        if (dc_adjust_ns > 10000) {
+            dc_adjust_ns =  10000;
+        }
+		// add cycles adjustment to time base (including a spot adjustment)
+        system_time_offset += dc_adjust_ns;
+    }
+    else {
+		if (dc_started == 0) {
+        	dc_started = (dc_diff_ns != 0);
+			system_time_offset = dc_diff_ns;
+		} else {
+			dc_started = 2;
+			dc_diff_init(dc_diff_ns);
+			system_time_offset += dc_diff_ns / 2;
+		}
+    }
+}
+
 status_t NETC_MDIO_Init(void)
 {
     status_t result = kStatus_Success;
diff --git a/_boards/imx943evk/soem_examples/soem_servo_motor/bm/cm33_core1/app.h b/_boards/imx943evk/soem_examples/soem_servo_motor/bm/cm33_core1/app.h
index 586879afe..e7ab0ed30 100644
--- a/_boards/imx943evk/soem_examples/soem_servo_motor/bm/cm33_core1/app.h
+++ b/_boards/imx943evk/soem_examples/soem_servo_motor/bm/cm33_core1/app.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -8,6 +8,7 @@
 
 /*${header:start}*/
 #include "board.h"
+#include "fsl_gpt.h"
 #include "fsl_netc_endpoint.h"
 #include "fsl_netc_switch.h"
 #include "fsl_netc_mdio.h"
@@ -15,7 +16,20 @@
 #include "fsl_phyrtl8201.h"
 #include "fsl_msgintr.h"
 #include "fsl_rgpio.h"
+
+#include "soem_port.h"
 #include "netc_ep/soem_netc_ep.h"
+#include "netc_ep/netc_ep.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
 /*${header:end}*/
 
 #define SOEM_PORT_NAME "J26"
@@ -83,6 +97,11 @@
  * Prototypes
  ******************************************************************************/
 /*${prototype:start}*/
+uint64_t gettime(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+void osal_timer_init(uint32_t priority);
+int if_port_init(void);
 status_t BOARD_InitHardware(void);
 status_t NETC_EP_MDIO_Init(void);
 status_t NETC_EP_PHY_Init(void);
diff --git a/_boards/imx943evk/soem_examples/soem_servo_motor/bm/cm33_core1/hardware_init.c b/_boards/imx943evk/soem_examples/soem_servo_motor/bm/cm33_core1/hardware_init.c
index 5904f0f38..3b10e44fc 100644
--- a/_boards/imx943evk/soem_examples/soem_servo_motor/bm/cm33_core1/hardware_init.c
+++ b/_boards/imx943evk/soem_examples/soem_servo_motor/bm/cm33_core1/hardware_init.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -11,6 +11,48 @@
 #include "fsl_power.h"
 /*${header:end}*/
 
+/*******************************************************************************
+ * Variables
+ ******************************************************************************/
+ /* Rx buffer memeory type. */
+typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
+
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+extern struct netc_ep_if_port if_port;
+#endif
+
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+extern struct netc_swt_if_port if_port;
+#endif
+
+volatile uint64_t system_time_ns = 0;
+
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+/* SWT resource. */
+static swt_config_t g_swt_config;
+static swt_transfer_config_t swtTxRxConfig;
+#endif
+
+/* Buffer descriptor resource. */
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BUFF_SIZE_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+#endif
+static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
+#endif
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
+                              EP_BD_ALIGN);
+static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
+#endif
+
 /*${variable:start}*/
 struct netc_ep_if_port if_port;
 
@@ -293,6 +335,175 @@ static status_t NETC_EP_EMDIORead(uint8_t phyAddr, uint8_t regAddr, uint16_t *pD
     return NETC_MDIORead(&if_port.s_emdio_handle, phyAddr, regAddr, pData);
 }
 
+uint64_t gettime()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > gettime());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = gettime();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
+{
+    /* Transmit interrupt */
+    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
+        if_port.txOver = true;
+    }
+    /* Receive interrupt */
+    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
+    }
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+static netc_rx_bdr_config_t rxBdrConfig = {0};
+static netc_tx_bdr_config_t txBdrConfig = {0};
+static netc_bdr_config_t bdrConfig;
+static netc_msix_entry_t msixEntry[2];
+static ep_config_t ep_config;
+
+/* OSHW: register enet port to SOEM stack */
+int if_port_init(void)
+{
+	struct soem_if_port soem_port;
+
+    bdrConfig.rxBdrConfig = &rxBdrConfig;
+	bdrConfig.txBdrConfig = &txBdrConfig;
+    uint32_t msgAddr;
+
+    PRINTF("\r\nNETC EP frame loopback example start.\r\n");
+
+    /* MSIX and interrupt configuration. */
+    MSGINTR_Init(MSGINTR1, &msgintrCallback);
+    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR1, 0);
+    msixEntry[0].control = kNETC_MsixIntrMaskBit;
+    msixEntry[0].msgAddr = msgAddr;
+    msixEntry[0].msgData = TX_INTR_MSG_DATA;
+    msixEntry[1].control = kNETC_MsixIntrMaskBit;
+    msixEntry[1].msgAddr = msgAddr;
+    msixEntry[1].msgData = RX_INTR_MSG_DATA;
+
+    /* BD ring configuration. */
+    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
+    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
+    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
+    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
+    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
+    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
+    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
+    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
+    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
+
+    bdrConfig.txBdrConfig[0].bdArray      = &g_txBuffDescrip[0][0];
+    bdrConfig.txBdrConfig[0].len          = EP_TXBD_NUM;
+    bdrConfig.txBdrConfig[0].dirtyArray   = &g_txDirty[0][0];
+    bdrConfig.txBdrConfig[0].msixEntryIdx = TX_MSIX_ENTRY_IDX;
+    bdrConfig.txBdrConfig[0].enIntr       = true;
+
+    /* Endpoint configuration. */
+    (void)EP_GetDefaultConfig(&ep_config);
+    ep_config.si                    = KNETC_EP_CONFIG_SI;
+    ep_config.siConfig.txRingUse    = 1;
+    ep_config.siConfig.rxRingUse    = 1;
+    //ep_config.reclaimCallback       = ReclaimCallback;
+    ep_config.msixEntry             = &msixEntry[0];
+    ep_config.entryNum              = 2;
+    ep_config.port.ethMac.miiMode   = KNETC_HW_MII_MODE;
+    ep_config.port.ethMac.miiSpeed  = kNETC_MiiSpeed100M;
+    ep_config.port.ethMac.miiDuplex = kNETC_MiiFullDuplex;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    ep_config.rxCacheMaintain = true;
+    ep_config.txCacheMaintain = true;
+#endif
+    
+	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
+    {
+        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
+        {
+            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
+        }
+    }
+	if_port.ep_config = &ep_config;
+	if_port.bdrConfig = &bdrConfig;
+	if_port.g_txFrame = g_txFrame;
+	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+	strncpy(soem_port.dev_name, "netc_ep", SOEM_DEV_NAME_MAXLEN);
+	soem_port.port_init = netc_ep_init;
+	soem_port.port_send = netc_ep_send;
+	soem_port.port_recv = netc_ep_recv;
+	soem_port.port_close = netc_ep_close;
+	soem_port.port_link_status= netc_ep_link_status;
+	soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
 phy_rtl8211f_resource_t s_phy_resource;
 status_t NETC_EP_PHY_Init(void)
 {
diff --git a/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/app.h b/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/app.h
index 17ecff434..9094efbd3 100644
--- a/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/app.h
+++ b/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/app.h
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -8,6 +8,7 @@
 
 /*${header:start}*/
 #include "board.h"
+#include "fsl_gpt.h"
 #include "fsl_netc_endpoint.h"
 #include "fsl_netc_switch.h"
 #include "fsl_netc_mdio.h"
@@ -15,9 +16,25 @@
 #include "fsl_phyrtl8201.h"
 #include "fsl_msgintr.h"
 #include "fsl_rgpio.h"
+
 #include "netc_ep/soem_netc_ep.h"
+#include "netc_ep/netc_ep.h"
+#include "soem_port.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
 /*${header:end}*/
 
+#define CYCLE_SHIFT_NS  440000  // 440us
+#define DC_FILTER_CNT   64
+
 #define SOEM_PORT_NAME "J26"
 #define MASTER_SLAVE_SYNC 1U
 
@@ -84,11 +101,16 @@
  * Prototypes
  ******************************************************************************/
 /*${prototype:start}*/
+void osal_timer_init(uint32_t priority);
+uint64_t system_time64_ns(void);
+void nsleep_to (uint64_t nsec_target);
+void osal_gettime(struct timeval *current_time);
+int if_port_init(void);
+void update_master_clock(void);
 status_t BOARD_InitHardware(void);
 status_t NETC_EP_MDIO_Init(void);
 status_t NETC_EP_PHY_Init(void);
 status_t NETC_EP_PHY_GetLinkStatus(phy_handle_t *handler, bool *link);
-uint64_t system_time64_ns(void);
 /*${prototype:end}*/
 
 #endif /* _APP_H_ */
\ No newline at end of file
diff --git a/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/hardware_init.c b/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/hardware_init.c
index 2f6c1f026..049576b4f 100644
--- a/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/hardware_init.c
+++ b/_boards/imx943evk/soem_examples/soem_servo_motor_rt1180/bm/cm33_core1/hardware_init.c
@@ -1,5 +1,5 @@
 /*
- * Copyright 2024 NXP
+ * Copyright 2024-2025 NXP
  *
  * SPDX-License-Identifier: BSD-3-Clause
  */
@@ -11,9 +11,267 @@
 #include "fsl_power.h"
 /*${header:end}*/
 
-/*${variable:start}*/
+/* Rx buffer memeory type. */
+typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
+
+/* dc sync time */
+uint8_t  dc_started = 0;
+int32_t  dc_diff_ns = 0;
+int32_t  prev_dc_diff_ns = 0;
+int64_t  dc_adjust_ns;
+int64_t  system_time_offset = 0LL;
+
 struct netc_ep_if_port if_port;
 
+volatile uint64_t system_time_ns = 0;
+
+/* Buffer descriptor resource. */
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
+                              EP_BUFF_SIZE_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
+#endif
+static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
+#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
+static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
+#endif
+#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
+AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
+                              EP_BD_ALIGN);
+static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
+#endif
+
+void irq_wake_task(void)
+{
+    return;
+}
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag. */
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+
+	system_time_ns += CLOCK_INCREASE_PER_SEC;
+
+	irq_wake_task();
+	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+ 	 exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void osal_timer_init(uint32_t priority)
+{
+	uint32_t gptFreq;
+	gpt_config_t gptConfig;
+
+	assert(priority < (1UL << __NVIC_PRIO_BITS));
+
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	gptFreq = OSAL_TIMER_CLK_FREQ;
+	/* Divide GPT clock source frequency to 1MHz */
+	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
+{
+    /* Transmit interrupt */
+    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
+        if_port.txOver = true;
+    }
+    /* Receive interrupt */
+    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
+    {
+        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
+    }
+}
+
+uint64_t system_time64_ns()
+{
+	uint64_t nsec_base;
+	uint32_t cur_nsec;
+
+	nsec_base  = system_time_ns;
+	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+
+	if (nsec_base != system_time_ns)
+	{
+		nsec_base  = system_time_ns;
+		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS - system_time_offset;
+}
+
+void nsleep_to (uint64_t nsec_target)
+{
+	while (nsec_target > system_time64_ns());
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint64_t nsec = system_time64_ns();
+	
+	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
+	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
+
+	return;
+}
+
+static netc_rx_bdr_config_t rxBdrConfig = {0};
+static netc_tx_bdr_config_t txBdrConfig = {0};
+static netc_bdr_config_t bdrConfig;
+static netc_msix_entry_t msixEntry[2];
+static ep_config_t ep_config;
+
+/* OSHW: register enet port to SOEM stack */
+int if_port_init(void)
+{
+	struct soem_if_port soem_port;
+
+    bdrConfig.rxBdrConfig = &rxBdrConfig;
+	bdrConfig.txBdrConfig = &txBdrConfig;
+    uint32_t msgAddr;
+
+    PRINTF("\r\nNETC EP frame loopback example start.\r\n");
+
+    /* MSIX and interrupt configuration. */
+    MSGINTR_Init(MSGINTR1, &msgintrCallback);
+    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR1, 0);
+    msixEntry[0].control = kNETC_MsixIntrMaskBit;
+    msixEntry[0].msgAddr = msgAddr;
+    msixEntry[0].msgData = TX_INTR_MSG_DATA;
+    msixEntry[1].control = kNETC_MsixIntrMaskBit;
+    msixEntry[1].msgAddr = msgAddr;
+    msixEntry[1].msgData = RX_INTR_MSG_DATA;
+
+    /* BD ring configuration. */
+    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
+    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
+    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
+    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
+    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
+    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
+    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
+    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
+    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
+
+    bdrConfig.txBdrConfig[0].bdArray      = &g_txBuffDescrip[0][0];
+    bdrConfig.txBdrConfig[0].len          = EP_TXBD_NUM;
+    bdrConfig.txBdrConfig[0].dirtyArray   = &g_txDirty[0][0];
+    bdrConfig.txBdrConfig[0].msixEntryIdx = TX_MSIX_ENTRY_IDX;
+    bdrConfig.txBdrConfig[0].enIntr       = true;
+
+    /* Endpoint configuration. */
+    (void)EP_GetDefaultConfig(&ep_config);
+    ep_config.si                    = KNETC_EP_CONFIG_SI;
+    ep_config.siConfig.txRingUse    = 1;
+    ep_config.siConfig.rxRingUse    = 1;
+    //ep_config.reclaimCallback       = ReclaimCallback;
+    ep_config.msixEntry             = &msixEntry[0];
+    ep_config.entryNum              = 2;
+    ep_config.port.ethMac.miiMode   = KNETC_HW_MII_MODE;
+    ep_config.port.ethMac.miiSpeed  = kNETC_MiiSpeed100M;
+    ep_config.port.ethMac.miiDuplex = kNETC_MiiFullDuplex;
+#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
+    ep_config.rxCacheMaintain = true;
+    ep_config.txCacheMaintain = true;
+#endif
+    
+	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
+    {
+        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
+        {
+            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
+        }
+    }
+	if_port.ep_config = &ep_config;
+	if_port.bdrConfig = &bdrConfig;
+	if_port.g_txFrame = g_txFrame;
+	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
+	strncpy(soem_port.dev_name, "netc_ep", SOEM_DEV_NAME_MAXLEN);
+	soem_port.port_init = netc_ep_init;
+	soem_port.port_send = netc_ep_send;
+	soem_port.port_recv = netc_ep_recv;
+	soem_port.port_close = netc_ep_close;
+	soem_port.port_link_status= netc_ep_link_status;
+	soem_port.port_pri = &if_port;
+    return register_soem_port(&soem_port);
+}
+
+uint64_t dc_diff_accu = 0;
+int32_t dc_diff_accu_arrary[DC_FILTER_CNT];
+int32_t dc_diff_accu_index = 0;
+
+static void dc_diff_init(int32_t dc_diff_ns)
+{
+	int i;
+	for (i = 0; i < DC_FILTER_CNT; i++) {
+		dc_diff_accu_arrary[i] = dc_diff_ns;
+		dc_diff_accu += dc_diff_ns;
+	}
+}
+
+static int32_t dc_diff_update(int32_t dc_diff_ns)
+{
+	dc_diff_accu += dc_diff_ns;
+	dc_diff_accu -= dc_diff_accu_arrary[dc_diff_accu_index];
+	dc_diff_accu_arrary[dc_diff_accu_index++] = dc_diff_ns;
+	if (dc_diff_accu_index >= DC_FILTER_CNT) {
+		dc_diff_accu_index = 0;
+	}
+	return dc_diff_accu / DC_FILTER_CNT;
+}
+
+#define PID_P  3 / 2
+#define PID_I  3 / 2
+#define PID_D  1 / 5 
+void update_master_clock()
+{
+	int32_t dc_diff_ns_avg;
+    // calc drift (via un-normalised time diff)
+    int32_t delta = dc_diff_ns - prev_dc_diff_ns;
+    prev_dc_diff_ns = dc_diff_ns;
+
+    if (dc_started == 2) {
+		dc_diff_ns_avg = dc_diff_update(dc_diff_ns);
+       dc_adjust_ns = dc_diff_ns * PID_P  + dc_diff_ns_avg * PID_I  + delta * PID_D;
+        if (dc_adjust_ns < -10000) {
+            dc_adjust_ns = -10000;
+        }
+        if (dc_adjust_ns > 10000) {
+            dc_adjust_ns =  10000;
+        }
+		// add cycles adjustment to time base (including a spot adjustment)
+        system_time_offset += dc_adjust_ns;
+    }
+    else {
+		if (dc_started == 0) {
+        	dc_started = (dc_diff_ns != 0);
+			system_time_offset = dc_diff_ns;
+		} else {
+			dc_started = 2;
+			dc_diff_init(dc_diff_ns);
+			system_time_offset += dc_diff_ns / 2;
+		}
+    }
+}
+
 status_t BOARD_InitHardware(void)
 {
     status_t result = kStatus_Success;
diff --git a/soem_examples/soem_servo_motor/bm/soem_servo_motor.c b/soem_examples/soem_servo_motor/bm/soem_servo_motor.c
index 85254d35a..66174013b 100644
--- a/soem_examples/soem_servo_motor/bm/soem_servo_motor.c
+++ b/soem_examples/soem_servo_motor/bm/soem_servo_motor.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2015, Freescale Semiconductor, Inc.
- * Copyright 2016-2024 NXP
+ * Copyright 2016-2025 NXP
  * All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -12,31 +12,10 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-#include "ethercattype.h"
-#include "nicdrv.h"
-#include "ethercatbase.h"
-#include "ethercatmain.h"
-#include "ethercatdc.h"
-#include "ethercatcoe.h"
-#include "ethercatfoe.h"
-#include "ethercatconfig.h"
-#include "ethercatprint.h"
-#include "soem_port.h"
-
 #include "cia402.h"
 #include "servo.h"
-#include "fsl_gpt.h"
 #include "app.h"
 
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
-#include "netc_ep/soem_netc_ep.h"
-#include "netc_ep/netc_ep.h"
-#endif
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-#include "netc_swt/soem_netc_swt.h"
-#include "netc_swt/netc_swt.h"
-#endif
-
 /*******************************************************************************
  * Definitions
  ******************************************************************************/
@@ -54,65 +33,9 @@
 #define MAX_SERVO 2
 #define MAX_AXIS 2
 
-#ifndef PHY_STABILITY_DELAY_US
-#define PHY_STABILITY_DELAY_US (500000U)
-#endif
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-/* ENETC pseudo port for management */
-#ifndef EXAMPLE_SWT_SI
-#define EXAMPLE_SWT_SI kNETC_ENETC1PSI0
-#endif
-/* Switch pseudo port */
-#ifndef EXAMPLE_SWT_PSEUDO_PORT
-#define EXAMPLE_SWT_PSEUDO_PORT 0x4U
-#endif
-#endif
-/*******************************************************************************
- * Prototypes
- ******************************************************************************/
-/* Rx buffer memeory type. */
-typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
-
 /*******************************************************************************
  * Variables
  ******************************************************************************/
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
-extern struct netc_ep_if_port if_port;
-#endif
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-extern struct netc_swt_if_port if_port;
-#endif
-
-volatile uint64_t system_time_ns = 0;
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-/* SWT resource. */
-static swt_config_t g_swt_config;
-static swt_transfer_config_t swtTxRxConfig;
-#endif
-
-/* Buffer descriptor resource. */
-AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
-                              EP_BD_ALIGN);
-AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
-                              EP_BUFF_SIZE_ALIGN);
-AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
-AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
-#endif
-static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
-#endif
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
-AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
-                              EP_BD_ALIGN);
-static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
-#endif
-
 static char IOmap[1500];
 
 static char *tp[MAX_SERVO] = {
@@ -296,345 +219,6 @@ static void servo_setup(struct servo_t *servo, int servo_num) {
 	}
 }
 
-void irq_wake_task(void);
-
-void OSAL_TIMER_IRQHandler(void)
-{
-	/* Clear interrupt flag. */
-	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
-
-	system_time_ns += CLOCK_INCREASE_PER_SEC;
-
-	irq_wake_task();
-	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
- 	 exception return operation might vector to incorrect interrupt */
-#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
-	__DSB();
-#endif
-}
-
-static void osal_timer_init(uint32_t priority)
-{
-	uint32_t gptFreq;
-	gpt_config_t gptConfig;
-
-	assert(priority < (1UL << __NVIC_PRIO_BITS));
-
-	GPT_GetDefaultConfig(&gptConfig);
-	GPT_Init(OSAL_TIMER, &gptConfig);
-	gptFreq = OSAL_TIMER_CLK_FREQ;
-	/* Divide GPT clock source frequency to 1MHz */
-	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
-	/* Set both GPT modules to 1 second duration */
-	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
-	/* Enable GPT Output Compare1 interrupt */
-	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
-	/* Enable at the Interrupt */
-	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
-	EnableIRQ(OSAL_TIMER_IRQ_ID);
-	GPT_StartTimer(OSAL_TIMER);
-}
-
-void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
-{
-    /* Transmit interrupt */
-    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
-    {
-        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
-        if_port.txOver = true;
-    }
-    /* Receive interrupt */
-    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
-    {
-        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
-    }
-}
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-static status_t APP_SwtReclaimCallback(swt_handle_t *handle, netc_tx_frame_info_t *frameInfo, void *userData)
-{
-    return kStatus_Success;
-}
-#endif
-
-static uint64_t gettime()
-{
-	uint64_t nsec_base;
-	uint32_t cur_nsec;
-
-	nsec_base  = system_time_ns;
-	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
-
-	if (nsec_base != system_time_ns)
-	{
-		nsec_base  = system_time_ns;
-		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
-	}
-	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS;
-}
-
-static void nsleep_to (uint64_t nsec_target)
-{
-	while (nsec_target > gettime());
-}
-
-void osal_gettime(struct timeval *current_time)
-{
-	uint64_t nsec = gettime();
-	
-	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
-	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
-
-	return;
-}
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-static status_t APP_SWT_AddTableEntry()
-{
-    status_t result = kStatus_Success;
-    uint32_t entryID;
-
-#if defined(EXAMPLE_SWT_USE_IPF) && EXAMPLE_SWT_USE_IPF
-    netc_tb_ipf_config_t ipfEntryCfg;
-
-    memset(&ipfEntryCfg, 0U, sizeof(netc_tb_ipf_config_t));
-    ipfEntryCfg.keye.srcPortMask = EXAMPLE_SWT_USED_PORT_BITMAP;
-    ipfEntryCfg.cfge.hr          = kNETC_SoftwareDefHR0;
-    ipfEntryCfg.cfge.fltfa       = kNETC_IPFRedirectToMgmtPort;
-
-    /* Frame from used port redirect to management port. */
-    for (uint32_t i = 0; i < EXAMPLE_SWT_MAX_PORT_NUM; i++)
-    {
-        /* Only check the enabled port. */
-        if (((1U << i) & EXAMPLE_SWT_USED_PORT_BITMAP) == 0U)
-        {
-            continue;
-        }
-
-        ipfEntryCfg.keye.srcPort = i;
-        result                   = SWT_RxIPFAddTableEntry(&if_port.g_swt_handle, &ipfEntryCfg, &entryID);
-        if ((kStatus_Success != result) && (entryID != 0xFFFFFFFF))
-        {
-            PRINTF("\r\n%s: %d, Failed to add IPF table!, result = %u\r\n, entryID = %u", __func__, __LINE__, result,
-                   entryID);
-            return kStatus_Fail;
-        }
-    }
-#else
-    /* Set FDB table, input frame only forwards to pseudo MAC port. */
-    netc_tb_fdb_config_t fdbEntryCfg = {
-        .keye.fid = FRAME_FID, .cfge.portBitmap = (1U << EXAMPLE_SWT_PSEUDO_PORT), .cfge.dynamic = 1};
-    memset(&fdbEntryCfg.keye.macAddr[0], 0xFF, 6U);
-    result = SWT_BridgeAddFDBTableEntry(&if_port.g_swt_handle, &fdbEntryCfg, &entryID);
-    if ((kStatus_Success != result) || (0xFFFFFFFFU == entryID))
-    {
-        PRINTF("\r\n%s: %d, Failed to add FDB table!, result = %d, entryID = %d\r\n", __func__, __LINE__, result,
-               entryID);
-        return kStatus_Fail;
-    }
-#endif
-
-    return result;
-}
-#endif
-
-static netc_rx_bdr_config_t rxBdrConfig = {0};
-static netc_tx_bdr_config_t txBdrConfig = {0};
-static netc_bdr_config_t bdrConfig;
-static netc_msix_entry_t msixEntry[2];
-static ep_config_t ep_config;
-
-/* OSHW: register enet port to SOEM stack */
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
-static int if_port_init(void)
-{
-	struct soem_if_port soem_port;
-
-    bdrConfig.rxBdrConfig = &rxBdrConfig;
-	bdrConfig.txBdrConfig = &txBdrConfig;
-    uint32_t msgAddr;
-
-    PRINTF("\r\nNETC EP frame loopback example start.\r\n");
-
-    /* MSIX and interrupt configuration. */
-    MSGINTR_Init(MSGINTR1, &msgintrCallback);
-    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR1, 0);
-    msixEntry[0].control = kNETC_MsixIntrMaskBit;
-    msixEntry[0].msgAddr = msgAddr;
-    msixEntry[0].msgData = TX_INTR_MSG_DATA;
-    msixEntry[1].control = kNETC_MsixIntrMaskBit;
-    msixEntry[1].msgAddr = msgAddr;
-    msixEntry[1].msgData = RX_INTR_MSG_DATA;
-
-    /* BD ring configuration. */
-    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
-    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
-    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
-    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
-    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
-    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
-    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
-    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
-    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
-
-    bdrConfig.txBdrConfig[0].bdArray      = &g_txBuffDescrip[0][0];
-    bdrConfig.txBdrConfig[0].len          = EP_TXBD_NUM;
-    bdrConfig.txBdrConfig[0].dirtyArray   = &g_txDirty[0][0];
-    bdrConfig.txBdrConfig[0].msixEntryIdx = TX_MSIX_ENTRY_IDX;
-    bdrConfig.txBdrConfig[0].enIntr       = true;
-
-    /* Endpoint configuration. */
-    (void)EP_GetDefaultConfig(&ep_config);
-    ep_config.si                    = KNETC_EP_CONFIG_SI;
-    ep_config.siConfig.txRingUse    = 1;
-    ep_config.siConfig.rxRingUse    = 1;
-    //ep_config.reclaimCallback       = ReclaimCallback;
-    ep_config.msixEntry             = &msixEntry[0];
-    ep_config.entryNum              = 2;
-    ep_config.port.ethMac.miiMode   = KNETC_HW_MII_MODE;
-    ep_config.port.ethMac.miiSpeed  = kNETC_MiiSpeed100M;
-    ep_config.port.ethMac.miiDuplex = kNETC_MiiFullDuplex;
-#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
-    ep_config.rxCacheMaintain = true;
-    ep_config.txCacheMaintain = true;
-#endif
-    
-	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
-    {
-        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
-        {
-            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
-        }
-    }
-	if_port.ep_config = &ep_config;
-	if_port.bdrConfig = &bdrConfig;
-	if_port.g_txFrame = g_txFrame;
-	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
-	strncpy(soem_port.dev_name, "net_ep", SOEM_DEV_NAME_MAXLEN);
-	soem_port.port_init = netc_ep_init;
-	soem_port.port_send = netc_ep_send;
-	soem_port.port_recv = netc_ep_recv;
-	soem_port.port_close = netc_ep_close;
-	soem_port.port_link_status= netc_ep_link_status;
-	soem_port.port_pri = &if_port;
-    return register_soem_port(&soem_port);
-}
-#endif
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-static int if_port_swt_init(void)
-{
-	struct soem_if_port soem_port;
-    bdrConfig.rxBdrConfig = &rxBdrConfig;
-	bdrConfig.txBdrConfig = &txBdrConfig;
-    uint32_t msgAddr;
-
-    PRINTF("\r\nNETC swtich frame loopback example start.\r\n");
-
-    /* MSIX and interrupt configuration. */
-    MSGINTR_Init(MSGINTR, &msgintrCallback);
-    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR, 0);
-    msixEntry[0].control = kNETC_MsixIntrMaskBit;
-    msixEntry[0].msgAddr = msgAddr;
-    msixEntry[0].msgData = TX_INTR_MSG_DATA;
-    msixEntry[1].control = kNETC_MsixIntrMaskBit;
-    msixEntry[1].msgAddr = msgAddr;
-    msixEntry[1].msgData = RX_INTR_MSG_DATA;
-
-    /* BD ring configuration. */
-    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
-    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
-    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
-    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
-    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
-    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
-    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
-    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
-    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
-
-    /* Endpoint configuration. */
-    (void)EP_GetDefaultConfig(&ep_config);
-    ep_config.si                    = EXAMPLE_SWT_SI;
-    ep_config.siConfig.txRingUse    = 1;
-    ep_config.siConfig.rxRingUse    = 1;
-    //ep_config.reclaimCallback       = ReclaimCallback;
-    ep_config.msixEntry             = &msixEntry[0];
-    ep_config.entryNum              = 2;
-#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
-    ep_config.rxCacheMaintain = true;
-    ep_config.txCacheMaintain = true;
-#endif
-
-    SWT_GetDefaultConfig(&g_swt_config);
-
-    for (int i = 0; i < EXAMPLE_SWT_MAX_PORT_NUM; i++)
-    {
-        g_swt_config.ports[i].ethMac.miiMode   = KNETC_HW_MII_MODE;
-        g_swt_config.ports[i].ethMac.miiSpeed  = kNETC_MiiSpeed100M;
-        g_swt_config.ports[i].ethMac.miiDuplex = kNETC_MiiFullDuplex;
-    }
-
-    /* Wait a moment for PHY status to be stable. */
-    SDK_DelayAtLeastUs(PHY_STABILITY_DELAY_US, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
-
-    g_swt_config.bridgeCfg.dVFCfg.portMembership = (1U << EXAMPLE_SWT_PSEUDO_PORT) | EXAMPLE_SWT_USED_PORT_BITMAP;
-#if defined(EXAMPLE_SWT_USE_IPF) && EXAMPLE_SWT_USE_IPF
-    g_swt_config.ports[0].commonCfg.ipfCfg.enIPFTable = true;
-    g_swt_config.ports[2].commonCfg.ipfCfg.enIPFTable = true;
-#else
-    g_swt_config.bridgeCfg.dVFCfg.enUseFilterID = true;
-    g_swt_config.bridgeCfg.dVFCfg.filterID      = FRAME_FID;
-    g_swt_config.bridgeCfg.dVFCfg.mfo           = kNETC_FDBLookUpWithDiscard;
-    g_swt_config.bridgeCfg.dVFCfg.mlo           = kNETC_DisableMACLearn;
-#endif
-
-    g_swt_config.cmdRingUse            = 1U;
-    g_swt_config.cmdBdrCfg[0].bdBase   = &g_cmdBuffDescrip[0];
-    g_swt_config.cmdBdrCfg[0].bdLength = 8U;
-
-    /* Configure switch transfer resource. */
-    swtTxRxConfig.enUseMgmtRxBdRing            = false;
-    swtTxRxConfig.enUseMgmtTxBdRing            = true;
-    swtTxRxConfig.mgmtTxBdrConfig.bdArray      = &g_mgmtTxBuffDescrip[0];
-    swtTxRxConfig.mgmtTxBdrConfig.len          = EP_TXBD_NUM;
-    swtTxRxConfig.mgmtTxBdrConfig.dirtyArray   = &g_mgmtTxDirty[0];
-    swtTxRxConfig.mgmtTxBdrConfig.msixEntryIdx = TX_MSIX_ENTRY_IDX;
-    swtTxRxConfig.mgmtTxBdrConfig.enIntr       = true;
-    swtTxRxConfig.reclaimCallback              = APP_SwtReclaimCallback;
-#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
-    swtTxRxConfig.rxCacheMaintain = true;
-    swtTxRxConfig.txCacheMaintain = true;
-#endif
-
-	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
-    {
-        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
-        {
-            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
-        }
-    }
-	if_port.ep_config = &ep_config;
-    if_port.swt_config = &g_swt_config;
-	if_port.swtTxRxConfig = &swtTxRxConfig;
-    if_port.bdrConfig = &bdrConfig;
-	if_port.g_txFrame = g_txFrame;
-	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
-	strncpy(soem_port.dev_name, "netc_swt", SOEM_DEV_NAME_MAXLEN);
-	soem_port.port_init = netc_swt_init;
-	soem_port.port_send = netc_swt_send;
-	soem_port.port_recv = netc_swt_recv;
-	soem_port.port_close = netc_swt_close;
-	soem_port.port_link_status= netc_swt_link_status;
-	soem_port.port_pri = &if_port;
-    return register_soem_port(&soem_port);
-}
-#endif
-
-void irq_wake_task(void)
-{
-    return;
-}
-
 void control_task(char *ifname)
 {
 	int expectedWKC;
diff --git a/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c b/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c
index c5a4632cc..16eb4404e 100644
--- a/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c
+++ b/soem_examples/soem_servo_motor_rt1180/bm/soem_servo_motor.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2015, Freescale Semiconductor, Inc.
- * Copyright 2016-2024 NXP
+ * Copyright 2016-2025 NXP
  * All rights reserved.
  *
  * SPDX-License-Identifier: BSD-3-Clause
@@ -12,37 +12,14 @@
 #include <stdlib.h>
 #include <stdio.h>
 
-#include "ethercattype.h"
-#include "nicdrv.h"
-#include "ethercatbase.h"
-#include "ethercatmain.h"
-#include "ethercatdc.h"
-#include "ethercatcoe.h"
-#include "ethercatfoe.h"
-#include "ethercatconfig.h"
-#include "ethercatprint.h"
-#include "soem_port.h"
-
 #include "cia402.h"
 #include "servo.h"
-#include "fsl_gpt.h"
 #include "app.h"
 
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
-#include "netc_ep/soem_netc_ep.h"
-#include "netc_ep/netc_ep.h"
-#endif
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-#include "netc_swt/soem_netc_swt.h"
-#include "netc_swt/netc_swt.h"
-#endif
-
 /*******************************************************************************
  * Definitions
  ******************************************************************************/
 #define CYCLE_PERIOD_NS 1000000 // 1ms
-#define CYCLE_SHIFT_NS  440000  // 440us
-#define DC_FILTER_CNT   64
 
 #define asda_b3_VendorId 0x000001dd
 #define asda_b3_ProductID 0x00006080
@@ -53,72 +30,12 @@
 #define MAX_SERVO 1
 #define MAX_AXIS 1
 
-#ifndef PHY_STABILITY_DELAY_US
-#define PHY_STABILITY_DELAY_US (500000U)
-#endif
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-/* ENETC pseudo port for management */
-#ifndef EXAMPLE_SWT_SI
-#define EXAMPLE_SWT_SI kNETC_ENETC1PSI0
-#endif
-/* Switch pseudo port */
-#ifndef EXAMPLE_SWT_PSEUDO_PORT
-#define EXAMPLE_SWT_PSEUDO_PORT 0x4U
-#endif
-#endif
-/*******************************************************************************
- * Prototypes
- ******************************************************************************/
-/* Rx buffer memeory type. */
-typedef uint8_t rx_buffer_t[EP_RXBUFF_SIZE_ALIGN];
-
-/* dc sync time */
-static uint64_t dc_start_time_ns = 0LL;
-static uint8_t  dc_started = 0;
-static int32_t  dc_diff_ns = 0;
-static int32_t  prev_dc_diff_ns = 0;
-static int64_t  dc_adjust_ns;
-static int64_t  system_time_offset = 0LL;
-
 /*******************************************************************************
  * Variables
  ******************************************************************************/
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
-extern struct netc_ep_if_port if_port;
-#endif
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-extern struct netc_swt_if_port if_port;
-#endif
-
-volatile uint64_t system_time_ns = 0;
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-/* SWT resource. */
-static swt_config_t g_swt_config;
-static swt_transfer_config_t swtTxRxConfig;
-#endif
-
-/* Buffer descriptor resource. */
-AT_NONCACHEABLE_SECTION_ALIGN(static netc_rx_bd_t g_rxBuffDescrip[EP_RING_NUM][EP_RXBD_NUM],
-                              EP_BD_ALIGN);
-AT_NONCACHEABLE_SECTION_ALIGN(static rx_buffer_t g_rxDataBuff[EP_RING_NUM][EP_RXBD_NUM],
-                              EP_BUFF_SIZE_ALIGN);
-AT_NONCACHEABLE_SECTION_ALIGN(static uint8_t g_txFrame[EP_TXBUFF_SIZE], EP_BUFF_SIZE_ALIGN);
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_mgmtTxBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
-AT_NONCACHEABLE_SECTION_ALIGN(static netc_cmd_bd_t g_cmdBuffDescrip[EP_TXBD_NUM], EP_BD_ALIGN);
-#endif
-static uint64_t rxBuffAddrArray[EP_RING_NUM][EP_RXBD_NUM];
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-static netc_tx_frame_info_t g_mgmtTxDirty[EP_TXBD_NUM];
-#endif
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
-AT_NONCACHEABLE_SECTION_ALIGN(static netc_tx_bd_t g_txBuffDescrip[EP_RING_NUM][EP_TXBD_NUM],
-                              EP_BD_ALIGN);
-static netc_tx_frame_info_t g_txDirty[EP_RING_NUM][EP_TXBD_NUM];
-#endif
+/* dc sync time */
+uint64_t dc_start_time_ns = 0LL;
+extern int32_t  dc_diff_ns;
 
 static char IOmap[1500];
 
@@ -250,401 +167,6 @@ static void servo_setup(struct servo_t *servo, int servo_num) {
 	}
 }
 
-void irq_wake_task(void);
-
-void OSAL_TIMER_IRQHandler(void)
-{
-	/* Clear interrupt flag. */
-	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
-
-	system_time_ns += CLOCK_INCREASE_PER_SEC;
-
-	irq_wake_task();
-	/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
- 	 exception return operation might vector to incorrect interrupt */
-#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
-	__DSB();
-#endif
-}
-
-static void osal_timer_init(uint32_t priority)
-{
-	uint32_t gptFreq;
-	gpt_config_t gptConfig;
-
-	assert(priority < (1UL << __NVIC_PRIO_BITS));
-
-	GPT_GetDefaultConfig(&gptConfig);
-	GPT_Init(OSAL_TIMER, &gptConfig);
-	gptFreq = OSAL_TIMER_CLK_FREQ;
-	/* Divide GPT clock source frequency to 1MHz */
-	GPT_SetClockDivider(OSAL_TIMER, gptFreq / CLOCK_GRANULARITY_FRE);
-	/* Set both GPT modules to 1 second duration */
-	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, CLOCK_GRANULARITY_FRE);
-	/* Enable GPT Output Compare1 interrupt */
-	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
-	/* Enable at the Interrupt */
-	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, priority);
-	EnableIRQ(OSAL_TIMER_IRQ_ID);
-	GPT_StartTimer(OSAL_TIMER);
-}
-
-void msgintrCallback(MSGINTR_Type *base, uint8_t channel, uint32_t pendingIntr)
-{
-    /* Transmit interrupt */
-    if ((pendingIntr & (1U << TX_INTR_MSG_DATA)) != 0U)
-    {
-        EP_CleanTxIntrFlags(&if_port.g_ep_handle, 1, 0);
-        if_port.txOver = true;
-    }
-    /* Receive interrupt */
-    if ((pendingIntr & (1U << RX_INTR_MSG_DATA)) != 0U)
-    {
-        EP_CleanRxIntrFlags(&if_port.g_ep_handle, 1);
-    }
-}
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-static status_t APP_SwtReclaimCallback(swt_handle_t *handle, netc_tx_frame_info_t *frameInfo, void *userData)
-{
-    return kStatus_Success;
-}
-#endif
-
-uint64_t system_time64_ns()
-{
-	uint64_t nsec_base;
-	uint32_t cur_nsec;
-
-	nsec_base  = system_time_ns;
-	cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
-
-	if (nsec_base != system_time_ns)
-	{
-		nsec_base  = system_time_ns;
-		cur_nsec   = GPT_GetCurrentTimerCount(OSAL_TIMER);
-	}
-	return nsec_base + cur_nsec * CLOCK_GRANULARITY_NS - system_time_offset;
-}
-
-static void nsleep_to (uint64_t nsec_target)
-{
-	while (nsec_target > system_time64_ns());
-}
-
-void osal_gettime(struct timeval *current_time)
-{
-	uint64_t nsec = system_time64_ns();
-	
-	current_time->tv_sec  = nsec / CLOCK_INCREASE_PER_SEC;
-	current_time->tv_usec = (nsec % CLOCK_INCREASE_PER_SEC) / 1000;
-
-	return;
-}
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-static status_t APP_SWT_AddTableEntry()
-{
-    status_t result = kStatus_Success;
-    uint32_t entryID;
-
-#if defined(EXAMPLE_SWT_USE_IPF) && EXAMPLE_SWT_USE_IPF
-    netc_tb_ipf_config_t ipfEntryCfg;
-
-    memset(&ipfEntryCfg, 0U, sizeof(netc_tb_ipf_config_t));
-    ipfEntryCfg.keye.srcPortMask = EXAMPLE_SWT_USED_PORT_BITMAP;
-    ipfEntryCfg.cfge.hr          = kNETC_SoftwareDefHR0;
-    ipfEntryCfg.cfge.fltfa       = kNETC_IPFRedirectToMgmtPort;
-
-    /* Frame from used port redirect to management port. */
-    for (uint32_t i = 0; i < EXAMPLE_SWT_MAX_PORT_NUM; i++)
-    {
-        /* Only check the enabled port. */
-        if (((1U << i) & EXAMPLE_SWT_USED_PORT_BITMAP) == 0U)
-        {
-            continue;
-        }
-
-        ipfEntryCfg.keye.srcPort = i;
-        result                   = SWT_RxIPFAddTableEntry(&if_port.g_swt_handle, &ipfEntryCfg, &entryID);
-        if ((kStatus_Success != result) && (entryID != 0xFFFFFFFF))
-        {
-            PRINTF("\r\n%s: %d, Failed to add IPF table!, result = %u\r\n, entryID = %u", __func__, __LINE__, result,
-                   entryID);
-            return kStatus_Fail;
-        }
-    }
-#else
-    /* Set FDB table, input frame only forwards to pseudo MAC port. */
-    netc_tb_fdb_config_t fdbEntryCfg = {
-        .keye.fid = FRAME_FID, .cfge.portBitmap = (1U << EXAMPLE_SWT_PSEUDO_PORT), .cfge.dynamic = 1};
-    memset(&fdbEntryCfg.keye.macAddr[0], 0xFF, 6U);
-    result = SWT_BridgeAddFDBTableEntry(&if_port.g_swt_handle, &fdbEntryCfg, &entryID);
-    if ((kStatus_Success != result) || (0xFFFFFFFFU == entryID))
-    {
-        PRINTF("\r\n%s: %d, Failed to add FDB table!, result = %d, entryID = %d\r\n", __func__, __LINE__, result,
-               entryID);
-        return kStatus_Fail;
-    }
-#endif
-
-    return result;
-}
-#endif
-
-static netc_rx_bdr_config_t rxBdrConfig = {0};
-static netc_tx_bdr_config_t txBdrConfig = {0};
-static netc_bdr_config_t bdrConfig;
-static netc_msix_entry_t msixEntry[2];
-static ep_config_t ep_config;
-
-/* OSHW: register enet port to SOEM stack */
-#if defined(EXAMPLE_EP_NUM) && EXAMPLE_EP_NUM
-static int if_port_init(void)
-{
-	struct soem_if_port soem_port;
-
-    bdrConfig.rxBdrConfig = &rxBdrConfig;
-	bdrConfig.txBdrConfig = &txBdrConfig;
-    uint32_t msgAddr;
-
-    PRINTF("\r\nNETC EP frame loopback example start.\r\n");
-
-    /* MSIX and interrupt configuration. */
-    MSGINTR_Init(MSGINTR1, &msgintrCallback);
-    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR1, 0);
-    msixEntry[0].control = kNETC_MsixIntrMaskBit;
-    msixEntry[0].msgAddr = msgAddr;
-    msixEntry[0].msgData = TX_INTR_MSG_DATA;
-    msixEntry[1].control = kNETC_MsixIntrMaskBit;
-    msixEntry[1].msgAddr = msgAddr;
-    msixEntry[1].msgData = RX_INTR_MSG_DATA;
-
-    /* BD ring configuration. */
-    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
-    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
-    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
-    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
-    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
-    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
-    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
-    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
-    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
-
-    bdrConfig.txBdrConfig[0].bdArray      = &g_txBuffDescrip[0][0];
-    bdrConfig.txBdrConfig[0].len          = EP_TXBD_NUM;
-    bdrConfig.txBdrConfig[0].dirtyArray   = &g_txDirty[0][0];
-    bdrConfig.txBdrConfig[0].msixEntryIdx = TX_MSIX_ENTRY_IDX;
-    bdrConfig.txBdrConfig[0].enIntr       = true;
-
-    /* Endpoint configuration. */
-    (void)EP_GetDefaultConfig(&ep_config);
-    ep_config.si                    = KNETC_EP_CONFIG_SI;
-    ep_config.siConfig.txRingUse    = 1;
-    ep_config.siConfig.rxRingUse    = 1;
-    //ep_config.reclaimCallback       = ReclaimCallback;
-    ep_config.msixEntry             = &msixEntry[0];
-    ep_config.entryNum              = 2;
-    ep_config.port.ethMac.miiMode   = KNETC_HW_MII_MODE;
-    ep_config.port.ethMac.miiSpeed  = kNETC_MiiSpeed100M;
-    ep_config.port.ethMac.miiDuplex = kNETC_MiiFullDuplex;
-#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
-    ep_config.rxCacheMaintain = true;
-    ep_config.txCacheMaintain = true;
-#endif
-    
-	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
-    {
-        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
-        {
-            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
-        }
-    }
-	if_port.ep_config = &ep_config;
-	if_port.bdrConfig = &bdrConfig;
-	if_port.g_txFrame = g_txFrame;
-	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
-	strncpy(soem_port.dev_name, "net_ep", SOEM_DEV_NAME_MAXLEN);
-	soem_port.port_init = netc_ep_init;
-	soem_port.port_send = netc_ep_send;
-	soem_port.port_recv = netc_ep_recv;
-	soem_port.port_close = netc_ep_close;
-	soem_port.port_link_status= netc_ep_link_status;
-	soem_port.port_pri = &if_port;
-    return register_soem_port(&soem_port);
-}
-#endif
-
-#if !(defined(EXAMPLE_NETC_HAS_NO_SWITCH) && EXAMPLE_NETC_HAS_NO_SWITCH)
-static int if_port_swt_init(void)
-{
-	struct soem_if_port soem_port;
-    bdrConfig.rxBdrConfig = &rxBdrConfig;
-	bdrConfig.txBdrConfig = &txBdrConfig;
-    uint32_t msgAddr;
-
-    PRINTF("\r\nNETC swtich frame loopback example start.\r\n");
-
-    /* MSIX and interrupt configuration. */
-    MSGINTR_Init(MSGINTR, &msgintrCallback);
-    msgAddr              = MSGINTR_GetIntrSelectAddr(MSGINTR, 0);
-    msixEntry[0].control = kNETC_MsixIntrMaskBit;
-    msixEntry[0].msgAddr = msgAddr;
-    msixEntry[0].msgData = TX_INTR_MSG_DATA;
-    msixEntry[1].control = kNETC_MsixIntrMaskBit;
-    msixEntry[1].msgAddr = msgAddr;
-    msixEntry[1].msgData = RX_INTR_MSG_DATA;
-
-    /* BD ring configuration. */
-    bdrConfig.rxBdrConfig[0].bdArray       = &g_rxBuffDescrip[0][0];
-    bdrConfig.rxBdrConfig[0].len           = EP_RXBD_NUM;
-    bdrConfig.rxBdrConfig[0].buffAddrArray = &rxBuffAddrArray[0][0];
-    bdrConfig.rxBdrConfig[0].buffSize      = EP_RXBUFF_SIZE_ALIGN;
-    bdrConfig.rxBdrConfig[0].msixEntryIdx  = RX_MSIX_ENTRY_IDX;
-    bdrConfig.rxBdrConfig[0].extendDescEn  = false;
-    bdrConfig.rxBdrConfig[0].enThresIntr   = true;
-    bdrConfig.rxBdrConfig[0].enCoalIntr    = true;
-    bdrConfig.rxBdrConfig[0].intrThreshold = 1;
-
-    /* Endpoint configuration. */
-    (void)EP_GetDefaultConfig(&ep_config);
-    ep_config.si                    = EXAMPLE_SWT_SI;
-    ep_config.siConfig.txRingUse    = 1;
-    ep_config.siConfig.rxRingUse    = 1;
-    //ep_config.reclaimCallback       = ReclaimCallback;
-    ep_config.msixEntry             = &msixEntry[0];
-    ep_config.entryNum              = 2;
-#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
-    ep_config.rxCacheMaintain = true;
-    ep_config.txCacheMaintain = true;
-#endif
-
-    SWT_GetDefaultConfig(&g_swt_config);
-
-    for (int i = 0; i < EXAMPLE_SWT_MAX_PORT_NUM; i++)
-    {
-        g_swt_config.ports[i].ethMac.miiMode   = KNETC_HW_MII_MODE;
-        g_swt_config.ports[i].ethMac.miiSpeed  = kNETC_MiiSpeed100M;
-        g_swt_config.ports[i].ethMac.miiDuplex = kNETC_MiiFullDuplex;
-    }
-
-    /* Wait a moment for PHY status to be stable. */
-    SDK_DelayAtLeastUs(PHY_STABILITY_DELAY_US, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
-
-    g_swt_config.bridgeCfg.dVFCfg.portMembership = (1U << EXAMPLE_SWT_PSEUDO_PORT) | EXAMPLE_SWT_USED_PORT_BITMAP;
-#if defined(EXAMPLE_SWT_USE_IPF) && EXAMPLE_SWT_USE_IPF
-    g_swt_config.ports[0].commonCfg.ipfCfg.enIPFTable = true;
-    g_swt_config.ports[2].commonCfg.ipfCfg.enIPFTable = true;
-#else
-    g_swt_config.bridgeCfg.dVFCfg.enUseFilterID = true;
-    g_swt_config.bridgeCfg.dVFCfg.filterID      = FRAME_FID;
-    g_swt_config.bridgeCfg.dVFCfg.mfo           = kNETC_FDBLookUpWithDiscard;
-    g_swt_config.bridgeCfg.dVFCfg.mlo           = kNETC_DisableMACLearn;
-#endif
-
-    g_swt_config.cmdRingUse            = 1U;
-    g_swt_config.cmdBdrCfg[0].bdBase   = &g_cmdBuffDescrip[0];
-    g_swt_config.cmdBdrCfg[0].bdLength = 8U;
-
-    /* Configure switch transfer resource. */
-    swtTxRxConfig.enUseMgmtRxBdRing            = false;
-    swtTxRxConfig.enUseMgmtTxBdRing            = true;
-    swtTxRxConfig.mgmtTxBdrConfig.bdArray      = &g_mgmtTxBuffDescrip[0];
-    swtTxRxConfig.mgmtTxBdrConfig.len          = EP_TXBD_NUM;
-    swtTxRxConfig.mgmtTxBdrConfig.dirtyArray   = &g_mgmtTxDirty[0];
-    swtTxRxConfig.mgmtTxBdrConfig.msixEntryIdx = TX_MSIX_ENTRY_IDX;
-    swtTxRxConfig.mgmtTxBdrConfig.enIntr       = true;
-    swtTxRxConfig.reclaimCallback              = APP_SwtReclaimCallback;
-#ifdef EXAMPLE_ENABLE_CACHE_MAINTAIN
-    swtTxRxConfig.rxCacheMaintain = true;
-    swtTxRxConfig.txCacheMaintain = true;
-#endif
-
-	for (uint8_t ring = 0U; ring < EP_RING_NUM; ring++)
-    {
-        for (uint8_t index = 0U; index < EP_RXBD_NUM; index++)
-        {
-            rxBuffAddrArray[ring][index] = (uint64_t)(uintptr_t)&g_rxDataBuff[ring][index];
-        }
-    }
-	if_port.ep_config = &ep_config;
-    if_port.swt_config = &g_swt_config;
-	if_port.swtTxRxConfig = &swtTxRxConfig;
-    if_port.bdrConfig = &bdrConfig;
-	if_port.g_txFrame = g_txFrame;
-	strncpy(soem_port.ifname, SOEM_PORT_NAME, SOEM_IF_NAME_MAXLEN);
-	strncpy(soem_port.dev_name, "netc_swt", SOEM_DEV_NAME_MAXLEN);
-	soem_port.port_init = netc_swt_init;
-	soem_port.port_send = netc_swt_send;
-	soem_port.port_recv = netc_swt_recv;
-	soem_port.port_close = netc_swt_close;
-	soem_port.port_link_status= netc_swt_link_status;
-	soem_port.port_pri = &if_port;
-    return register_soem_port(&soem_port);
-}
-#endif
-
-void irq_wake_task(void)
-{
-    return;
-}
-
-uint64_t dc_diff_accu = 0;
-int32_t dc_diff_accu_arrary[DC_FILTER_CNT];
-int32_t dc_diff_accu_index = 0;
-void dc_diff_init(int32_t dc_diff_ns)
-{
-	int i;
-	for (i = 0; i < DC_FILTER_CNT; i++) {
-		dc_diff_accu_arrary[i] = dc_diff_ns;
-		dc_diff_accu += dc_diff_ns;
-	}
-}
-int32_t dc_diff_update(int32_t dc_diff_ns)
-{
-	dc_diff_accu += dc_diff_ns;
-	dc_diff_accu -= dc_diff_accu_arrary[dc_diff_accu_index];
-	dc_diff_accu_arrary[dc_diff_accu_index++] = dc_diff_ns;
-	if (dc_diff_accu_index >= DC_FILTER_CNT) {
-		dc_diff_accu_index = 0;
-	}
-	return dc_diff_accu / DC_FILTER_CNT;
-}
-
-#define PID_P  3 / 2
-#define PID_I  3 / 2
-#define PID_D  1 / 5 
-void update_master_clock()
-{
-	int32_t dc_diff_ns_avg;
-    // calc drift (via un-normalised time diff)
-    int32_t delta = dc_diff_ns - prev_dc_diff_ns;
-    prev_dc_diff_ns = dc_diff_ns;
-
-    if (dc_started == 2) {
-		dc_diff_ns_avg = dc_diff_update(dc_diff_ns);
-       dc_adjust_ns = dc_diff_ns * PID_P  + dc_diff_ns_avg * PID_I  + delta * PID_D;
-        if (dc_adjust_ns < -10000) {
-            dc_adjust_ns = -10000;
-        }
-        if (dc_adjust_ns > 10000) {
-            dc_adjust_ns =  10000;
-        }
-		// add cycles adjustment to time base (including a spot adjustment)
-        system_time_offset += dc_adjust_ns;
-    }
-    else {
-		if (dc_started == 0) {
-        	dc_started = (dc_diff_ns != 0);
-			system_time_offset = dc_diff_ns;
-		} else {
-			dc_started = 2;
-			dc_diff_init(dc_diff_ns);
-			system_time_offset += dc_diff_ns / 2;
-		}
-    }
-}
-
 void control_task(char *ifname)
 {
 	int expectedWKC;
-- 
2.43.0

