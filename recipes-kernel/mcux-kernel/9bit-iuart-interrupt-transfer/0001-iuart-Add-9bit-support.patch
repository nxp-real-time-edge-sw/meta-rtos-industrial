From e9e326c25abd9518cca93bb8f1861f59c038dd16 Mon Sep 17 00:00:00 2001
From: Wenbin Song <wenbin.song@nxp.com>
Date: Wed, 24 Aug 2022 21:25:05 +0800
Subject: [PATCH] iuart: Add 9bit support

Signed-off-by: Wenbin Song <wenbin.song@nxp.com>
---
 drivers/iuart/fsl_uart.c |  88 ++++++++++++++++++++++++++++++----
 drivers/iuart/fsl_uart.h | 100 +++++++++++++++++++++++++++++++++++++++
 2 files changed, 180 insertions(+), 8 deletions(-)

diff --git a/drivers/iuart/fsl_uart.c b/drivers/iuart/fsl_uart.c
index fb868272..e7a059af 100644
--- a/drivers/iuart/fsl_uart.c
+++ b/drivers/iuart/fsl_uart.c
@@ -458,6 +458,51 @@ status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcCl
     }
 }
 
+/*!
+ * brief Enable 9-bit RS-485 mode for UART.
+ *
+ * This function set the 9-bit RS-485 mode for UART module. The 9th bit is not used for parity thus can be modified by user.
+ *
+ * param base UART peripheral base address.
+ * param enable true to enable, flase to disable.
+ */
+void UART_Enable9bitRS485Mode(UART_Type *base, bool enable)
+{
+    assert(base != NULL);
+
+    if (enable)
+    {
+        /* Set PREN to enable trasmitting the ninth data bit and set WS for 8bits data word size*/
+        base->UCR2 |= UART_UCR2_WS_MASK | UART_UCR2_PREN_MASK;
+
+		/* set MDEN to enable 9bit RS485 mode. */
+		base->UMCR |= UART_UMCR_MDEN_MASK;
+    }
+    else
+    {
+        /* Clear MDEN. */
+        base->UMCR &= ~UART_UMCR_MDEN_MASK;
+    }
+}
+
+/*!
+ * brief Transmit an address frame in 9-bit data mode.
+ *
+ * param base UART peripheral base address.
+ * param address UART slave address.
+ */
+void UART_Send9bitRS485Address(UART_Type *base, uint8_t address)
+{
+    assert(base != NULL);
+
+    /* Set address mark. */
+    UART_Set9thTransmitBit(base);
+    /* Send address. */
+	UART_WriteBlocking(base, &address, 1);
+    /* Clear address mark for following data transfer. */
+    UART_Clear9thTransmitBit(base);
+}
+
 /*!
  * brief Enables UART interrupts according to the provided mask.
  *
@@ -771,7 +816,8 @@ status_t UART_ReadBlocking(UART_Type *base, uint8_t *data, size_t length)
             if ((base->USR1 & UART_USR1_PARITYERR_MASK) != 0U)
             {
                 UART_ClearStatusFlag(base, (uint32_t)kUART_ParityErrorFlag);
-                status = kStatus_UART_ParityError;
+                if ((UART_UMCR_MDEN_MASK & base->UMCR) == 0U)
+                    status = kStatus_UART_ParityError;
             }
             /* Framing error check for receiving character */
             if ((base->USR1 & UART_USR1_FRAMERR_MASK) != 0U)
@@ -1266,13 +1312,14 @@ void UART_TransferHandleIRQ(UART_Type *base, void *irqHandle)
     {
         /* Write 1 to clear parity error flag. */
         base->USR1 |= UART_USR1_PARITYERR_MASK;
-
-        handle->rxState    = (uint8_t)kUART_RxParityError;
-        handle->rxDataSize = 0U;
-        /* Trigger callback. */
-        if ((handle->callback) != NULL)
-        {
-            handle->callback(base, handle, kStatus_UART_ParityError, handle->userData);
+        if (((UART_UMCR_MDEN_MASK & base->UMCR) == 0U)) {
+             handle->rxState    = (uint8_t)kUART_RxParityError;
+             handle->rxDataSize = 0U;
+             /* Trigger callback. */
+             if ((handle->callback) != NULL)
+             {
+                 handle->callback(base, handle, kStatus_UART_ParityError, handle->userData);
+             }
         }
     }
 
@@ -1293,6 +1340,19 @@ void UART_TransferHandleIRQ(UART_Type *base, void *irqHandle)
     {
         /* Get the size that stored in receive FIFO buffer for this interrupt. */
         count = (uint8_t)((base->UFCR & UART_UFCR_RXTL_MASK) >> UART_UFCR_RXTL_SHIFT);
+        /* If 9bit RS-485 Slave Address was detected*/
+       if ((UART_USR1_SAD_MASK & base->USR1) != 0U)
+       {
+            /* Write 1 to clear SAD interrupt flag */
+            base->USR1 |= UART_USR1_SAD_MASK;
+
+            if ((handle->callback) != NULL)
+            {
+                handle->callback(base, handle, kStatus_UART_RS485SlaveAddressDetected, handle->userData);
+            }
+
+        }
+        /* Get the size that stored in receive FIFO buffer for this interrupt. */
 
         /* If count and handle->rxDataSize are not 0, first save data to handle->rxData. */
         while ((count != 0U) && (handle->rxDataSize != 0U))
@@ -1376,6 +1436,18 @@ void UART_TransferHandleIRQ(UART_Type *base, void *irqHandle)
      */
     if (((UART_USR1_AGTIM_MASK & base->USR1) != 0U) && ((UART_UCR2_ATEN_MASK & base->UCR2) != 0U))
     {
+        /* If 9bit RS-485 Slave Address was detected*/
+        if ((UART_USR1_SAD_MASK & base->USR1) != 0U)
+        {
+            /* Write 1 to clear SAD interrupt flag */
+            base->USR1 |= UART_USR1_SAD_MASK;
+
+            if ((handle->callback) != NULL)
+            {
+                handle->callback(base, handle, kStatus_UART_RS485SlaveAddressDetected, handle->userData);
+            }
+
+        }
         /* If count and handle->rxDataSize are not 0, first save data to handle->rxData. */
         while (((base->USR2 & UART_USR2_RDR_MASK) != 0U) && (handle->rxDataSize != 0U))
         {
diff --git a/drivers/iuart/fsl_uart.h b/drivers/iuart/fsl_uart.h
index 16fce994..f465f194 100644
--- a/drivers/iuart/fsl_uart.h
+++ b/drivers/iuart/fsl_uart.h
@@ -30,6 +30,9 @@
 #define UART_RETRY_TIMES 0U /* Defining to zero means to keep waiting for the flag until it is assert/deassert. */
 #endif
 
+#define RS485_ADDRESS_DETECT_MODE_NORMAL 0
+#define RS485_ADDRESS_DETECT_MODE_AUTOMATIC 1
+
 /*! @brief Error codes for the UART driver. */
 enum
 {
@@ -51,6 +54,7 @@ enum
         MAKE_STATUS(kStatusGroup_IUART, 13), /*!< Baudrate is not support in current clock source */
     kStatus_UART_BreakDetect = MAKE_STATUS(kStatusGroup_IUART, 14), /*!< Receiver detect BREAK signal */
     kStatus_UART_Timeout     = MAKE_STATUS(kStatusGroup_IUART, 15), /*!< UART times out. */
+    kStatus_UART_RS485SlaveAddressDetected   = MAKE_STATUS(kStatusGroup_IUART, 16), /*!< Receiver detect RS485 slave address. */
 };
 
 /*! @brief UART data bits count. */
@@ -358,6 +362,102 @@ void UART_GetDefaultConfig(uart_config_t *config);
  */
 status_t UART_SetBaudRate(UART_Type *base, uint32_t baudRate_Bps, uint32_t srcClock_Hz);
 
+/*!
+ * @brief Enable RS485 9-bit mode for UART.
+ *
+ * This function set the RS485 9-bit mode for UART module.
+ *
+ * @param base UART peripheral base address.
+ * @param enable true to enable, flase to disable.
+ */
+void UART_Enable9bitRS485Mode(UART_Type *base, bool enable);
+
+/*!
+ * @brief Transmit an address frame in 9-bit data mode.
+ *
+ * @param base UART peripheral base address.
+ * @param address UART slave address.
+ */
+void UART_Send9bitRS485Address(UART_Type *base, uint8_t address);
+
+
+/*!
+ * @brief Set the RS-485 slave address character.
+ *
+ * This function configures the address for UART module that works as slave in 9-bit RS-485 mode.
+ *
+ * @param base UART peripheral base address.
+ * @param address RS485 slave address character.
+ */
+static inline void UART_SetMatchAddress(UART_Type *base, uint8_t address)
+{
+    /* Configure RS485 slave address character. */
+    base->UMCR &= ~UART_UMCR_SLADDR_MASK;
+	base->UMCR |= UART_UMCR_SLADDR(address);
+}
+
+/*!
+ * @brief Set RS485 Slave Address Detect Mode.
+ * Mode:
+ *    Normal   - In this mode, once the UART has detected a 9th bit is equal to '1',
+ *               it will always save the subsequent frames to RxFIFO. So the software
+ *               must decide whether the address and data in RxFIFO are needed or not.
+ *    Automtic - In this mode, If the address byte is received and it does not match
+ *               SLADDR character, the receiver will discard the address byte and
+*                subsequent data byte.If the address byte again matches SLADDR character,
+ *               the receiver will put this address byte and subsequent data byte in the
+ *               RxFIFO along with their 9th bit.
+ * @param base UART peripheral base address.
+ * @param mode RS485 Slave Address Detect Mode Selection.
+ *
+ *    RS485_ADDRESS_DETECT_MODE_NORMAL for Normal mode
+ *    RS485_ADDRESS_DETECT_MODE_AUTOMATIC for Automtic mode.
+ */
+static inline void UART_SetRS485AddressDetectMode(UART_Type *base, uint8_t mode)
+{
+    if (mode == RS485_ADDRESS_DETECT_MODE_NORMAL)
+        base->UMCR &= ~UART_UMCR_SLAM_MASK;
+    else
+        base->UMCR |= UART_UMCR_SLAM_MASK;
+}
+
+/*!
+ * @brief Set RS-485 Slave Address Detected Interrupt Enable.
+ *
+ * @param base UART peripheral base address.
+ * @param enable true to enable, flase to disable.
+ */
+static inline void UART_SetRS485AddressDetectInterrput(UART_Type *base, bool enable)
+{
+    if (enable)
+        base->UMCR |= UART_UMCR_SADEN_MASK;
+    else
+        base->UMCR &= ~UART_UMCR_SADEN_MASK;
+}
+
+/*!
+ * @brief Set UART 9th transmit bit.
+ *
+ * @param base UART peripheral base address.
+ */
+static inline void UART_Set9thTransmitBit(UART_Type *base)
+{
+    base->UMCR |= UART_UMCR_TXB8_MASK;
+}
+
+
+
+/*!
+ * @brief Clear UART 9th transmit bit.
+ *
+ * @param base UART peripheral base address.
+ */
+static inline void UART_Clear9thTransmitBit(UART_Type *base)
+{
+    base->UMCR &= ~UART_UMCR_TXB8_MASK;
+}
+
+
 /*!
  * @brief This function is used to Enable the UART Module.
  *
-- 
2.17.1

