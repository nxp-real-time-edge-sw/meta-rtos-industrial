From 09c9ea99d0ff5034eb34bb4d57a111d1c21d5076 Mon Sep 17 00:00:00 2001
From: qizhang <jony.zhang@nxp.com>
Date: Wed, 8 Mar 2023 23:47:49 +0800
Subject: [PATCH] SOEM: add freertos_soem_gpio_pulse example to evkmimx8mm
 platform

Signed-off-by: Wenbin Song <wenbin.song@nxp.com>
Signed-off-by: qizhang <jony.zhang@nxp.com>
---
 .../freertos_soem_gpio_pulse/FreeRTOSConfig.h | 155 +++++
 .../armgcc/CMakeLists.txt                     | 117 ++++
 .../armgcc/MIMX8MM6xxxxx_cm4_ddr_ram.ld       | 228 +++++++
 .../armgcc/MIMX8MM6xxxxx_cm4_flash.ld         | 228 +++++++
 .../armgcc/MIMX8MM6xxxxx_cm4_ram.ld           | 227 +++++++
 .../armgcc/build_all.bat                      |  43 ++
 .../armgcc/build_all.sh                       |  43 ++
 .../armgcc/build_ddr_debug.bat                |   6 +
 .../armgcc/build_ddr_debug.sh                 |   7 +
 .../armgcc/build_ddr_release.bat              |   6 +
 .../armgcc/build_ddr_release.sh               |   7 +
 .../armgcc/build_debug.bat                    |   6 +
 .../armgcc/build_debug.sh                     |   7 +
 .../armgcc/build_flash_debug.bat              |   6 +
 .../armgcc/build_flash_debug.sh               |   7 +
 .../armgcc/build_flash_release.bat            |   6 +
 .../armgcc/build_flash_release.sh             |   7 +
 .../armgcc/build_release.bat                  |   6 +
 .../armgcc/build_release.sh                   |   7 +
 .../freertos_soem_gpio_pulse/armgcc/clean.bat |   3 +
 .../freertos_soem_gpio_pulse/armgcc/clean.sh  |   3 +
 .../armgcc/config.cmake                       |   5 +
 .../armgcc/flags.cmake                        | 566 ++++++++++++++++++
 .../freertos_soem_gpio_pulse/pin_mux.c        |  98 +++
 .../freertos_soem_gpio_pulse/pin_mux.h        |  54 ++
 .../freertos_soem_gpio_pulse/readme.txt       |  77 +++
 .../freertos_soem_gpio_pulse/soem_config.h    |  48 ++
 .../soem_gpio_pulse.c                         | 394 ++++++++++++
 28 files changed, 2367 insertions(+)
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/FreeRTOSConfig.h
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/CMakeLists.txt
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_ddr_ram.ld
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_flash.ld
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_ram.ld
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_all.bat
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_all.sh
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_debug.bat
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_debug.sh
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_release.bat
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_release.sh
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_debug.bat
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_debug.sh
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_debug.bat
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_debug.sh
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_release.bat
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_release.sh
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_release.bat
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_release.sh
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/clean.bat
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/clean.sh
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/config.cmake
 create mode 100755 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/flags.cmake
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/pin_mux.c
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/pin_mux.h
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/readme.txt
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/soem_config.h
 create mode 100644 evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/soem_gpio_pulse.c

diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/FreeRTOSConfig.h b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/FreeRTOSConfig.h
new file mode 100644
index 000000000..710b5bdf0
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/FreeRTOSConfig.h
@@ -0,0 +1,155 @@
+/*
+FreeRTOS Kernel V10.3.0
+Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy of
+this software and associated documentation files (the "Software"), to deal in
+the Software without restriction, including without limitation the rights to
+use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
+the Software, and to permit persons to whom the Software is furnished to do so,
+subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
+FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
+COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
+IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+ http://aws.amazon.com/freertos
+ http://www.FreeRTOS.org
+*/
+
+#ifndef FREERTOS_CONFIG_H
+#define FREERTOS_CONFIG_H
+
+/*-----------------------------------------------------------
+ * Application specific definitions.
+ *
+ * These definitions should be adjusted for your particular hardware and
+ * application requirements.
+ *
+ * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
+ * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
+ *
+ * See http://www.freertos.org/a00110.html.
+ *----------------------------------------------------------*/
+
+#define configUSE_PREEMPTION                    1
+#define configUSE_TICKLESS_IDLE                 0
+#define configCPU_CLOCK_HZ                      (SystemCoreClock)
+#define configTICK_RATE_HZ                      ((TickType_t)200)
+#define configMAX_PRIORITIES                    5
+#define configMINIMAL_STACK_SIZE                ((unsigned short)90)
+#define configMAX_TASK_NAME_LEN                 20
+#define configUSE_16_BIT_TICKS                  0
+#define configIDLE_SHOULD_YIELD                 1
+#define configUSE_TASK_NOTIFICATIONS            1
+#define configUSE_MUTEXES                       1
+#define configUSE_RECURSIVE_MUTEXES             1
+#define configUSE_COUNTING_SEMAPHORES           1
+#define configUSE_ALTERNATIVE_API               0 /* Deprecated! */
+#define configQUEUE_REGISTRY_SIZE               8
+#define configUSE_QUEUE_SETS                    0
+#define configUSE_TIME_SLICING                  0
+#define configUSE_NEWLIB_REENTRANT              0
+#define configENABLE_BACKWARD_COMPATIBILITY     0
+#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 5
+
+/* Used memory allocation (heap_x.c) */
+#define configFRTOS_MEMORY_SCHEME               1
+/* Tasks.c additions (e.g. Thread Aware Debug capability) */
+#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0
+
+/* Memory allocation related definitions. */
+#define configSUPPORT_STATIC_ALLOCATION         1
+#define configSUPPORT_DYNAMIC_ALLOCATION        0
+#define configTOTAL_HEAP_SIZE                   ((size_t)(10 * 1024))
+#define configAPPLICATION_ALLOCATED_HEAP        0
+
+/* Hook function related definitions. */
+#define configUSE_IDLE_HOOK                     0
+#define configUSE_TICK_HOOK                     0
+#define configCHECK_FOR_STACK_OVERFLOW          0
+#define configUSE_MALLOC_FAILED_HOOK            0
+#define configUSE_DAEMON_TASK_STARTUP_HOOK      0
+
+/* Run time and task stats gathering related definitions. */
+#define configGENERATE_RUN_TIME_STATS           0
+#define configUSE_TRACE_FACILITY                0
+#define configUSE_STATS_FORMATTING_FUNCTIONS    0
+
+/* Task aware debugging. */
+#define configRECORD_STACK_HIGH_ADDRESS         0
+
+/* Co-routine related definitions. */
+#define configUSE_CO_ROUTINES                   0
+#define configMAX_CO_ROUTINE_PRIORITIES         0
+
+/* Software timer related definitions. */
+#define configUSE_TIMERS                        1
+#define configTIMER_TASK_PRIORITY               (configMAX_PRIORITIES - 1)
+#define configTIMER_QUEUE_LENGTH                10
+#define configTIMER_TASK_STACK_DEPTH            (configMINIMAL_STACK_SIZE * 2)
+
+/* Define to trap errors during development. */
+#define configASSERT(x) if(( x) == 0) {taskDISABLE_INTERRUPTS(); for (;;);}
+
+/* Optional functions - most linkers will remove unused functions anyway. */
+#define INCLUDE_vTaskPrioritySet                1
+#define INCLUDE_uxTaskPriorityGet               1
+#define INCLUDE_vTaskDelete                     1
+#define INCLUDE_vTaskSuspend                    1
+#define INCLUDE_vTaskDelayUntil                 1
+#define INCLUDE_vTaskDelay                      1
+#define INCLUDE_xTaskGetSchedulerState          0
+#define INCLUDE_xTaskGetCurrentTaskHandle       0
+#define INCLUDE_uxTaskGetStackHighWaterMark     0
+#define INCLUDE_xTaskGetIdleTaskHandle          0
+#define INCLUDE_eTaskGetState                   1
+#define INCLUDE_xTimerPendFunctionCall          1
+#define INCLUDE_xTaskAbortDelay                 0
+#define INCLUDE_xTaskGetHandle                  0
+#define INCLUDE_xTaskResumeFromISR              1
+
+#if defined(__ICCARM__)||defined(__CC_ARM)||defined(__GNUC__)
+    /* Clock manager provides in this variable system core clock frequency */
+    #include <stdint.h>
+    extern uint32_t SystemCoreClock;
+#endif
+
+/* Interrupt nesting behaviour configuration. Cortex-M specific. */
+#ifdef __NVIC_PRIO_BITS
+/* __BVIC_PRIO_BITS will be specified when CMSIS is being used. */
+#define configPRIO_BITS __NVIC_PRIO_BITS
+#else
+#define configPRIO_BITS 4 /* 15 priority levels */
+#endif
+
+/* The lowest interrupt priority that can be used in a call to a "set priority"
+function. */
+#define configLIBRARY_LOWEST_INTERRUPT_PRIORITY ((1U << (configPRIO_BITS)) - 1)
+
+/* The highest interrupt priority that can be used by any interrupt service
+routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL
+INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER
+PRIORITY THAN THIS! (higher priorities are lower numeric values. */
+#define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 2
+
+/* Interrupt priorities used by the kernel port layer itself.  These are generic
+to all Cortex-M ports, and do not rely on any particular library functions. */
+#define configKERNEL_INTERRUPT_PRIORITY (configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 - configPRIO_BITS))
+/* !!!! configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero !!!!
+See http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. */
+#define configMAX_SYSCALL_INTERRUPT_PRIORITY (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 - configPRIO_BITS))
+
+/* Definitions that map the FreeRTOS port interrupt handlers to their CMSIS
+standard names. */
+#define vPortSVCHandler SVC_Handler
+#define xPortPendSVHandler PendSV_Handler
+#define xPortSysTickHandler SysTick_Handler
+
+#endif /* FREERTOS_CONFIG_H */
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/CMakeLists.txt b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/CMakeLists.txt
new file mode 100644
index 000000000..99da5b68c
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/CMakeLists.txt
@@ -0,0 +1,117 @@
+# CROSS COMPILER SETTING
+SET(CMAKE_SYSTEM_NAME Generic)
+CMAKE_MINIMUM_REQUIRED (VERSION 3.1.1)
+
+# THE VERSION NUMBER
+SET (Tutorial_VERSION_MAJOR 1)
+SET (Tutorial_VERSION_MINOR 0)
+
+# ENABLE ASM
+ENABLE_LANGUAGE(ASM)
+
+SET(CMAKE_STATIC_LIBRARY_PREFIX)
+SET(CMAKE_STATIC_LIBRARY_SUFFIX)
+
+SET(CMAKE_EXECUTABLE_LIBRARY_PREFIX)
+SET(CMAKE_EXECUTABLE_LIBRARY_SUFFIX)
+
+# CURRENT DIRECTORY
+SET(ProjDirPath ${CMAKE_CURRENT_SOURCE_DIR})
+
+SET(EXECUTABLE_OUTPUT_PATH ${ProjDirPath}/${CMAKE_BUILD_TYPE})
+SET(LIBRARY_OUTPUT_PATH ${ProjDirPath}/${CMAKE_BUILD_TYPE})
+
+
+project(soem_gpio_pulse)
+
+set(MCUX_SDK_PROJECT_NAME soem_gpio_pulse.elf)
+
+include(${ProjDirPath}/flags.cmake)
+
+include(${ProjDirPath}/config.cmake)
+
+add_executable(${MCUX_SDK_PROJECT_NAME} 
+"${ProjDirPath}/../soem_gpio_pulse.c"
+"${ProjDirPath}/../pin_mux.c"
+"${ProjDirPath}/../pin_mux.h"
+"${ProjDirPath}/../FreeRTOSConfig.h"
+"${ProjDirPath}/../../../../../core/boards/evkmimx8mm/board.c"
+"${ProjDirPath}/../../../../../core/boards/evkmimx8mm/board.h"
+"${ProjDirPath}/../../../../../core/boards/evkmimx8mm/clock_config.c"
+"${ProjDirPath}/../../../../../core/boards/evkmimx8mm/clock_config.h"
+)
+
+target_include_directories(${MCUX_SDK_PROJECT_NAME} PRIVATE
+    ${ProjDirPath}/..
+	${ProjDirPath}/../../../../../core/boards/evkmimx8mm/
+)
+
+set(CMAKE_MODULE_PATH
+    ${ProjDirPath}/../../../../../core/
+)
+
+#Include Entry cmake component
+include(all_devices)
+
+# include modules
+include(driver_mdio-enet)
+
+include(driver_phy-device-ar8031)
+
+include(utility_assert_lite)
+
+include(driver_clock)
+
+include(driver_enet)
+
+include(driver_common)
+
+include(driver_rdc)
+
+include(device_CMSIS)
+
+include(component_iuart_adapter)
+
+include(component_lists)
+
+include(driver_iuart)
+
+include(device_startup)
+
+include(driver_igpio)
+
+include(driver_mdio-common)
+
+include(CMSIS_Include_core_cm)
+
+include(driver_phy-common)
+
+include(CMSIS_Include_core_cm)
+
+include(middleware_freertos-kernel_MIMX8MM6)
+
+include(middleware_freertos-kernel_extension)
+
+include(utilities_misc_utilities)
+
+include(device_system)
+
+include(driver_gpt)
+
+include(component_soem)
+
+TARGET_LINK_LIBRARIES(${MCUX_SDK_PROJECT_NAME} PRIVATE -Wl,--start-group)
+
+target_link_libraries(${MCUX_SDK_PROJECT_NAME} PRIVATE m)
+
+target_link_libraries(${MCUX_SDK_PROJECT_NAME} PRIVATE c)
+
+target_link_libraries(${MCUX_SDK_PROJECT_NAME} PRIVATE gcc)
+
+target_link_libraries(${MCUX_SDK_PROJECT_NAME} PRIVATE nosys)
+
+TARGET_LINK_LIBRARIES(${MCUX_SDK_PROJECT_NAME} PRIVATE -Wl,--end-group)
+
+ADD_CUSTOM_COMMAND(TARGET ${MCUX_SDK_PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_OBJCOPY}
+-Obinary ${EXECUTABLE_OUTPUT_PATH}/${MCUX_SDK_PROJECT_NAME} ${EXECUTABLE_OUTPUT_PATH}/soem_gpio_pulse.bin)
+
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_ddr_ram.ld b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_ddr_ram.ld
new file mode 100644
index 000000000..13a695433
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_ddr_ram.ld
@@ -0,0 +1,228 @@
+/*
+** ###################################################################
+**     Processors:          MIMX8MM6CVTKZ
+**                          MIMX8MM6DVTLZ
+**
+**     Compiler:            GNU C Compiler
+**     Reference manual:    MX8MMRM, Rev. 0, 02/2019
+**     Version:             rev. 4.0, 2019-02-18
+**     Build:               b200330
+**
+**     Abstract:
+**         Linker file for the GNU C Compiler
+**
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2020 NXP
+**     All rights reserved.
+**
+**     SPDX-License-Identifier: BSD-3-Clause
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+** ###################################################################
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+HEAP_SIZE  = DEFINED(__heap_size__)  ? __heap_size__  : 0x0400;
+STACK_SIZE = DEFINED(__stack_size__) ? __stack_size__ : 0x0400;
+
+/* Specify the memory areas */
+MEMORY
+{
+  m_interrupts          (RX)  : ORIGIN = 0x80000000, LENGTH = 0x00000240
+  m_text                (RX)  : ORIGIN = 0x80000240, LENGTH = 0x001FFDC0
+  m_data                (RW)  : ORIGIN = 0x80200000, LENGTH = 0x00200000
+  m_data2               (RW)  : ORIGIN = 0x80400000, LENGTH = 0x00C00000
+}
+
+/* Define output sections */
+SECTIONS
+{
+/* The startup code goes first into internal RAM */
+  .interrupts :
+  {
+    __VECTOR_TABLE = .;
+    __Vectors = .;
+    . = ALIGN(4);
+    KEEP(*(.isr_vector))     /* Startup code */
+    . = ALIGN(4);
+  } > m_interrupts
+
+  .resource_table :
+  {
+    . = ALIGN(8);
+    KEEP(*(.resource_table)) /* Resource table */
+    . = ALIGN(8);
+  } > m_text
+
+  /* The program code and other data goes into internal RAM */
+  .text :
+  {
+    . = ALIGN(4);
+    *(.text)                 /* .text sections (code) */
+    *(.text*)                /* .text* sections (code) */
+    *(.rodata)               /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)              /* .rodata* sections (constants, strings, etc.) */
+    *(.glue_7)               /* glue arm to thumb code */
+    *(.glue_7t)              /* glue thumb to arm code */
+    *(.eh_frame)
+    KEEP (*(.init))
+    KEEP (*(.fini))
+    . = ALIGN(4);
+  } > m_text
+
+  .ARM.extab :
+  {
+    *(.ARM.extab* .gnu.linkonce.armextab.*)
+  } > m_text
+
+  .ARM :
+  {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } > m_text
+
+ .ctors :
+  {
+    __CTOR_LIST__ = .;
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    __CTOR_END__ = .;
+  } > m_text
+
+  .dtors :
+  {
+    __DTOR_LIST__ = .;
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    __DTOR_END__ = .;
+  } > m_text
+
+  .preinit_array :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } > m_text
+
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } > m_text
+
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } > m_text
+
+  __etext = .;    /* define a global symbol at end of code */
+  __DATA_ROM = .; /* Symbol is used by startup for data initialization */
+
+  .data : AT(__DATA_ROM)
+  {
+    . = ALIGN(4);
+    __DATA_RAM = .;
+    __data_start__ = .;      /* create a global symbol at data start */
+    *(.data)                 /* .data sections */
+    *(.data*)                /* .data* sections */
+    KEEP(*(.jcr*))
+    . = ALIGN(4);
+    __data_end__ = .;        /* define a global symbol at data end */
+  } > m_data
+
+  __CACHE_REGION_START = ORIGIN(m_interrupts);
+  __CACHE_REGION_SIZE  = LENGTH(m_interrupts) + LENGTH(m_text) + LENGTH(m_data);
+
+  __NDATA_ROM = __DATA_ROM + SIZEOF(.data); /* Symbol is used by startup for ncache data initialization */
+
+  .ncache.init : AT(__NDATA_ROM)
+  {
+    __noncachedata_start__ = .;   /* create a global symbol at ncache data start */
+    *(NonCacheable.init)
+    . = ALIGN(4);
+    __noncachedata_init_end__ = .;   /* create a global symbol at initialized ncache data end */
+  } > m_data2
+
+  . = __noncachedata_init_end__;
+  .ncache :
+  {
+    *(NonCacheable)
+    . = ALIGN(4);
+    __noncachedata_end__ = .;     /* define a global symbol at ncache data end */
+  } > m_data2
+
+  __DATA_END = __DATA_ROM + (__data_end__ - __data_start__);
+  text_end = ORIGIN(m_text) + LENGTH(m_text);
+  ASSERT(__DATA_END <= text_end, "region m_text overflowed with text and data")
+
+  /* Uninitialized data section */
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss section */
+    . = ALIGN(4);
+    __START_BSS = .;
+    __bss_start__ = .;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    . = ALIGN(4);
+    __bss_end__ = .;
+    __END_BSS = .;
+  } > m_data
+
+  .heap :
+  {
+    . = ALIGN(8);
+    __end__ = .;
+    PROVIDE(end = .);
+    __HeapBase = .;
+    . += HEAP_SIZE;
+    __HeapLimit = .;
+    __heap_limit = .; /* Add for _sbrk */
+  } > m_data
+
+  .stack :
+  {
+    . = ALIGN(8);
+    . += STACK_SIZE;
+  } > m_data
+
+  /* Initializes stack on the end of block */
+  __StackTop   = ORIGIN(m_data) + LENGTH(m_data);
+  __StackLimit = __StackTop - STACK_SIZE;
+  PROVIDE(__stack = __StackTop);
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+
+  ASSERT(__StackLimit >= __HeapLimit, "region m_data overflowed with stack and heap")
+}
+
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_flash.ld b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_flash.ld
new file mode 100644
index 000000000..6e69dec2d
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_flash.ld
@@ -0,0 +1,228 @@
+/*
+** ###################################################################
+**     Processors:          MIMX8MM6CVTKZ
+**                          MIMX8MM6DVTLZ
+**
+**     Compiler:            GNU C Compiler
+**     Reference manual:    MX8MMRM, Rev. 0, 02/2019
+**     Version:             rev. 4.0, 2019-02-18
+**     Build:               b200330
+**
+**     Abstract:
+**         Linker file for the GNU C Compiler
+**
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2020 NXP
+**     All rights reserved.
+**
+**     SPDX-License-Identifier: BSD-3-Clause
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+** ###################################################################
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+HEAP_SIZE  = DEFINED(__heap_size__)  ? __heap_size__  : 0x0400;
+STACK_SIZE = DEFINED(__stack_size__) ? __stack_size__ : 0x0400;
+
+/* Specify the memory areas */
+MEMORY
+{
+  m_interrupts          (RX)  : ORIGIN = 0x08000000, LENGTH = 0x00000A00
+  m_text                (RX)  : ORIGIN = 0x08000A00, LENGTH = 0x000FF600
+  m_data                (RW)  : ORIGIN = 0x20000000, LENGTH = 0x00020000
+  m_data2               (RW)  : ORIGIN = 0x80000000, LENGTH = 0x01000000
+  m_tcml                (RW)  : ORIGIN = 0x1FFE0020, LENGTH = 0x0001FFE0
+}
+
+/* Define output sections */
+SECTIONS
+{
+/* The startup code goes first into internal RAM */
+  .interrupts :
+  {
+    __VECTOR_TABLE = .;
+    __Vectors = .;
+    . = ALIGN(4);
+    KEEP(*(.isr_vector))     /* Startup code */
+    . = ALIGN(4);
+  } > m_interrupts
+
+  .resource_table :
+  {
+    . = ALIGN(8);
+    KEEP(*(.resource_table)) /* Resource table */
+    . = ALIGN(8);
+  } > m_text
+
+  /* The program code and other data goes into internal RAM */
+  .text :
+  {
+    . = ALIGN(4);
+    *(.text)                 /* .text sections (code) */
+    *(.text*)                /* .text* sections (code) */
+    *(.rodata)               /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)              /* .rodata* sections (constants, strings, etc.) */
+    *(.glue_7)               /* glue arm to thumb code */
+    *(.glue_7t)              /* glue thumb to arm code */
+    *(.eh_frame)
+    KEEP (*(.init))
+    KEEP (*(.fini))
+    . = ALIGN(4);
+  } > m_text
+
+  .ARM.extab :
+  {
+    *(.ARM.extab* .gnu.linkonce.armextab.*)
+  } > m_text
+
+  .ARM :
+  {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } > m_text
+
+ .ctors :
+  {
+    __CTOR_LIST__ = .;
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    __CTOR_END__ = .;
+  } > m_text
+
+  .dtors :
+  {
+    __DTOR_LIST__ = .;
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    __DTOR_END__ = .;
+  } > m_text
+
+  .preinit_array :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } > m_text
+
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } > m_text
+
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } > m_text
+
+  __etext = .;    /* define a global symbol at end of code */
+  __DATA_ROM = .; /* Symbol is used by startup for data initialization */
+
+  .data : AT(__DATA_ROM)
+  {
+    . = ALIGN(4);
+    __DATA_RAM = .;
+    __data_start__ = .;      /* create a global symbol at data start */
+    *(.data)                 /* .data sections */
+    *(.data*)                /* .data* sections */
+    KEEP(*(.jcr*))
+    . = ALIGN(4);
+    __data_end__ = .;        /* define a global symbol at data end */
+  } > m_data
+
+  __CACHE_REGION_START = ORIGIN(m_interrupts);
+  __CACHE_REGION_SIZE  = 0;
+  __NDATA_ROM = __DATA_ROM + SIZEOF(.data); /* Symbol is used by startup for ncache data initialization */
+
+  .ncache.init : AT(__NDATA_ROM)
+  {
+    __noncachedata_start__ = .;   /* create a global symbol at ncache data start */
+    *(NonCacheable.init)
+    . = ALIGN(4);
+    __noncachedata_init_end__ = .;   /* create a global symbol at initialized ncache data end */
+  } > m_data2
+
+  . = __noncachedata_init_end__;
+  .ncache :
+  {
+    *(NonCacheable)
+    . = ALIGN(4);
+    __noncachedata_end__ = .;     /* define a global symbol at ncache data end */
+  } > m_data2
+
+  __DATA_END = __DATA_ROM + (__data_end__ - __data_start__);
+  text_end = ORIGIN(m_text) + LENGTH(m_text);
+  ASSERT(__DATA_END <= text_end, "region m_text overflowed with text and data")
+
+  /* Uninitialized data section */
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss section */
+    . = ALIGN(4);
+    __START_BSS = .;
+    __bss_start__ = .;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    . = ALIGN(4);
+    __bss_end__ = .;
+    __END_BSS = .;
+  } > m_data
+
+  .heap :
+  {
+    . = ALIGN(8);
+    __end__ = .;
+    PROVIDE(end = .);
+    __HeapBase = .;
+    . += HEAP_SIZE;
+    __HeapLimit = .;
+    __heap_limit = .; /* Add for _sbrk */
+  } > m_data
+
+  .stack :
+  {
+    . = ALIGN(8);
+    . += STACK_SIZE;
+  } > m_data
+
+  /* Initializes stack on the end of block */
+  __StackTop   = ORIGIN(m_data) + LENGTH(m_data);
+  __StackLimit = __StackTop - STACK_SIZE;
+  PROVIDE(__stack = __StackTop);
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+
+  ASSERT(__StackLimit >= __HeapLimit, "region m_data overflowed with stack and heap")
+}
+
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_ram.ld b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_ram.ld
new file mode 100644
index 000000000..82ef572a4
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/MIMX8MM6xxxxx_cm4_ram.ld
@@ -0,0 +1,227 @@
+/*
+** ###################################################################
+**     Processors:          MIMX8MM6CVTKZ
+**                          MIMX8MM6DVTLZ
+**
+**     Compiler:            GNU C Compiler
+**     Reference manual:    MX8MMRM, Rev. 0, 02/2019
+**     Version:             rev. 4.0, 2019-02-18
+**     Build:               b200330
+**
+**     Abstract:
+**         Linker file for the GNU C Compiler
+**
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2020 NXP
+**     All rights reserved.
+**
+**     SPDX-License-Identifier: BSD-3-Clause
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+** ###################################################################
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+HEAP_SIZE  = DEFINED(__heap_size__)  ? __heap_size__  : 0x0400;
+STACK_SIZE = DEFINED(__stack_size__) ? __stack_size__ : 0x0400;
+
+/* Specify the memory areas */
+MEMORY
+{
+  m_interrupts          (RX)  : ORIGIN = 0x1FFE0000, LENGTH = 0x00000240
+  m_text                (RX)  : ORIGIN = 0x1FFE0240, LENGTH = 0x0001FDC0
+  m_data                (RW)  : ORIGIN = 0x20000000, LENGTH = 0x00020000
+  m_data2               (RW)  : ORIGIN = 0x80000000, LENGTH = 0x01000000
+}
+
+/* Define output sections */
+SECTIONS
+{
+/* The startup code goes first into internal RAM */
+  .interrupts :
+  {
+    __VECTOR_TABLE = .;
+    __Vectors = .;
+    . = ALIGN(4);
+    KEEP(*(.isr_vector))     /* Startup code */
+    . = ALIGN(4);
+  } > m_interrupts
+
+  .resource_table :
+  {
+    . = ALIGN(8);
+    KEEP(*(.resource_table)) /* Resource table */
+    . = ALIGN(8);
+  } > m_text
+
+  /* The program code and other data goes into internal RAM */
+  .text :
+  {
+    . = ALIGN(4);
+    *(.text)                 /* .text sections (code) */
+    *(.text*)                /* .text* sections (code) */
+    *(.rodata)               /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)              /* .rodata* sections (constants, strings, etc.) */
+    *(.glue_7)               /* glue arm to thumb code */
+    *(.glue_7t)              /* glue thumb to arm code */
+    *(.eh_frame)
+    KEEP (*(.init))
+    KEEP (*(.fini))
+    . = ALIGN(4);
+  } > m_text
+
+  .ARM.extab :
+  {
+    *(.ARM.extab* .gnu.linkonce.armextab.*)
+  } > m_text
+
+  .ARM :
+  {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } > m_text
+
+ .ctors :
+  {
+    __CTOR_LIST__ = .;
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    __CTOR_END__ = .;
+  } > m_text
+
+  .dtors :
+  {
+    __DTOR_LIST__ = .;
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    __DTOR_END__ = .;
+  } > m_text
+
+  .preinit_array :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } > m_text
+
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } > m_text
+
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } > m_text
+
+  __etext = .;    /* define a global symbol at end of code */
+  __DATA_ROM = .; /* Symbol is used by startup for data initialization */
+
+  .data : AT(__DATA_ROM)
+  {
+    . = ALIGN(4);
+    __DATA_RAM = .;
+    __data_start__ = .;      /* create a global symbol at data start */
+    *(.data)                 /* .data sections */
+    *(.data*)                /* .data* sections */
+    KEEP(*(.jcr*))
+    . = ALIGN(4);
+    __data_end__ = .;        /* define a global symbol at data end */
+  } > m_data
+
+  __CACHE_REGION_START = ORIGIN(m_interrupts);
+  __CACHE_REGION_SIZE  = 0;
+  __NDATA_ROM = __DATA_ROM + SIZEOF(.data); /* Symbol is used by startup for ncache data initialization */
+
+  .ncache.init : AT(__NDATA_ROM)
+  {
+    __noncachedata_start__ = .;   /* create a global symbol at ncache data start */
+    *(NonCacheable.init)
+    . = ALIGN(4);
+    __noncachedata_init_end__ = .;   /* create a global symbol at initialized ncache data end */
+  } > m_data2
+
+  . = __noncachedata_init_end__;
+  .ncache :
+  {
+    *(NonCacheable)
+    . = ALIGN(4);
+    __noncachedata_end__ = .;     /* define a global symbol at ncache data end */
+  } > m_data2
+
+  __DATA_END = __DATA_ROM + (__data_end__ - __data_start__);
+  text_end = ORIGIN(m_text) + LENGTH(m_text);
+  ASSERT(__DATA_END <= text_end, "region m_text overflowed with text and data")
+
+  /* Uninitialized data section */
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss section */
+    . = ALIGN(4);
+    __START_BSS = .;
+    __bss_start__ = .;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    . = ALIGN(4);
+    __bss_end__ = .;
+    __END_BSS = .;
+  } > m_data
+
+  .heap :
+  {
+    . = ALIGN(8);
+    __end__ = .;
+    PROVIDE(end = .);
+    __HeapBase = .;
+    . += HEAP_SIZE;
+    __HeapLimit = .;
+    __heap_limit = .; /* Add for _sbrk */
+  } > m_data
+
+  .stack :
+  {
+    . = ALIGN(8);
+    . += STACK_SIZE;
+  } > m_data
+
+  /* Initializes stack on the end of block */
+  __StackTop   = ORIGIN(m_data) + LENGTH(m_data);
+  __StackLimit = __StackTop - STACK_SIZE;
+  PROVIDE(__stack = __StackTop);
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+
+  ASSERT(__StackLimit >= __HeapLimit, "region m_data overflowed with stack and heap")
+}
+
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_all.bat b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_all.bat
new file mode 100644
index 000000000..2c2a394e4
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_all.bat
@@ -0,0 +1,43 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=debug  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=release  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=ddr_debug  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=ddr_release  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=flash_debug  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=flash_release  .
+mingw32-make -j
+
+IF "%1" == "" ( pause )
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_all.sh b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_all.sh
new file mode 100755
index 000000000..e133b8d66
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_all.sh
@@ -0,0 +1,43 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=debug  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=release  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=ddr_debug  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=ddr_release  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=flash_debug  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=flash_release  .
+make -j
+
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_debug.bat b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_debug.bat
new file mode 100644
index 000000000..f528316a8
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_debug.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=ddr_debug  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_debug.sh b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_debug.sh
new file mode 100755
index 000000000..ee16e2ea2
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_debug.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=ddr_debug  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_release.bat b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_release.bat
new file mode 100644
index 000000000..79c227d96
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_release.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=ddr_release  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_release.sh b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_release.sh
new file mode 100755
index 000000000..c4da7ac0c
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_ddr_release.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=ddr_release  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_debug.bat b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_debug.bat
new file mode 100644
index 000000000..91c5925be
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_debug.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=debug  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_debug.sh b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_debug.sh
new file mode 100755
index 000000000..088872c90
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_debug.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=debug  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_debug.bat b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_debug.bat
new file mode 100644
index 000000000..e9e1ee337
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_debug.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=flash_debug  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_debug.sh b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_debug.sh
new file mode 100755
index 000000000..9730d0f35
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_debug.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=flash_debug  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_release.bat b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_release.bat
new file mode 100644
index 000000000..7f21801a6
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_release.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=flash_release  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_release.sh b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_release.sh
new file mode 100755
index 000000000..d2973cc77
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_flash_release.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=flash_release  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_release.bat b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_release.bat
new file mode 100644
index 000000000..e603434be
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_release.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=release  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_release.sh b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_release.sh
new file mode 100755
index 000000000..094cbd202
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/build_release.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=release  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/clean.bat b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/clean.bat
new file mode 100644
index 000000000..d7474444f
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/clean.bat
@@ -0,0 +1,3 @@
+RD /s /Q debug release ddr_debug ddr_release flash_debug flash_release CMakeFiles
+DEL /s /Q /F Makefile cmake_install.cmake CMakeCache.txt
+pause
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/clean.sh b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/clean.sh
new file mode 100755
index 000000000..c438211d7
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/clean.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+rm -rf debug release ddr_debug ddr_release flash_debug flash_release CMakeFiles
+rm -rf Makefile cmake_install.cmake CMakeCache.txt
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/config.cmake b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/config.cmake
new file mode 100755
index 000000000..4c9f4dee8
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/config.cmake
@@ -0,0 +1,5 @@
+# config to select component, the format is CONFIG_USE_${component}
+set(CONFIG_USE_driver_iuart true)
+set(CONFIG_USE_middleware_freertos-kernel true)
+set(CONFIG_USE_soem_ifport_enet true)
+set(MCUX_DEVICE "MIMX8MM6")
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/flags.cmake b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/flags.cmake
new file mode 100755
index 000000000..329f3fa66
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/armgcc/flags.cmake
@@ -0,0 +1,566 @@
+SET(CMAKE_ASM_FLAGS_DEBUG " \
+    ${CMAKE_ASM_FLAGS_DEBUG} \
+    -DDEBUG \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -g \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_RELEASE " \
+    ${CMAKE_ASM_FLAGS_RELEASE} \
+    -DNDEBUG \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_DDR_DEBUG " \
+    ${CMAKE_ASM_FLAGS_DDR_DEBUG} \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -g \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_DDR_RELEASE " \
+    ${CMAKE_ASM_FLAGS_DDR_RELEASE} \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_FLASH_DEBUG " \
+    ${CMAKE_ASM_FLAGS_FLASH_DEBUG} \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -g \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_FLASH_RELEASE " \
+    ${CMAKE_ASM_FLAGS_FLASH_RELEASE} \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_DEBUG " \
+    ${CMAKE_C_FLAGS_DEBUG} \
+    -DDEBUG \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_RELEASE " \
+    ${CMAKE_C_FLAGS_RELEASE} \
+    -DNDEBUG \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_DDR_DEBUG " \
+    ${CMAKE_C_FLAGS_DDR_DEBUG} \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_DDR_RELEASE " \
+    ${CMAKE_C_FLAGS_DDR_RELEASE} \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_FLASH_DEBUG " \
+    ${CMAKE_C_FLAGS_FLASH_DEBUG} \
+    -DFLASH_TARGET \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_FLASH_RELEASE " \
+    ${CMAKE_C_FLAGS_FLASH_RELEASE} \
+    -DFLASH_TARGET \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_CXX_FLAGS_DEBUG " \
+    ${CMAKE_CXX_FLAGS_DEBUG} \
+    -DDEBUG \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_RELEASE " \
+    ${CMAKE_CXX_FLAGS_RELEASE} \
+    -DNDEBUG \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_DDR_DEBUG " \
+    ${CMAKE_CXX_FLAGS_DDR_DEBUG} \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_DDR_RELEASE " \
+    ${CMAKE_CXX_FLAGS_DDR_RELEASE} \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_FLASH_DEBUG " \
+    ${CMAKE_CXX_FLAGS_FLASH_DEBUG} \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_FLASH_RELEASE " \
+    ${CMAKE_CXX_FLAGS_FLASH_RELEASE} \
+    -DCPU_MIMX8MM6DVTLZ \
+    -DCPU_MIMX8MM6DVTLZ_cm4 \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_DEBUG " \
+    ${CMAKE_EXE_LINKER_FLAGS_DEBUG} \
+    -g \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8MM6xxxxx_cm4_ram.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_RELEASE " \
+    ${CMAKE_EXE_LINKER_FLAGS_RELEASE} \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8MM6xxxxx_cm4_ram.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_DDR_DEBUG " \
+    ${CMAKE_EXE_LINKER_FLAGS_DDR_DEBUG} \
+    -g \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8MM6xxxxx_cm4_ddr_ram.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_DDR_RELEASE " \
+    ${CMAKE_EXE_LINKER_FLAGS_DDR_RELEASE} \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8MM6xxxxx_cm4_ddr_ram.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_FLASH_DEBUG " \
+    ${CMAKE_EXE_LINKER_FLAGS_FLASH_DEBUG} \
+    -g \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8MM6xxxxx_cm4_flash.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_FLASH_RELEASE " \
+    ${CMAKE_EXE_LINKER_FLAGS_FLASH_RELEASE} \
+    -mcpu=cortex-m4 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv4-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8MM6xxxxx_cm4_flash.ld -static \
+")
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/pin_mux.c b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/pin_mux.c
new file mode 100644
index 000000000..37b70af3f
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/pin_mux.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright 2022 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v11.0
+processor: MIMX8MM6xxxLZ
+package_id: MIMX8MM6DVTLZ
+mcu_data: ksdk2_0
+processor_version: 0.11.3
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+    BOARD_InitPins();
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'true', prefix: BOARD_, coreID: cm4}
+- pin_list:
+  - {pin_num: F19, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: F18, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Disabled, PUE: Disabled, DSE: X6_0}
+  - {pin_num: AE27, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: ENET_RD0}
+  - {pin_num: AD27, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: ENET_RD1}
+  - {pin_num: AD26, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: ENET_RD2}
+  - {pin_num: AC26, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: ENET_RD3}
+  - {pin_num: AF27, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: ENET_RX_CTL}
+  - {pin_num: AE26, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: ENET_RXC}
+  - {pin_num: AG26, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: ENET_TD0}
+  - {pin_num: AF26, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: ENET_TD1}
+  - {pin_num: AG25, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: ENET_TD2}
+  - {pin_num: AF25, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: ENET_TD3}
+  - {pin_num: AF24, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: ENET_TX_CTL}
+  - {pin_num: AG24, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: ENET_TXC}
+  - {pin_num: AB22, peripheral: GPIO4, signal: 'gpio_io, 22', pin_signal: SAI2_RXC}
+  - {pin_num: AB27, peripheral: ENET1, signal: enet_mdio, pin_signal: ENET_MDIO}
+  - {pin_num: AC27, peripheral: ENET1, signal: enet_mdc, pin_signal: ENET_MDC}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: undefined[cm4] */
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDC_ENET1_MDC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_MDIO_ENET1_MDIO, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD0_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD1_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD2_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RD3_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_RX_CTL_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TXC_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinMux(IOMUXC_ENET_TX_CTL_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI2_RXC_GPIO4_IO22, 0U);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(6U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL(2U));
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/pin_mux.h b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/pin_mux.h
new file mode 100644
index 000000000..592a0dac6
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/pin_mux.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright 2022 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: undefined[cm4] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/readme.txt b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/readme.txt
new file mode 100644
index 000000000..f194c85bb
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/readme.txt
@@ -0,0 +1,77 @@
+Overview
+========
+The log Demo application demonstrates to prompt LOG with level by commands.
+Note: Please input one character at a time. If you input too many characters each time, the receiver may overflow
+because the low level UART uses simple polling way for receiving. If you want to try inputting many characters each time,
+just define DEBUG_CONSOLE_TRANSFER_NON_BLOCKING in your project to use the advanced debug console utility.
+Besides, the demo does not support semihosting mode. The log demo is based on shell, debug console and 
+serial manager. When semihosting is used, debug console and serial manager are bypassed. So the log demo cannot
+work with semihosting.
+
+Toolchain supported
+===================
+- IAR embedded Workbench  8.50.9
+- Keil MDK  5.33
+- GCC ARM Embedded  9.3.1
+- MCUXpresso  11.3.0
+
+Hardware requirements
+=====================
+- Mini/micro USB cable
+- EVK-MIMXRT1064 board
+- Personal Computer
+
+Board settings
+==============
+No special settings are required.
+
+Prepare the Demo
+================
+1.  Connect a USB cable between the host PC and the OpenSDA USB port on the target board. 
+2.  Open a serial terminal with the following settings:
+    - 115200 baud rate
+    - 8 data bits
+    - No parity
+    - One stop bit
+    - No flow control
+3.  Download the program to the target board.
+4.  Either press the reset button on your board or launch the debugger in your IDE to begin running the demo.
+
+Note
+- This demo will use GPIO toggle which is only available on A1 silicon (MIMXRT106xxxxxA).
+
+Running the demo
+================
+When the example runs successfully, the following message is displayed in the terminal:
+
+~~~~~~~~~~~~~~~~~~~~~
+SHELL build: Sep 27 2020
+Copyright  2020  NXP
+
+LOG SHELL>> installbackend debugconsole
+LOG SHELL>> log error
+       22350: ERROR log_main.c:104:This is "error" log message
+
+LOG SHELL>> log fatal
+       27900: FATAL log_main.c:100:This is "fatal" log message
+
+LOG SHELL>> log warning
+       35430: WARN  log_main.c:108:This is "warning" log message
+
+LOG SHELL>> log info
+       38585: INFO  log_main.c:112:This is "info" log message
+
+LOG SHELL>> log debug
+       41330: DEBUG log_main.c:116:This is "debug" log message
+
+LOG SHELL>> log trace
+       45090: TRACE log_main.c:120:This is "trace" log message
+
+LOG SHELL>> log test
+       49835: ERROR log_main.c:124:The input arguement "test" is not valid
+
+LOG SHELL>> uninstallbackend debugconsole
+LOG SHELL>> 
+~~~~~~~~~~~~~~~~~~~~~
+Note: The shell information "SHELL build: Sep 27 2020" may be different, which depends on the compile date.
+
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/soem_config.h b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/soem_config.h
new file mode 100644
index 000000000..1ab40f5fb
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/soem_config.h
@@ -0,0 +1,48 @@
+#ifndef __SOEM__CONFIG__H__
+#define __SOEM__CONFIG__H__
+
+/** max. etries in EtherCAT error list */
+#define EC_MAXELIST       64
+
+/** max. length of readable name in slavelist and Object Description List */
+#define EC_MAXNAME        40
+
+/** max. number of slaves in array */
+#define EC_MAXSLAVE       100
+
+/** max. number of groups */
+#define EC_MAXGROUP       2
+
+/** max. number of IO segments per group */
+#define EC_MAXIOSEGMENTS  64
+
+/** max. mailbox size */
+#define EC_MAXMBX         1486
+
+/** max. eeprom PDO entries */
+#define EC_MAXEEPDO       0x200
+
+/** max. SM used */
+#define EC_MAXSM          8
+
+/** max. FMMU used */
+#define EC_MAXFMMU        4
+
+/** max. Adapter */
+#define EC_MAXLEN_ADAPTERNAME    128
+
+/* CoE */
+/** max entries in Object Description list */
+#define EC_MAXODLIST   1024
+
+/** max entries in Object Entry list */
+#define EC_MAXOELIST   256
+
+/* OS */
+#define MAX_SOEM_TASK 1
+
+/* Static allocate for SOEM stack when configSUPPORT_STATIC_ALLOCATION is configured*/
+#define MAX_SOEM_TASK_STACK 256
+#define MAX_SOEM_MUTE 1
+
+#endif
diff --git a/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/soem_gpio_pulse.c b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/soem_gpio_pulse.c
new file mode 100644
index 000000000..c136dc69f
--- /dev/null
+++ b/evkmimx8mm/rtos_examples/freertos_soem_gpio_pulse/soem_gpio_pulse.c
@@ -0,0 +1,394 @@
+/*
+ * Copyright (c) 2015, Freescale Semiconductor, Inc.
+ * Copyright 2016-2020 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+#include <sys/time.h>
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_debug_console.h"
+#include "fsl_enet.h"
+#include "fsl_phy.h"
+#if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
+#include "fsl_memory.h"
+#endif
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet_mdio.h"
+#include "fsl_phyar8031.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "soem_port.h"
+#include "FreeRTOS.h"
+
+int _write(int handle, char *buffer, int size)
+{
+	int i;
+    if (NULL == buffer)
+    {
+        /* return -1 if error. */
+        return -1;
+    }
+
+    /* This function only writes to "standard out" and "standard err" for all other file handles it returns failure. */
+    if ((handle != 1) && (handle != 2))
+    {
+        return -1;
+    }
+	for(i = 0; i < size; i++) {
+		if (buffer[i] == '\n') {
+			DbgConsole_Putchar('\r');
+		}
+		DbgConsole_Putchar(buffer[i]);
+     }
+    return size;
+}
+
+static StackType_t IdleTaskStack[configMINIMAL_STACK_SIZE];
+static StaticTask_t IdleTaskTCB;
+
+static StackType_t TimerTaskStacj[configMINIMAL_STACK_SIZE];
+static StaticTask_t TimerTaskTCB;
+
+void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize)
+{
+	*ppxIdleTaskTCBBuffer = &IdleTaskTCB;
+	*ppxIdleTaskStackBuffer = &IdleTaskStack[0];
+	*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
+}
+
+void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize)
+{
+	*ppxTimerTaskTCBBuffer = &TimerTaskTCB;
+	*ppxTimerTaskStackBuffer = &TimerTaskStacj[0];
+	*pulTimerTaskStackSize = configMINIMAL_STACK_SIZE;
+}
+
+#define OSEM_PORT_NAME 			"enet"
+#define OSEM_PORT               ENET
+#define PHY_ADDRESS             0x00u
+#define PHY_INTERFACE_RGMII
+#define ENET_CLOCK_FREQ 250000000
+#define SOEM_PERIOD 125 // 125us
+#define RT_TASK_STACK_SIZE 1024
+#define EC_TIMEOUTMON 500
+#define EC_MAXSLAVE 100
+
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (100000)
+#endif
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (0U)
+#endif
+
+#define ENET_RXBD_NUM          (1)
+#define ENET_TXBD_NUM          (1)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*********************************************************************
+GPT timer will be used to waken up the RT task and provide the system time and delay;
+*********************************************************************/
+#define OSAL_TIMER_IRQ_ID		GPT1_IRQn
+#define OSAL_TIMER				GPT1
+#define OSAL_TIMER_IRQHandler	GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ     (CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+
+static struct timeval system_time_base = {
+	.tv_sec = 0,
+	.tv_usec =  0
+};
+
+static StaticTask_t xTaskBuffer;
+static StaticTask_t xTaskBuffer_uart;
+static TaskHandle_t rt_task = NULL;
+static TaskHandle_t uart_task = NULL;
+static StackType_t  rt_task_stack[RT_TASK_STACK_SIZE];
+static StackType_t  uart_task_stack[RT_TASK_STACK_SIZE];
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	BaseType_t xHigherPriorityTaskWoken;
+    /* Clear interrupt flag.*/
+    GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+    system_time_base.tv_usec += SOEM_PERIOD;
+	system_time_base.tv_sec += system_time_base.tv_usec / 1000000;
+	system_time_base.tv_usec = system_time_base.tv_usec % 1000000;
+
+	if (rt_task) {
+		/*Waken up the rt task*/
+		xHigherPriorityTaskWoken = pdFALSE;
+		vTaskNotifyGiveFromISR(rt_task, &xHigherPriorityTaskWoken);
+		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
+	}
+/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+  exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+    __DSB();
+#endif
+}
+
+
+
+void osal_timer_init()
+{
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+	gpt_config_t gptConfig;
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	GPT_SetClockDivider(OSAL_TIMER, 100);
+	/*Divide GPT clock source frequency to 1MHz*/
+	/* Set both GPT modules to SOEM_PERIOD duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, SOEM_PERIOD);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	NVIC_SetPriority(OSAL_TIMER_IRQ_ID, 5);
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint32_t sec = system_time_base.tv_sec;
+	uint32_t usec_base = system_time_base.tv_usec;
+	uint32_t usec_again = system_time_base.tv_usec;
+	uint32_t usec = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	/*in case of that the GPT IRQ occurred during the sec and usec reading obove*/
+	if (usec != usec_again) {
+		usec = GPT_GetCurrentTimerCount(OSAL_TIMER);
+		usec_base = system_time_base.tv_usec;
+		sec = system_time_base.tv_sec;
+	}
+	current_time->tv_sec = sec;
+	current_time->tv_usec = usec + usec_base;
+}
+
+/*******************************************************************************
+ * OSHW: register enet port to SOEM stack
+ ******************************************************************************/
+
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+
+enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+
+struct enet_if_port if_port;
+
+int if_port_init()
+{
+	memset(&if_port, 0, sizeof(if_port));
+	if_port.mdioHandle.ops = &enet_ops;
+	if_port.phyHandle.ops = &phyar8031_ops;
+	if_port.bufferConfig = buffConfig;
+	if_port.base =  OSEM_PORT;
+    /* The miiMode should be set according to the different PHY interfaces. */
+#ifdef PHY_INTERFACE_RGMII
+	if_port.mii_mode = kENET_RgmiiMode;
+#else
+	if_port.mii_mode = kENET_RmiiMode;
+#endif
+	if_port.phy_config.autoNeg = true;
+	if_port.phy_config.phyAddr = PHY_ADDRESS;
+	if_port.srcClock_Hz = ENET_CLOCK_FREQ;
+	if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+	if_port.phy_stability_delay_us = PHY_STABILITY_DELAY_US;
+	return register_soem_port(OSEM_PORT_NAME, "enet", &if_port);
+}
+
+unsigned int time_trans = 0;
+void uart_printf_task(void *ifname)
+{
+	while (1) {
+		printf("EtherCAT task takes %2dus\r\n", time_trans);
+	}
+}
+
+
+char IOmap[100];
+void control_task(void *ifname)
+{
+	int oloop, iloop;
+	int expectedWKC;
+	volatile int wkc;
+	int old_switch0 = 0, old_switch1 = 0;
+	struct timeval start_time;
+	struct timeval end_time;
+	struct timeval trans_time;
+	const TickType_t xBlockTime = pdMS_TO_TICKS( 500 );
+	
+/* initialise SOEM, and if_port */
+	if (ec_init(ifname)) {
+		printf("ec_init on %s succeeded.\n",(char *)ifname);
+		if ( ec_config_init(FALSE) > 0 ) {
+			printf("%d slaves found and configured.\n",ec_slavecount);
+			ec_config_map(&IOmap);
+			ec_configdc();
+			printf("Slaves mapped, state to SAFE_OP.\n");
+			/* wait for all slaves to reach SAFE_OP state */
+			ec_statecheck(0, EC_STATE_SAFE_OP,  EC_TIMEOUTSTATE * 4);
+			oloop = ec_slave[2].Obytes;
+			iloop = ec_slave[3].Ibytes;
+			printf("oloop = %d, iloop = %d\n", oloop, iloop);
+
+			printf("Request operational state for all slaves\n");
+			expectedWKC = (ec_group[0].outputsWKC * 2) + ec_group[0].inputsWKC;
+			printf("Calculated workcounter %d\n", expectedWKC);
+			ec_slave[0].state = EC_STATE_OPERATIONAL;
+			/* send one valid process data to make outputs in slaves happy*/
+			ec_send_processdata();
+			ec_receive_processdata(EC_TIMEOUTRET);
+			/* request OP state for all slaves */
+			ec_writestate(0);
+			char chk = 40;
+			/* wait for all slaves to reach OP state */
+			do {
+				ec_send_processdata();
+				ec_receive_processdata(EC_TIMEOUTRET);
+				ec_statecheck(0, EC_STATE_OPERATIONAL, 50000);
+			} while(chk-- && (ec_slave[0].state != EC_STATE_OPERATIONAL));
+			printf("Operational state reached for all slaves.\n");
+			/* cyclic loop */
+			ec_send_processdata();
+			for(;;) {
+				osal_gettime(&start_time);
+				wkc = ec_receive_processdata(EC_TIMEOUTRET);
+
+				if(wkc >= expectedWKC) {
+					/*The channel-1 of slave2 is the lift limit switch*/
+					if ((*(ec_slave[3].inputs) & 0x01)  && old_switch0 == 0) {
+						/*The channel-3 of slave1 is the dir pin*/
+						if (*(ec_slave[2].outputs) & 0x04 )
+							*(ec_slave[2].outputs) &= ~0x04;
+						else
+							*(ec_slave[2].outputs) |= 0x04;
+					}
+
+					/*The channel-2 of slave2 is the right limit switch*/
+					if ((*(ec_slave[3].inputs) & 0x02)  && old_switch1 == 0) {
+						if (*(ec_slave[2].outputs) & 0x04 )
+							*(ec_slave[2].outputs) &= ~0x04;
+						else
+							*(ec_slave[2].outputs) |= 0x04;
+					}
+
+					old_switch0 = *(ec_slave[3].inputs) & 0x01;
+					old_switch1 = *(ec_slave[3].inputs) & 0x02;
+
+					/*The channel-2 of slave1 is the  plus pin*/
+					if (*(ec_slave[2].outputs) & 0x02 )
+						*(ec_slave[2].outputs) &= ~0x02;
+					else
+						*(ec_slave[2].outputs) |= 0x02;
+				}
+				ec_send_processdata();
+				osal_gettime(&end_time);
+				timersub(&end_time, &start_time, &trans_time);
+				/*Test the communication time*/
+				time_trans = trans_time.tv_usec;
+				ulTaskNotifyTake( pdFALSE, xBlockTime);
+			}
+		}
+	}
+	vTaskSuspend(NULL);
+}
+
+/*!
+ * @brief Main function
+ */
+int main(void)
+{
+    /* Hardware Initialization. */
+	BOARD_InitMemory();
+    BOARD_RdcInit();
+    BOARD_InitPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4); /* SYSTEM PLL2 divided by 4: 250Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+    
+    /* mii/rgmii interface clock */
+    CLOCK_SetRootDivider(kCLOCK_RootEnetRef, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetRef, kCLOCK_EnetRefRootmuxSysPll2Div8); /* SYSTEM PLL2 divided by 8: 125MHz */
+    
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+
+    GPIO_PinInit(GPIO4, 22U, &gpio_config);
+
+    GPIO_WritePinOutput(GPIO4, 22U, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 22U, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET_MAC0_Rx_Tx_Done1_IRQn);
+    EnableIRQ(ENET_MAC0_Rx_Tx_Done2_IRQn);
+
+    osal_timer_init();
+    if_port_init();
+	rt_task = xTaskCreateStatic(/* The function that implements the task. */
+		control_task,
+		"RT_task",
+		RT_TASK_STACK_SIZE,
+		OSEM_PORT_NAME,
+		configMAX_PRIORITIES - 1,
+		rt_task_stack,
+         &xTaskBuffer);
+	uart_task = xTaskCreateStatic(
+		uart_printf_task,
+        "UART_task",
+        RT_TASK_STACK_SIZE,
+        OSEM_PORT_NAME,
+        configMAX_PRIORITIES - 2,
+        uart_task_stack,
+         &xTaskBuffer_uart);
+
+	vTaskStartScheduler();
+	for (;;)
+		;
+    return 0;
+}
-- 
2.25.1

