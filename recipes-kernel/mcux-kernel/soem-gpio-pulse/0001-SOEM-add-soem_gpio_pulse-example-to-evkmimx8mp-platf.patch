From 22abee89fd70a0fdee57fb916a00492ab2ea7e43 Mon Sep 17 00:00:00 2001
From: Wenbin Song <wenbin.song@nxp.com>
Date: Tue, 4 Jan 2022 14:17:33 +0800
Subject: [PATCH 1/2] SOEM: add soem_gpio_pulse example to evkmimx8mp platform

Signed-off-by: Wenbin Song <wenbin.song@nxp.com>
---
 .../soem_gpio_pulse/armgcc/CMakeLists.txt     | 114 ++++
 .../armgcc/MIMX8ML8xxxxx_cm7_ddr_ram.ld       | 230 +++++++
 .../armgcc/MIMX8ML8xxxxx_cm7_flash.ld         | 230 +++++++
 .../armgcc/MIMX8ML8xxxxx_cm7_ram.ld           | 229 +++++++
 .../soem_gpio_pulse/armgcc/build_all.bat      |  43 ++
 .../soem_gpio_pulse/armgcc/build_all.sh       |  43 ++
 .../armgcc/build_ddr_debug.bat                |   6 +
 .../soem_gpio_pulse/armgcc/build_ddr_debug.sh |   7 +
 .../armgcc/build_ddr_release.bat              |   6 +
 .../armgcc/build_ddr_release.sh               |   7 +
 .../soem_gpio_pulse/armgcc/build_debug.bat    |   6 +
 .../soem_gpio_pulse/armgcc/build_debug.sh     |   7 +
 .../armgcc/build_flash_debug.bat              |   6 +
 .../armgcc/build_flash_debug.sh               |   7 +
 .../armgcc/build_flash_release.bat            |   6 +
 .../armgcc/build_flash_release.sh             |   7 +
 .../soem_gpio_pulse/armgcc/build_release.bat  |   6 +
 .../soem_gpio_pulse/armgcc/build_release.sh   |   7 +
 .../soem_gpio_pulse/armgcc/clean.bat          |   3 +
 .../demo_apps/soem_gpio_pulse/armgcc/clean.sh |   3 +
 .../soem_gpio_pulse/armgcc/config.cmake       |   5 +
 .../soem_gpio_pulse/armgcc/flags.cmake        | 570 ++++++++++++++++++
 .../demo_apps/soem_gpio_pulse/pin_mux.c       | 146 +++++
 .../demo_apps/soem_gpio_pulse/pin_mux.h       |  56 ++
 .../demo_apps/soem_gpio_pulse/soem_config.h   |  50 ++
 .../soem_gpio_pulse/soem_gpio_pulse.c         | 330 ++++++++++
 26 files changed, 2130 insertions(+)
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/CMakeLists.txt
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_ddr_ram.ld
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_flash.ld
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_ram.ld
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_all.bat
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_all.sh
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_debug.bat
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_debug.sh
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_release.bat
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_release.sh
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_debug.bat
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_debug.sh
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_debug.bat
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_debug.sh
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_release.bat
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_release.sh
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_release.bat
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_release.sh
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/clean.bat
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/clean.sh
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/config.cmake
 create mode 100755 evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/flags.cmake
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/pin_mux.c
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/pin_mux.h
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/soem_config.h
 create mode 100644 evkmimx8mp/demo_apps/soem_gpio_pulse/soem_gpio_pulse.c

diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/CMakeLists.txt b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/CMakeLists.txt
new file mode 100644
index 000000000..6084c9b17
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/CMakeLists.txt
@@ -0,0 +1,114 @@
+# CROSS COMPILER SETTING
+SET(CMAKE_SYSTEM_NAME Generic)
+CMAKE_MINIMUM_REQUIRED (VERSION 3.1.1)
+
+# THE VERSION NUMBER
+SET (Tutorial_VERSION_MAJOR 1)
+SET (Tutorial_VERSION_MINOR 0)
+
+# ENABLE ASM
+ENABLE_LANGUAGE(ASM)
+
+SET(CMAKE_STATIC_LIBRARY_PREFIX)
+SET(CMAKE_STATIC_LIBRARY_SUFFIX)
+
+SET(CMAKE_EXECUTABLE_LIBRARY_PREFIX)
+SET(CMAKE_EXECUTABLE_LIBRARY_SUFFIX)
+
+# CURRENT DIRECTORY
+SET(ProjDirPath ${CMAKE_CURRENT_SOURCE_DIR})
+
+SET(EXECUTABLE_OUTPUT_PATH ${ProjDirPath}/${CMAKE_BUILD_TYPE})
+SET(LIBRARY_OUTPUT_PATH ${ProjDirPath}/${CMAKE_BUILD_TYPE})
+
+
+project(soem_gpio_pulse)
+
+set(MCUX_SDK_PROJECT_NAME soem_gpio_pulse.elf)
+
+include(${ProjDirPath}/flags.cmake)
+
+include(${ProjDirPath}/config.cmake)
+
+add_executable(${MCUX_SDK_PROJECT_NAME}
+"${ProjDirPath}/../soem_gpio_pulse.c"
+"${ProjDirPath}/../pin_mux.c"
+"${ProjDirPath}/../pin_mux.h"
+"${ProjDirPath}/../../../../../core/boards/evkmimx8mp/board.c"
+"${ProjDirPath}/../../../../../core/boards/evkmimx8mp/board.h"
+"${ProjDirPath}/../../../../../core/boards/evkmimx8mp/clock_config.c"
+"${ProjDirPath}/../../../../../core/boards/evkmimx8mp/clock_config.h"
+)
+
+target_include_directories(${MCUX_SDK_PROJECT_NAME} PRIVATE
+    ${ProjDirPath}/..
+	${ProjDirPath}/../../../../../core/boards/evkmimx8mp/
+)
+
+set(CMAKE_MODULE_PATH
+    ${ProjDirPath}/../../../../../core/
+)
+
+#Include Entry cmake component
+include(all_devices)
+
+# include modules
+include(driver_mdio-enet)
+
+include(driver_phy-device-rtl8211f)
+
+include(utility_debug_console_lite)
+
+include(utility_assert_lite)
+
+include(driver_clock)
+
+include(driver_enet)
+
+include(driver_common)
+
+include(driver_rdc)
+
+include(driver_audiomix)
+
+include(device_CMSIS)
+
+include(component_iuart_adapter)
+
+include(component_lists)
+
+include(driver_iuart)
+
+include(device_startup)
+
+include(driver_igpio)
+
+include(driver_mdio-common)
+
+include(CMSIS_Include_core_cm)
+
+include(driver_phy-common)
+
+include(utilities_misc_utilities)
+
+include(device_system)
+
+include(driver_gpt)
+
+include(component_soem)
+
+TARGET_LINK_LIBRARIES(${MCUX_SDK_PROJECT_NAME} PRIVATE -Wl,--start-group)
+
+target_link_libraries(${MCUX_SDK_PROJECT_NAME} PRIVATE m)
+
+target_link_libraries(${MCUX_SDK_PROJECT_NAME} PRIVATE c)
+
+target_link_libraries(${MCUX_SDK_PROJECT_NAME} PRIVATE gcc)
+
+target_link_libraries(${MCUX_SDK_PROJECT_NAME} PRIVATE nosys)
+
+TARGET_LINK_LIBRARIES(${MCUX_SDK_PROJECT_NAME} PRIVATE -Wl,--end-group)
+
+ADD_CUSTOM_COMMAND(TARGET ${MCUX_SDK_PROJECT_NAME} POST_BUILD COMMAND ${CMAKE_OBJCOPY}
+-Obinary ${EXECUTABLE_OUTPUT_PATH}/${MCUX_SDK_PROJECT_NAME} ${EXECUTABLE_OUTPUT_PATH}/soem_gpio_pulse.bin)
+
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_ddr_ram.ld b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_ddr_ram.ld
new file mode 100644
index 000000000..26596f53f
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_ddr_ram.ld
@@ -0,0 +1,230 @@
+/*
+** ###################################################################
+**     Processors:          MIMX8ML8CVNKZ
+**                          MIMX8ML8DVNLZ
+**
+**     Compiler:            GNU C Compiler
+**     Reference manual:    IMX8MPRM, Rev.D, 12/2020
+**     Version:             rev. 5.0, 2021-03-01
+**     Build:               b210301
+**
+**     Abstract:
+**         Linker file for the GNU C Compiler
+**
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2021 NXP
+**     All rights reserved.
+**
+**     SPDX-License-Identifier: BSD-3-Clause
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+** ###################################################################
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+HEAP_SIZE  = DEFINED(__heap_size__)  ? __heap_size__  : 0x0400;
+STACK_SIZE = DEFINED(__stack_size__) ? __stack_size__ : 0x0400;
+
+/* Specify the memory areas */
+MEMORY
+{
+  m_interrupts          (RX)  : ORIGIN = 0x80000000, LENGTH = 0x00000400
+  m_text                (RX)  : ORIGIN = 0x80000400, LENGTH = 0x001FFC00
+  m_data                (RW)  : ORIGIN = 0x80200000, LENGTH = 0x00200000
+  m_data2               (RW)  : ORIGIN = 0x80400000, LENGTH = 0x00C00000
+}
+
+/* Define output sections */
+SECTIONS
+{
+/* The startup code goes first into internal RAM */
+  .interrupts :
+  {
+    __VECTOR_TABLE = .;
+    __Vectors = .;
+    . = ALIGN(4);
+    KEEP(*(.isr_vector))     /* Startup code */
+    . = ALIGN(4);
+  } > m_interrupts
+
+  .resource_table :
+  {
+    . = ALIGN(8);
+    KEEP(*(.resource_table)) /* Resource table */
+    . = ALIGN(8);
+  } > m_text
+
+  /* The program code and other data goes into internal RAM */
+  .text :
+  {
+    . = ALIGN(4);
+    *(.text)                 /* .text sections (code) */
+    *(.text*)                /* .text* sections (code) */
+    *(.rodata)               /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)              /* .rodata* sections (constants, strings, etc.) */
+    *(.glue_7)               /* glue arm to thumb code */
+    *(.glue_7t)              /* glue thumb to arm code */
+    *(.eh_frame)
+    KEEP (*(.init))
+    KEEP (*(.fini))
+    . = ALIGN(4);
+  } > m_text
+
+  .ARM.extab :
+  {
+    *(.ARM.extab* .gnu.linkonce.armextab.*)
+  } > m_text
+
+  .ARM :
+  {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } > m_text
+
+ .ctors :
+  {
+    __CTOR_LIST__ = .;
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    __CTOR_END__ = .;
+  } > m_text
+
+  .dtors :
+  {
+    __DTOR_LIST__ = .;
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    __DTOR_END__ = .;
+  } > m_text
+
+  .preinit_array :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } > m_text
+
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } > m_text
+
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } > m_text
+
+  __etext = .;    /* define a global symbol at end of code */
+  __DATA_ROM = .; /* Symbol is used by startup for data initialization */
+
+  .data : AT(__DATA_ROM)
+  {
+    . = ALIGN(4);
+    __DATA_RAM = .;
+    __data_start__ = .;      /* create a global symbol at data start */
+    *(.data)                 /* .data sections */
+    *(.data*)                /* .data* sections */
+    KEEP(*(.jcr*))
+    . = ALIGN(4);
+    __data_end__ = .;        /* define a global symbol at data end */
+  } > m_data
+
+  __CACHE_REGION_START = ORIGIN(m_interrupts);
+  __CACHE_REGION_SIZE  = LENGTH(m_interrupts) + LENGTH(m_text) + LENGTH(m_data);
+
+  __NDATA_ROM = __DATA_ROM + SIZEOF(.data); /* Symbol is used by startup for ncache data initialization */
+
+  .ncache.init : AT(__NDATA_ROM)
+  {
+    __noncachedata_start__ = .;   /* create a global symbol at ncache data start */
+    *(NonCacheable.init)
+    . = ALIGN(4);
+    __noncachedata_init_end__ = .;   /* create a global symbol at initialized ncache data end */
+  } > m_data2
+
+  . = __noncachedata_init_end__;
+  .ncache :
+  {
+    *(NonCacheable)
+    . = ALIGN(4);
+    __noncachedata_end__ = .;     /* define a global symbol at ncache data end */
+  } > m_data2
+
+  __DATA_END = __DATA_ROM + (__data_end__ - __data_start__);
+  text_end = ORIGIN(m_text) + LENGTH(m_text);
+  ASSERT(__DATA_END <= text_end, "region m_text overflowed with text and data")
+
+  /* Uninitialized data section */
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss section */
+    . = ALIGN(4);
+    __START_BSS = .;
+    __bss_start__ = .;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    . = ALIGN(4);
+    __bss_end__ = .;
+    __END_BSS = .;
+  } > m_data2
+
+  .heap :
+  {
+    . = ALIGN(8);
+    __end__ = .;
+    PROVIDE(end = .);
+    __HeapBase = .;
+    . += HEAP_SIZE;
+    __HeapLimit = .;
+    __heap_limit = .; /* Add for _sbrk */
+  } > m_data
+
+
+  .stack :
+  {
+    . = ALIGN(8);
+    . += STACK_SIZE;
+  } > m_data
+
+
+  /* Initializes stack on the end of block */
+  __StackTop   = ORIGIN(m_data) + LENGTH(m_data);
+  __StackLimit = __StackTop - STACK_SIZE;
+  PROVIDE(__stack = __StackTop);
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+
+  ASSERT(__StackLimit >= __HeapLimit, "region m_data overflowed with stack and heap")
+}
+
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_flash.ld b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_flash.ld
new file mode 100644
index 000000000..f4b39c78f
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_flash.ld
@@ -0,0 +1,230 @@
+/*
+** ###################################################################
+**     Processors:          MIMX8ML8CVNKZ
+**                          MIMX8ML8DVNLZ
+**
+**     Compiler:            GNU C Compiler
+**     Reference manual:    IMX8MPRM, Rev.D, 12/2020
+**     Version:             rev. 5.0, 2021-03-01
+**     Build:               b210301
+**
+**     Abstract:
+**         Linker file for the GNU C Compiler
+**
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2021 NXP
+**     All rights reserved.
+**
+**     SPDX-License-Identifier: BSD-3-Clause
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+** ###################################################################
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+HEAP_SIZE  = DEFINED(__heap_size__)  ? __heap_size__  : 0x0400;
+STACK_SIZE = DEFINED(__stack_size__) ? __stack_size__ : 0x0400;
+
+/* Specify the memory areas */
+MEMORY
+{
+  m_interrupts          (RX)  : ORIGIN = 0x08000000, LENGTH = 0x00000400
+  m_text                (RX)  : ORIGIN = 0x08000400, LENGTH = 0x000FFC00
+  m_data                (RW)  : ORIGIN = 0x20000000, LENGTH = 0x00020000
+  m_data2               (RW)  : ORIGIN = 0x80000000, LENGTH = 0x01000000
+  m_tcml                (RW)  : ORIGIN = 0x00000020, LENGTH = 0x0001FFE0
+}
+
+/* Define output sections */
+SECTIONS
+{
+/* The startup code goes first into internal flash */
+  .interrupts :
+  {
+    __VECTOR_TABLE = .;
+    __Vectors = .;
+    . = ALIGN(4);
+    KEEP(*(.isr_vector))     /* Startup code */
+    . = ALIGN(4);
+  } > m_interrupts
+
+  .resource_table :
+  {
+    . = ALIGN(8);
+    KEEP(*(.resource_table)) /* Resource table */
+    . = ALIGN(8);
+  } > m_text
+
+  /* The program code and other data goes into internal flash */
+  .text :
+  {
+    . = ALIGN(4);
+    *(.text)                 /* .text sections (code) */
+    *(.text*)                /* .text* sections (code) */
+    *(.rodata)               /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)              /* .rodata* sections (constants, strings, etc.) */
+    *(.glue_7)               /* glue arm to thumb code */
+    *(.glue_7t)              /* glue thumb to arm code */
+    *(.eh_frame)
+    KEEP (*(.init))
+    KEEP (*(.fini))
+    . = ALIGN(4);
+  } > m_text
+
+  .ARM.extab :
+  {
+    *(.ARM.extab* .gnu.linkonce.armextab.*)
+  } > m_text
+
+  .ARM :
+  {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } > m_text
+
+ .ctors :
+  {
+    __CTOR_LIST__ = .;
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    __CTOR_END__ = .;
+  } > m_text
+
+  .dtors :
+  {
+    __DTOR_LIST__ = .;
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    __DTOR_END__ = .;
+  } > m_text
+
+  .preinit_array :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } > m_text
+
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } > m_text
+
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } > m_text
+
+  __etext = .;    /* define a global symbol at end of code */
+  __DATA_ROM = .; /* Symbol is used by startup for data initialization */
+
+  .data : AT(__DATA_ROM)
+  {
+    . = ALIGN(4);
+    __DATA_RAM = .;
+    __data_start__ = .;      /* create a global symbol at data start */
+    *(.data)                 /* .data sections */
+    *(.data*)                /* .data* sections */
+    KEEP(*(.jcr*))
+    . = ALIGN(4);
+    __data_end__ = .;        /* define a global symbol at data end */
+  } > m_data
+
+  __CACHE_REGION_START = ORIGIN(m_interrupts);
+  __CACHE_REGION_SIZE  = 0;
+  __NDATA_ROM = __DATA_ROM + SIZEOF(.data); /* Symbol is used by startup for ncache data initialization */
+
+  .ncache.init : AT(__NDATA_ROM)
+  {
+    __noncachedata_start__ = .;   /* create a global symbol at ncache data start */
+    *(NonCacheable.init)
+    . = ALIGN(4);
+    __noncachedata_init_end__ = .;   /* create a global symbol at initialized ncache data end */
+  } > m_data2
+
+  . = __noncachedata_init_end__;
+  .ncache :
+  {
+    *(NonCacheable)
+    . = ALIGN(4);
+    __noncachedata_end__ = .;     /* define a global symbol at ncache data end */
+  } > m_data2
+
+  __DATA_END = __DATA_ROM + (__data_end__ - __data_start__);
+  text_end = ORIGIN(m_text) + LENGTH(m_text);
+  ASSERT(__DATA_END <= text_end, "region m_text overflowed with text and data")
+
+  /* Uninitialized data section */
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss section */
+    . = ALIGN(4);
+    __START_BSS = .;
+    __bss_start__ = .;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    . = ALIGN(4);
+    __bss_end__ = .;
+    __END_BSS = .;
+  } > m_data2
+
+  .heap :
+  {
+    . = ALIGN(8);
+    __end__ = .;
+    PROVIDE(end = .);
+    __HeapBase = .;
+    . += HEAP_SIZE;
+    __HeapLimit = .;
+    __heap_limit = .; /* Add for _sbrk */
+  } > m_data
+
+
+  .stack :
+  {
+    . = ALIGN(8);
+    . += STACK_SIZE;
+  } > m_data
+
+
+  /* Initializes stack on the end of block */
+  __StackTop   = ORIGIN(m_data) + LENGTH(m_data);
+  __StackLimit = __StackTop - STACK_SIZE;
+  PROVIDE(__stack = __StackTop);
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+
+  ASSERT(__StackLimit >= __HeapLimit, "region m_data overflowed with stack and heap")
+}
+
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_ram.ld b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_ram.ld
new file mode 100644
index 000000000..64164f090
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/MIMX8ML8xxxxx_cm7_ram.ld
@@ -0,0 +1,229 @@
+/*
+** ###################################################################
+**     Processors:          MIMX8ML8CVNKZ
+**                          MIMX8ML8DVNLZ
+**
+**     Compiler:            GNU C Compiler
+**     Reference manual:    IMX8MPRM, Rev.D, 12/2020
+**     Version:             rev. 5.0, 2021-03-01
+**     Build:               b210301
+**
+**     Abstract:
+**         Linker file for the GNU C Compiler
+**
+**     Copyright 2016 Freescale Semiconductor, Inc.
+**     Copyright 2016-2021 NXP
+**     All rights reserved.
+**
+**     SPDX-License-Identifier: BSD-3-Clause
+**
+**     http:                 www.nxp.com
+**     mail:                 support@nxp.com
+**
+** ###################################################################
+*/
+
+/* Entry Point */
+ENTRY(Reset_Handler)
+
+HEAP_SIZE  = DEFINED(__heap_size__)  ? __heap_size__  : 0x0400;
+STACK_SIZE = DEFINED(__stack_size__) ? __stack_size__ : 0x0400;
+
+/* Specify the memory areas */
+MEMORY
+{
+  m_interrupts          (RX)  : ORIGIN = 0x00000000, LENGTH = 0x00000400
+  m_text                (RX)  : ORIGIN = 0x00000400, LENGTH = 0x0001FC00
+  m_data                (RW)  : ORIGIN = 0x20000000, LENGTH = 0x00020000
+  m_data2               (RW)  : ORIGIN = 0x80000000, LENGTH = 0x01000000
+}
+
+/* Define output sections */
+SECTIONS
+{
+/* The startup code goes first into internal RAM */
+  .interrupts :
+  {
+    __VECTOR_TABLE = .;
+    __Vectors = .;
+    . = ALIGN(4);
+    KEEP(*(.isr_vector))     /* Startup code */
+    . = ALIGN(4);
+  } > m_interrupts
+
+  .resource_table :
+  {
+    . = ALIGN(8);
+    KEEP(*(.resource_table)) /* Resource table */
+    . = ALIGN(8);
+  } > m_text
+
+  /* The program code and other data goes into internal RAM */
+  .text :
+  {
+    . = ALIGN(4);
+    *(.text)                 /* .text sections (code) */
+    *(.text*)                /* .text* sections (code) */
+    *(.rodata)               /* .rodata sections (constants, strings, etc.) */
+    *(.rodata*)              /* .rodata* sections (constants, strings, etc.) */
+    *(.glue_7)               /* glue arm to thumb code */
+    *(.glue_7t)              /* glue thumb to arm code */
+    *(.eh_frame)
+    KEEP (*(.init))
+    KEEP (*(.fini))
+    . = ALIGN(4);
+  } > m_text
+
+  .ARM.extab :
+  {
+    *(.ARM.extab* .gnu.linkonce.armextab.*)
+  } > m_text
+
+  .ARM :
+  {
+    __exidx_start = .;
+    *(.ARM.exidx*)
+    __exidx_end = .;
+  } > m_text
+
+ .ctors :
+  {
+    __CTOR_LIST__ = .;
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+    KEEP (*crtbegin.o(.ctors))
+    KEEP (*crtbegin?.o(.ctors))
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    __CTOR_END__ = .;
+  } > m_text
+
+  .dtors :
+  {
+    __DTOR_LIST__ = .;
+    KEEP (*crtbegin.o(.dtors))
+    KEEP (*crtbegin?.o(.dtors))
+    KEEP (*(EXCLUDE_FILE(*crtend?.o *crtend.o) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    __DTOR_END__ = .;
+  } > m_text
+
+  .preinit_array :
+  {
+    PROVIDE_HIDDEN (__preinit_array_start = .);
+    KEEP (*(.preinit_array*))
+    PROVIDE_HIDDEN (__preinit_array_end = .);
+  } > m_text
+
+  .init_array :
+  {
+    PROVIDE_HIDDEN (__init_array_start = .);
+    KEEP (*(SORT(.init_array.*)))
+    KEEP (*(.init_array*))
+    PROVIDE_HIDDEN (__init_array_end = .);
+  } > m_text
+
+  .fini_array :
+  {
+    PROVIDE_HIDDEN (__fini_array_start = .);
+    KEEP (*(SORT(.fini_array.*)))
+    KEEP (*(.fini_array*))
+    PROVIDE_HIDDEN (__fini_array_end = .);
+  } > m_text
+
+  __etext = .;    /* define a global symbol at end of code */
+  __DATA_ROM = .; /* Symbol is used by startup for data initialization */
+
+  .data : AT(__DATA_ROM)
+  {
+    . = ALIGN(4);
+    __DATA_RAM = .;
+    __data_start__ = .;      /* create a global symbol at data start */
+    *(.data)                 /* .data sections */
+    *(.data*)                /* .data* sections */
+    KEEP(*(.jcr*))
+    . = ALIGN(4);
+    __data_end__ = .;        /* define a global symbol at data end */
+  } > m_data
+
+  __CACHE_REGION_START = ORIGIN(m_interrupts);
+  __CACHE_REGION_SIZE  = 0;
+  __NDATA_ROM = __DATA_ROM + SIZEOF(.data); /* Symbol is used by startup for ncache data initialization */
+
+  .ncache.init : AT(__NDATA_ROM)
+  {
+    __noncachedata_start__ = .;   /* create a global symbol at ncache data start */
+    *(NonCacheable.init)
+    . = ALIGN(4);
+    __noncachedata_init_end__ = .;   /* create a global symbol at initialized ncache data end */
+  } > m_data
+
+  . = __noncachedata_init_end__;
+  .ncache :
+  {
+    *(NonCacheable)
+    . = ALIGN(4);
+    __noncachedata_end__ = .;     /* define a global symbol at ncache data end */
+  } > m_data
+
+  __DATA_END = __DATA_ROM + (__data_end__ - __data_start__);
+  text_end = ORIGIN(m_text) + LENGTH(m_text);
+  ASSERT(__DATA_END <= text_end, "region m_text overflowed with text and data")
+
+  /* Uninitialized data section */
+  .bss :
+  {
+    /* This is used by the startup in order to initialize the .bss section */
+    . = ALIGN(4);
+    __START_BSS = .;
+    __bss_start__ = .;
+    *(.bss)
+    *(.bss*)
+    *(COMMON)
+    . = ALIGN(4);
+    __bss_end__ = .;
+    __END_BSS = .;
+  } > m_data
+
+  .heap :
+  {
+    . = ALIGN(8);
+    __end__ = .;
+    PROVIDE(end = .);
+    __HeapBase = .;
+    . += HEAP_SIZE;
+    __HeapLimit = .;
+    __heap_limit = .; /* Add for _sbrk */
+  } > m_data
+
+
+  .stack :
+  {
+    . = ALIGN(8);
+    . += STACK_SIZE;
+  } > m_data
+
+
+  /* Initializes stack on the end of block */
+  __StackTop   = ORIGIN(m_data) + LENGTH(m_data);
+  __StackLimit = __StackTop - STACK_SIZE;
+  PROVIDE(__stack = __StackTop);
+
+  .ARM.attributes 0 : { *(.ARM.attributes) }
+
+  ASSERT(__StackLimit >= __HeapLimit, "region m_data overflowed with stack and heap")
+}
+
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_all.bat b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_all.bat
new file mode 100644
index 000000000..2c2a394e4
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_all.bat
@@ -0,0 +1,43 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=debug  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=release  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=ddr_debug  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=ddr_release  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=flash_debug  .
+mingw32-make -j
+
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=flash_release  .
+mingw32-make -j
+
+IF "%1" == "" ( pause )
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_all.sh b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_all.sh
new file mode 100755
index 000000000..e133b8d66
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_all.sh
@@ -0,0 +1,43 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=debug  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=release  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=ddr_debug  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=ddr_release  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=flash_debug  .
+make -j
+
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=flash_release  .
+make -j
+
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_debug.bat b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_debug.bat
new file mode 100644
index 000000000..f528316a8
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_debug.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=ddr_debug  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_debug.sh b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_debug.sh
new file mode 100755
index 000000000..ee16e2ea2
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_debug.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=ddr_debug  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_release.bat b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_release.bat
new file mode 100644
index 000000000..79c227d96
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_release.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=ddr_release  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_release.sh b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_release.sh
new file mode 100755
index 000000000..c4da7ac0c
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_ddr_release.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=ddr_release  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_debug.bat b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_debug.bat
new file mode 100644
index 000000000..91c5925be
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_debug.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=debug  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_debug.sh b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_debug.sh
new file mode 100755
index 000000000..088872c90
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_debug.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=debug  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_debug.bat b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_debug.bat
new file mode 100644
index 000000000..e9e1ee337
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_debug.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=flash_debug  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_debug.sh b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_debug.sh
new file mode 100755
index 000000000..9730d0f35
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_debug.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=flash_debug  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_release.bat b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_release.bat
new file mode 100644
index 000000000..7f21801a6
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_release.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=flash_release  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_release.sh b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_release.sh
new file mode 100755
index 000000000..d2973cc77
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_flash_release.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=flash_release  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_release.bat b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_release.bat
new file mode 100644
index 000000000..e603434be
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_release.bat
@@ -0,0 +1,6 @@
+if exist CMakeFiles (RD /s /Q CMakeFiles)
+if exist Makefile (DEL /s /Q /F Makefile)
+if exist cmake_install.cmake (DEL /s /Q /F cmake_install.cmake)
+if exist CMakeCache.txt (DEL /s /Q /F CMakeCache.txt)
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=release  .
+mingw32-make -j 2> build_log.txt 
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_release.sh b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_release.sh
new file mode 100755
index 000000000..094cbd202
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/build_release.sh
@@ -0,0 +1,7 @@
+#!/bin/sh
+if [ -d "CMakeFiles" ];then rm -rf CMakeFiles; fi
+if [ -f "Makefile" ];then rm -f Makefile; fi
+if [ -f "cmake_install.cmake" ];then rm -f cmake_install.cmake; fi
+if [ -f "CMakeCache.txt" ];then rm -f CMakeCache.txt; fi
+cmake -DCMAKE_TOOLCHAIN_FILE="../../../../../core/tools/cmake_toolchain_files/armgcc.cmake" -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=release  .
+make -j 2>&1 | tee build_log.txt
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/clean.bat b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/clean.bat
new file mode 100644
index 000000000..d370a6ff0
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/clean.bat
@@ -0,0 +1,3 @@
+RD /s /Q flexspi_nor_sdram_debug flexspi_nor_sdram_release sdram_debug sdram_release flexspi_nor_debug flexspi_nor_release CMakeFiles
+DEL /s /Q /F Makefile cmake_install.cmake CMakeCache.txt
+pause
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/clean.sh b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/clean.sh
new file mode 100755
index 000000000..c337df9ef
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/clean.sh
@@ -0,0 +1,3 @@
+#!/bin/sh
+rm -rf flash_debug flash_release ddr_release ddr_debug release debug CMakeFiles
+rm -rf Makefile cmake_install.cmake CMakeCache.txt
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/config.cmake b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/config.cmake
new file mode 100755
index 000000000..409237f10
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/config.cmake
@@ -0,0 +1,5 @@
+# config to select component, the format is CONFIG_USE_${component}
+set(CONFIG_USE_driver_iuart true)
+set(CONFIG_USE_middleware_baremetal true)
+set(CONFIG_USE_soem_ifport_enet true)
+set(MCUX_DEVICE "MIMX8ML8")
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/flags.cmake b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/flags.cmake
new file mode 100755
index 000000000..0db61d8d8
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/armgcc/flags.cmake
@@ -0,0 +1,570 @@
+SET(CMAKE_ASM_FLAGS_DEBUG " \
+    ${CMAKE_ASM_FLAGS_DEBUG} \
+    -DDEBUG \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -g \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_RELEASE " \
+    ${CMAKE_ASM_FLAGS_RELEASE} \
+    -DNDEBUG \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_DDR_DEBUG " \
+    ${CMAKE_ASM_FLAGS_DDR_DEBUG} \
+    -DDEBUG \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -g \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_DDR_RELEASE " \
+    ${CMAKE_ASM_FLAGS_DDR_RELEASE} \
+    -DNDEBUG \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_FLASH_DEBUG " \
+    ${CMAKE_ASM_FLAGS_FLASH_DEBUG} \
+    -DDEBUG \
+    -DFLASH_TARGET \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -g \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_ASM_FLAGS_FLASH_RELEASE " \
+    ${CMAKE_ASM_FLAGS_FLASH_RELEASE} \
+    -DNDEBUG \
+    -DFLASH_TARGET \
+    -D__STARTUP_CLEAR_BSS \
+    -D__STARTUP_INITIALIZE_NONCACHEDATA \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_DEBUG " \
+    ${CMAKE_C_FLAGS_DEBUG} \
+    -DDEBUG \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_RELEASE " \
+    ${CMAKE_C_FLAGS_RELEASE} \
+    -DNDEBUG \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_DDR_DEBUG " \
+    ${CMAKE_C_FLAGS_DDR_DEBUG} \
+    -DDEBUG \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_DDR_RELEASE " \
+    ${CMAKE_C_FLAGS_DDR_RELEASE} \
+    -DNDEBUG \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_FLASH_DEBUG " \
+    ${CMAKE_C_FLAGS_FLASH_DEBUG} \
+    -DDEBUG \
+    -DFLASH_TARGET \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_C_FLAGS_FLASH_RELEASE " \
+    ${CMAKE_C_FLAGS_FLASH_RELEASE} \
+    -DNDEBUG \
+    -DFLASH_TARGET \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -std=gnu99 \
+")
+SET(CMAKE_CXX_FLAGS_DEBUG " \
+    ${CMAKE_CXX_FLAGS_DEBUG} \
+    -DDEBUG \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_RELEASE " \
+    ${CMAKE_CXX_FLAGS_RELEASE} \
+    -DNDEBUG \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_DDR_DEBUG " \
+    ${CMAKE_CXX_FLAGS_DDR_DEBUG} \
+    -DDEBUG \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_DDR_RELEASE " \
+    ${CMAKE_CXX_FLAGS_DDR_RELEASE} \
+    -DNDEBUG \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_FLASH_DEBUG " \
+    ${CMAKE_CXX_FLAGS_FLASH_DEBUG} \
+    -DDEBUG \
+    -DFLASH_TARGET \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -g \
+    -O0 \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_CXX_FLAGS_FLASH_RELEASE " \
+    ${CMAKE_CXX_FLAGS_FLASH_RELEASE} \
+    -DNDEBUG \
+    -DFLASH_TARGET \
+    -DCPU_MIMX8ML8DVNLZ \
+    -DMCUXPRESSO_SDK \
+    -Os \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -Wno-address-of-packed-member \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -mthumb \
+    -MMD \
+    -MP \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mapcs \
+    -fno-rtti \
+    -fno-exceptions \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_DEBUG " \
+    ${CMAKE_EXE_LINKER_FLAGS_DEBUG} \
+    -g \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8ML8xxxxx_cm7_ram.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_RELEASE " \
+    ${CMAKE_EXE_LINKER_FLAGS_RELEASE} \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8ML8xxxxx_cm7_ram.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_DDR_DEBUG " \
+    ${CMAKE_EXE_LINKER_FLAGS_DDR_DEBUG} \
+    -g \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8ML8xxxxx_cm7_ddr_ram.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_DDR_RELEASE " \
+    ${CMAKE_EXE_LINKER_FLAGS_DDR_RELEASE} \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8ML8xxxxx_cm7_ddr_ram.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_FLASH_DEBUG " \
+    ${CMAKE_EXE_LINKER_FLAGS_FLASH_DEBUG} \
+    -g \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8ML8xxxxx_cm7_flash.ld -static \
+")
+SET(CMAKE_EXE_LINKER_FLAGS_FLASH_RELEASE " \
+    ${CMAKE_EXE_LINKER_FLAGS_FLASH_RELEASE} \
+    -mcpu=cortex-m7 \
+    -Wall \
+    -mfloat-abi=hard \
+    -mfpu=fpv5-sp-d16 \
+    -Wl,--print-memory-usage \
+    --specs=nano.specs \
+    --specs=nosys.specs \
+    -fno-common \
+    -ffunction-sections \
+    -fdata-sections \
+    -ffreestanding \
+    -fno-builtin \
+    -mthumb \
+    -mapcs \
+    -Xlinker \
+    --gc-sections \
+    -Xlinker \
+    -static \
+    -Xlinker \
+    -z \
+    -Xlinker \
+    muldefs \
+    -Xlinker \
+    -Map=output.map \
+    -T${ProjDirPath}/MIMX8ML8xxxxx_cm7_flash.ld -static \
+")
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/pin_mux.c b/evkmimx8mp/demo_apps/soem_gpio_pulse/pin_mux.c
new file mode 100644
index 000000000..cc275b0af
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/pin_mux.c
@@ -0,0 +1,146 @@
+/*
+ * Copyright 2019-2020 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+/***********************************************************************************************************************
+ * This file was generated by the MCUXpresso Config Tools. Any manual edits made to this file
+ * will be overwritten if the respective MCUXpresso Config Tools is used to update this file.
+ **********************************************************************************************************************/
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+!!GlobalInfo
+product: Pins v8.0
+processor: MIMX8ML8xxxLZ
+package_id: MIMX8ML8DVNLZ
+mcu_data: ksdk2_0
+processor_version: 0.0.0
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+#include "fsl_common.h"
+#include "fsl_iomuxc.h"
+#include "pin_mux.h"
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitBootPins
+ * Description   : Calls initialization functions.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitBootPins(void)
+{
+}
+
+/*
+ * TEXT BELOW IS USED AS SETTING FOR TOOLS *************************************
+BOARD_InitPins:
+- options: {callFromInitBoot: 'false', coreID: m7}
+- pin_list:
+  - {pin_num: AJ5, peripheral: UART4, signal: uart_rx, pin_signal: UART4_RXD, PE: Enabled, PUE: Enabled, DSE: X1}
+  - {pin_num: AH5, peripheral: UART4, signal: uart_tx, pin_signal: UART4_TXD, PE: Enabled, PUE: Enabled, DSE: X1}
+  - {pin_num: AH9, peripheral: ENET1, signal: enet_mdc, pin_signal: SAI1_RXD2, PE: Disabled, DSE: X2}
+  - {pin_num: AJ8, peripheral: ENET1, signal: enet_mdio, pin_signal: SAI1_RXD3, PE: Disabled, DSE: X2}
+  - {pin_num: AD10, peripheral: ENET1, signal: 'enet_rgmii_rd, 0', pin_signal: SAI1_RXD4, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AE10, peripheral: ENET1, signal: 'enet_rgmii_rd, 1', pin_signal: SAI1_RXD5, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH10, peripheral: ENET1, signal: 'enet_rgmii_rd, 2', pin_signal: SAI1_RXD6, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AH12, peripheral: ENET1, signal: 'enet_rgmii_rd, 3', pin_signal: SAI1_RXD7, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AF12, peripheral: ENET1, signal: enet_rgmii_rx_ctl, pin_signal: SAI1_TXFS, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ12, peripheral: ENET1, signal: enet_rgmii_rxc, pin_signal: SAI1_TXC, PE: Disabled, HYS: Schmitt, FSEL: Fast}
+  - {pin_num: AJ11, peripheral: ENET1, signal: 'enet_rgmii_td, 0', pin_signal: SAI1_TXD0, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AJ10, peripheral: ENET1, signal: 'enet_rgmii_td, 1', pin_signal: SAI1_TXD1, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH11, peripheral: ENET1, signal: 'enet_rgmii_td, 2', pin_signal: SAI1_TXD2, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AD12, peripheral: ENET1, signal: 'enet_rgmii_td, 3', pin_signal: SAI1_TXD3, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH13, peripheral: ENET1, signal: enet_rgmii_tx_ctl, pin_signal: SAI1_TXD4, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AH14, peripheral: ENET1, signal: enet_rgmii_txc, pin_signal: SAI1_TXD5, PE: Disabled, HYS: CMOS, FSEL: Fast}
+  - {pin_num: AC10, peripheral: GPIO4, signal: 'gpio_io, 02', pin_signal: SAI1_RXD0, PE: Disabled, FSEL: Slow, DSE: X1}
+ * BE CAREFUL MODIFYING THIS COMMENT - IT IS YAML SETTINGS FOR TOOLS ***********
+ */
+
+/* FUNCTION ************************************************************************************************************
+ *
+ * Function Name : BOARD_InitPins
+ * Description   : Configures pin routing and optionally pin electrical features.
+ *
+ * END ****************************************************************************************************************/
+void BOARD_InitPins(void) {                                /*!< Function assigned for the core: Cortex-M7F[m7] */
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD0_GPIO4_IO02, 0U);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD2_ENET1_MDC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD2_ENET1_MDC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(1U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD3_ENET1_MDIO, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD3_ENET1_MDIO, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(1U));
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD4_ENET1_RGMII_RD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD5_ENET1_RGMII_RD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD6_ENET1_RGMII_RD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_RXD7_ENET1_RGMII_RD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXC_ENET1_RGMII_RXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD0_ENET1_RGMII_TD0, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD1_ENET1_RGMII_TD1, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD2_ENET1_RGMII_TD2, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD3_ENET1_RGMII_TD3, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD4_ENET1_RGMII_TX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXD5_ENET1_RGMII_TXC, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK);
+    IOMUXC_SetPinMux(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_SAI1_TXFS_ENET1_RGMII_RX_CTL, 
+                        IOMUXC_SW_PAD_CTL_PAD_DSE(3U) |
+                        IOMUXC_SW_PAD_CTL_PAD_FSEL_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_HYS_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_RXD_UART4_RX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_RXD_UART4_RX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+    IOMUXC_SetPinMux(IOMUXC_UART4_TXD_UART4_TX, 0U);
+    IOMUXC_SetPinConfig(IOMUXC_UART4_TXD_UART4_TX, 
+                        IOMUXC_SW_PAD_CTL_PAD_PUE_MASK |
+                        IOMUXC_SW_PAD_CTL_PAD_PE_MASK);
+}
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/pin_mux.h b/evkmimx8mp/demo_apps/soem_gpio_pulse/pin_mux.h
new file mode 100644
index 000000000..971278287
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/pin_mux.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2019-2020 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ */
+
+
+#ifndef _PIN_MUX_H_
+#define _PIN_MUX_H_
+
+#include "board.h"
+
+/***********************************************************************************************************************
+ * Definitions
+ **********************************************************************************************************************/
+
+/*!
+ * @addtogroup pin_mux
+ * @{
+ */
+
+/***********************************************************************************************************************
+ * API
+ **********************************************************************************************************************/
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+
+/*!
+ * @brief Calls initialization functions.
+ *
+ */
+void BOARD_InitBootPins(void);
+
+/*!
+ * @brief Configures pin routing and optionally pin electrical features.
+ *
+ */
+void BOARD_InitPins(void);                                 /*!< Function assigned for the core: Cortex-M7F[m7] */
+
+#if defined(__cplusplus)
+}
+#endif
+
+/*!
+ * @}
+ */
+#endif /* _PIN_MUX_H_ */
+
+/***********************************************************************************************************************
+ * EOF
+ **********************************************************************************************************************/
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/soem_config.h b/evkmimx8mp/demo_apps/soem_gpio_pulse/soem_config.h
new file mode 100644
index 000000000..2e1eb44bb
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/soem_config.h
@@ -0,0 +1,50 @@
+#ifndef __SOEM__CONFIG__H__
+#define __SOEM__CONFIG__H__
+#include <sys/time.h>
+
+/** max. etries in EtherCAT error list */
+#define EC_MAXELIST       64
+
+/** max. length of readable name in slavelist and Object Description List */
+#define EC_MAXNAME        40
+
+/** max. number of slaves in array */
+#define EC_MAXSLAVE       100
+
+/** max. number of groups */
+#define EC_MAXGROUP       2
+
+/** max. number of IO segments per group */
+#define EC_MAXIOSEGMENTS  64
+
+/** max. mailbox size */
+#define EC_MAXMBX         1486
+
+/** max. eeprom PDO entries */
+#define EC_MAXEEPDO       0x200
+
+/** max. SM used */
+#define EC_MAXSM          8
+
+/** max. FMMU used */
+#define EC_MAXFMMU        4
+
+/** max. Adapter */
+#define EC_MAXLEN_ADAPTERNAME    128
+
+/* CoE */
+/** max entries in Object Description list */
+#define EC_MAXODLIST   1024
+
+/** max entries in Object Entry list */
+#define EC_MAXOELIST   256
+
+/* OS */
+#define MAX_SOEM_TASK 1
+
+/* Static allocate for SOEM stack when configSUPPORT_STATIC_ALLOCATION is configured*/
+#define MAX_SOEM_TASK_STACK 256
+#define MAX_SOEM_MUTE 1
+
+void osal_gettime(struct timeval *);
+#endif
diff --git a/evkmimx8mp/demo_apps/soem_gpio_pulse/soem_gpio_pulse.c b/evkmimx8mp/demo_apps/soem_gpio_pulse/soem_gpio_pulse.c
new file mode 100644
index 000000000..11e4207c9
--- /dev/null
+++ b/evkmimx8mp/demo_apps/soem_gpio_pulse/soem_gpio_pulse.c
@@ -0,0 +1,330 @@
+/*
+ * Copyright (c) 2015, Freescale Semiconductor, Inc.
+ * Copyright 2016-2020 NXP
+ * All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+#include <sys/time.h>
+#include "pin_mux.h"
+#include "clock_config.h"
+#include "board.h"
+#include "fsl_debug_console.h"
+#include "fsl_enet.h"
+#include "fsl_phy.h"
+#if defined(FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET) && FSL_FEATURE_MEMORY_HAS_ADDRESS_OFFSET
+#include "fsl_memory.h"
+#endif
+#include "fsl_gpio.h"
+#include "fsl_iomuxc.h"
+#include "fsl_enet_mdio.h"
+#include "fsl_phyrtl8211f.h"
+#include "fsl_gpt.h"
+
+#include "ethercattype.h"
+#include "nicdrv.h"
+#include "ethercatbase.h"
+#include "ethercatmain.h"
+#include "ethercatdc.h"
+#include "ethercatcoe.h"
+#include "ethercatfoe.h"
+#include "ethercatconfig.h"
+#include "ethercatprint.h"
+#include "enet/soem_enet.h"
+#include "soem_port.h"
+
+
+int _write(int handle, char *buffer, int size)
+{
+	if (NULL == buffer)
+	{
+		/* return -1 if error. */
+		return -1;
+	}
+
+	/* This function only writes to "standard out" and "standard err" for all other file handles it returns failure. */
+	if ((handle != 1) && (handle != 2))
+	{
+		return -1;
+	}
+
+	int i;
+	for(i = 0; i < size; i++) {
+		if (buffer[i] == '\n') {
+			DbgConsole_Putchar('\r');
+		}
+		DbgConsole_Putchar(buffer[i]);
+	}
+
+	return size;
+}
+
+
+#define OSEM_PORT_NAME 			"enet1"
+#define OSEM_PORT				ENET1
+#define PHY_ADDRESS				0x01u
+#define PHY_INTERFACE_RGMII
+#define ENET_CLOCK_FREQ 250000000
+
+#define SOEM_PERIOD 125 // 125us
+
+#define EC_TIMEOUTMON 500
+#define EXAMPLE_PHY_INTERFACE_RGMII
+#ifndef PHY_AUTONEGO_TIMEOUT_COUNT
+#define PHY_AUTONEGO_TIMEOUT_COUNT (100000)
+#endif
+#ifndef PHY_STABILITY_DELAY_US
+#define PHY_STABILITY_DELAY_US (0U)
+#endif
+
+#define ENET_RXBD_NUM          (4)
+#define ENET_TXBD_NUM          (4)
+
+#define ENET_RXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+#define ENET_TXBUFF_SIZE       (ENET_FRAME_MAX_FRAMELEN)
+
+/*********************************************************************
+GPT timer will be used to calculate the system time and delay;
+*********************************************************************/
+#define OSAL_TIMER_IRQ_ID		GPT1_IRQn
+#define OSAL_TIMER				GPT1
+#define OSAL_TIMER_IRQHandler	GPT1_IRQHandler
+#define OSAL_TIMER_CLK_FREQ		(CLOCK_GetPllFreq(kCLOCK_SystemPll1Ctrl) / (CLOCK_GetRootPreDivider(kCLOCK_RootGpt1)) / \
+     (CLOCK_GetRootPostDivider(kCLOCK_RootGpt1)) / 2) /* SYSTEM PLL1 DIV2 */
+
+/*Updated on GPT IRQ*/
+static struct timeval system_time_base = {
+	.tv_sec = 0,
+	.tv_usec =  0
+};
+
+void OSAL_TIMER_IRQHandler(void)
+{
+	/* Clear interrupt flag.*/
+	GPT_ClearStatusFlags(OSAL_TIMER, kGPT_OutputCompare1Flag);
+	system_time_base.tv_sec += 1; // add 1000000us
+/* Add for ARM errata 838869, affects Cortex-M4, Cortex-M4F, Cortex-M7, Cortex-M7F Store immediate overlapping
+	exception return operation might vector to incorrect interrupt */
+#if defined __CORTEX_M && (__CORTEX_M == 4U || __CORTEX_M == 7U)
+	__DSB();
+#endif
+}
+
+void osal_timer_init()
+{
+	gpt_config_t gptConfig;
+    CLOCK_SetRootMux(kCLOCK_RootGpt1, kCLOCK_GptRootmuxSysPll1Div2); /* Set GPT1 source to SYSTEM PLL1 DIV2 400MHZ */
+    CLOCK_SetRootDivider(kCLOCK_RootGpt1, 1U, 4U);                   /* Set root clock to 400MHZ / 4 = 100MHZ */
+	GPT_GetDefaultConfig(&gptConfig);
+	GPT_Init(OSAL_TIMER, &gptConfig);
+	/*Divide GPT clock source frequency to 1MHz*/
+	GPT_SetClockDivider(OSAL_TIMER, 100);
+	/* Set both GPT modules to 1 second duration */
+	GPT_SetOutputCompareValue(OSAL_TIMER, kGPT_OutputCompare_Channel1, 1000000);
+	/* Enable GPT Output Compare1 interrupt */
+	GPT_EnableInterrupts(OSAL_TIMER, kGPT_OutputCompare1InterruptEnable);
+	/* Enable at the Interrupt */
+	EnableIRQ(OSAL_TIMER_IRQ_ID);
+	GPT_StartTimer(OSAL_TIMER);
+}
+
+void osal_gettime(struct timeval *current_time)
+{
+	uint32_t sec = system_time_base.tv_sec;
+	uint32_t usec = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	uint32_t sec_again = system_time_base.tv_sec;
+	/*in case of that the GPT IRQ occurred during the sec and usec reading obove*/
+	if (sec != sec_again) {
+		usec = GPT_GetCurrentTimerCount(OSAL_TIMER);
+	}
+	current_time->tv_sec = sec_again;
+	current_time->tv_usec = usec;
+	//printf("get_time %d. %d\r\n", current_time->tv_sec, current_time->tv_usec);
+}
+
+/*******************************************************************************
+ * OSHW: register enet port to SOEM stack
+ ******************************************************************************/
+
+/*! @brief Buffer descriptors should be in non-cacheable region and should be align to "ENET_BUFF_ALIGNMENT". */
+AT_NONCACHEABLE_SECTION_ALIGN(enet_rx_bd_struct_t g_rxBuffDescrip[ENET_RXBD_NUM], ENET_BUFF_ALIGNMENT);
+AT_NONCACHEABLE_SECTION_ALIGN(enet_tx_bd_struct_t g_txBuffDescrip[ENET_TXBD_NUM], ENET_BUFF_ALIGNMENT);
+/*! @brief The data buffers can be in cacheable region or in non-cacheable region.
+ * If use cacheable region, the alignment size should be the maximum size of "CACHE LINE SIZE" and "ENET_BUFF_ALIGNMENT"
+ * If use non-cache region, the alignment size is the "ENET_BUFF_ALIGNMENT".
+ */
+SDK_ALIGN(uint8_t g_rxDataBuff[ENET_RXBD_NUM][SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+SDK_ALIGN(uint8_t g_txDataBuff[ENET_TXBD_NUM][SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT)],
+          ENET_BUFF_ALIGNMENT);
+
+enet_buffer_config_t buffConfig[] = {{
+    ENET_RXBD_NUM,
+    ENET_TXBD_NUM,
+    SDK_SIZEALIGN(ENET_RXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    SDK_SIZEALIGN(ENET_TXBUFF_SIZE, ENET_BUFF_ALIGNMENT),
+    &g_rxBuffDescrip[0],
+    &g_txBuffDescrip[0],
+    &g_rxDataBuff[0][0],
+    &g_txDataBuff[0][0],
+    true,
+    true,
+    NULL,
+}};
+
+struct enet_if_port if_port;
+
+int if_port_init()
+{
+	memset(&if_port, 0, sizeof(if_port));
+	if_port.mdioHandle.ops = &enet_ops;
+	if_port.phyHandle.ops = &phyrtl8211f_ops;
+	if_port.bufferConfig = buffConfig;
+	if_port.base = OSEM_PORT;
+/* The miiMode should be set according to the different PHY interfaces. */
+#ifdef EXAMPLE_PHY_INTERFACE_RGMII
+	if_port.mii_mode = kENET_RgmiiMode;
+#else
+	if_port.mii_mode = kENET_RmiiMode;
+#endif
+	if_port.phy_config.autoNeg = true;
+	if_port.phy_config.phyAddr = PHY_ADDRESS;
+	if_port.srcClock_Hz = ENET_CLOCK_FREQ;
+	if_port.phy_autonego_timeout_count = PHY_AUTONEGO_TIMEOUT_COUNT;
+	if_port.phy_stability_delay_us = PHY_STABILITY_DELAY_US;
+	return register_soem_port(OSEM_PORT_NAME, "enet", &if_port);
+}
+
+char IOmap[100];
+
+void control_task(char *ifname)
+{
+	int oloop, iloop;
+	int expectedWKC;
+	volatile int wkc;
+	int old_switch0 = 0, old_switch1 = 0;
+	struct timeval sleep_time;
+	struct timeval target_time;
+	struct timeval end_time;
+	struct timeval period_time;
+	sleep_time.tv_sec = 0;
+	sleep_time.tv_usec = SOEM_PERIOD;
+	
+/* initialise SOEM, and if_port */
+	if (ec_init(ifname)) {
+		printf("ec_init on %s succeeded.\n",ifname);
+		if ( ec_config_init(FALSE) > 0 ) {
+			printf("%d slaves found and configured.\n",ec_slavecount);
+			ec_config_map(&IOmap);
+			ec_configdc();
+			printf("Slaves mapped, state to SAFE_OP.\n");
+			/* wait for all slaves to reach SAFE_OP state */
+			ec_statecheck(0, EC_STATE_SAFE_OP,  EC_TIMEOUTSTATE * 4);
+			oloop = ec_slave[2].Obytes;
+			iloop = ec_slave[3].Ibytes;
+			printf("oloop = %d, iloop = %d\n", oloop, iloop);
+
+			printf("Request operational state for all slaves\n");
+			expectedWKC = (ec_group[0].outputsWKC * 2) + ec_group[0].inputsWKC;
+			printf("Calculated workcounter %d\n", expectedWKC);
+			ec_slave[0].state = EC_STATE_OPERATIONAL;
+			/* send one valid process data to make outputs in slaves happy*/
+			ec_send_processdata();
+			ec_receive_processdata(EC_TIMEOUTRET);
+			/* request OP state for all slaves */
+			ec_writestate(0);
+			char chk = 40;
+			/* wait for all slaves to reach OP state */
+			do {
+				ec_send_processdata();
+				ec_receive_processdata(EC_TIMEOUTRET);
+				ec_statecheck(0, EC_STATE_OPERATIONAL, 50000);
+			}  while(chk-- && (ec_slave[0].state != EC_STATE_OPERATIONAL));
+			printf("Operational state reached for all slaves.\n");
+			/* cyclic loop */
+			int is_expired;
+			period_time.tv_usec = SOEM_PERIOD;
+			period_time.tv_sec = 0;
+			ec_send_processdata();
+			osal_gettime(&target_time);
+			while (1) {
+				timeradd(&target_time, &period_time, &target_time);
+				wkc = ec_receive_processdata(EC_TIMEOUTRET);
+				if(wkc >= expectedWKC) {
+					if ((*(ec_slave[3].inputs) & 0x01)  && old_switch0 == 0) {
+						if (*(ec_slave[2].outputs) & 0x04 )
+							*(ec_slave[2].outputs) &= ~0x04;
+						else
+							*(ec_slave[2].outputs) |= 0x04;
+					}
+
+					if ((*(ec_slave[3].inputs) & 0x02)  && old_switch1 == 0) {
+						if (*(ec_slave[2].outputs) & 0x04 )
+							*(ec_slave[2].outputs) &= ~0x04;
+						else
+							*(ec_slave[2].outputs) |= 0x04;
+					}
+
+					old_switch0 = *(ec_slave[3].inputs) & 0x01;
+					old_switch1 = *(ec_slave[3].inputs) & 0x02;
+					if (*(ec_slave[2].outputs) & 0x02 )
+						*(ec_slave[2].outputs) &= ~0x02;
+					else
+						*(ec_slave[2].outputs) |= 0x02;
+				}
+				osal_gettime(&end_time);
+				ec_send_processdata();
+				is_expired = timercmp(&target_time, &end_time, <= );
+
+				if (!is_expired)  {
+					timersub(&target_time, &end_time, &sleep_time);
+					osal_usleep(sleep_time.tv_usec);
+				}
+				else {
+					printf("period time is \n");
+					while(1);
+				}
+			}
+		}
+	}
+}
+
+/*!
+ * @brief Main function
+ */
+int main(void)
+{
+	/* Hardware Initialization. */
+    BOARD_InitMemory();
+    BOARD_RdcInit();
+    BOARD_InitPins();
+    BOARD_BootClockRUN();
+    BOARD_InitDebugConsole();
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetAxi, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetAxi, kCLOCK_EnetAxiRootmuxSysPll2Div4); /* SYSTEM PLL2 divided by 4: 250Mhz */
+
+    CLOCK_SetRootDivider(kCLOCK_RootEnetTimer, 1U, 1U);
+    CLOCK_SetRootMux(kCLOCK_RootEnetTimer, kCLOCK_EnetTimerRootmuxSysPll2Div10); /* SYSTEM PLL2 divided by 10: 100Mhz */
+
+    gpio_pin_config_t gpio_config = {kGPIO_DigitalOutput, 0, kGPIO_NoIntmode};
+
+    GPIO_PinInit(GPIO4, 2, &gpio_config);
+
+	GPIO_WritePinOutput(GPIO4, 2, 0);
+    SDK_DelayAtLeastUs(10000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+    GPIO_WritePinOutput(GPIO4, 2, 1);
+    SDK_DelayAtLeastUs(30000, SDK_DEVICE_MAXIMUM_CPU_CLOCK_FREQUENCY);
+
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done0_IRQn);
+    EnableIRQ(ENET1_MAC0_Rx_Tx_Done1_IRQn);
+
+    osal_timer_init();
+    if_port_init();
+    control_task(OSEM_PORT_NAME);
+    return 0;
+}
-- 
2.17.1

